Table of Contents

Essential C++ By Stanley B. Lippman
Publisher : Addison Wesley Pub Date : September 12, 2002
ISBN : 0-201-48518-4 Pages : 416

"Readers can pick up this book and become familiar with C++ in a short time. Stan has taken a very broad and complicated topic and reduced it to the essentials that budding C++ programmers need to know to write real programs. His case study is effective and provides a familiar thread throughout the book." -Steve Vinoski, IONA
For the practicing programmer with little time to spare, Essential C++ offers a fast-track to learning and working with C++ on the job. This book is specifically designed to bring you up to speed in a short amount of time. It focuses on the elements of C++ programming that you are most likely to encounter and examines features and techniques that help solve real-world programming challenges.
Essential C++ presents the basics of C++ in the context of procedural, generic, objectbased, and object-oriented programming. It is organized around a series of increasingly complex programming problems, and language features are introduced as solutions to these problems. In this way you will not only learn about the functions and structure of C++, but will understand their purpose and rationale.
You will find in-depth coverage of key topics such as:
• Generic programming and the Standard Template Library (STL) • Object-based programming and class design • Object-oriented programming and the design of class hierarchies • Function and class template design and use • Exception handling and Run-Time Type Identification
In addition, an invaluable appendix provides complete solutions to, and detailed explanations of, the programming exercises found at the end of each chapter. A second appendix offers a quick reference handbook for the generic algorithms, providing an example of how each is used.
This concise tutorial will give you a working knowledge of C++ and a firm foundation on which to further your professional expertise.

Table of Content
Table of Content .................................................................................................................. i Copyright.............................................................................................................................. v
Dedication ...................................................................................................................... vi Preface................................................................................................................................ vi
Structure of This Book................................................................................................. vii A Note on the Source Code....................................................................................... viii Acknowledgments....................................................................................................... viii Where to Find More Information ................................................................................. ix Typographical Conventions ......................................................................................... ix Chapter 1. Basic C++ Programming ............................................................................... 1 1.1 How to Write a C++ Program ................................................................................ 1 1.2 Defining and Initializing a Data Object ................................................................. 6 1.3 Writing Expressions ................................................................................................ 9 1.4 Writing Conditional and Loop Statements ......................................................... 13 1.5 How to Use Arrays and Vectors .......................................................................... 19 1.6 Pointers Allow for Flexibility ................................................................................. 23 1.7 Writing and Reading Files .................................................................................... 26 Chapter 2. Procedural Programming............................................................................. 30 2.1 How to Write a Function ....................................................................................... 30 2.2 Invoking a Function ............................................................................................... 35 2.3 Providing Default Parameter Values .................................................................. 43 2.4 Using Local Static Objects ................................................................................... 45 2.5 Declaring a Function Inline .................................................................................. 47 2.6 Providing Overloaded Functions......................................................................... 48 2.7 Defining and Using Template Functions............................................................ 49 2.8 Pointers to Functions Add Flexibility .................................................................. 52 2.9 Setting Up a Header File ...................................................................................... 54 Chapter 3. Generic Programming.................................................................................. 57 3.1 The Arithmetic of Pointers.................................................................................... 57 3.2 Making Sense of Iterators.................................................................................... 62 3.3 Operations Common to All Containers .............................................................. 65 3.4 Using the Sequential Containers ........................................................................ 66 3.5 Using the Generic Algorithms.............................................................................. 69 3.6 How to Design a Generic Algorithm ................................................................... 71 3.7 Using a Map ........................................................................................................... 77 3.8 Using a Set ............................................................................................................. 78 3.9 How to Use Iterator Inserters............................................................................... 80 3.10 Using the iostream Iterators .............................................................................. 81 Chapter 4. Object-Based Programming........................................................................ 85 4.1 How to Implement a Class ................................................................................... 86 4.2 What Are Class Constructors and the Class Destructor? ............................... 89 4.3 What Are mutable and const? ........................................................................ 94 4.4 What Is the this Pointer?................................................................................... 97 4.5 Static Class Members........................................................................................... 99 4.6 Building an Iterator Class ................................................................................... 102 4.7 Collaboration Sometimes Requires Friendship .............................................. 106 4.8 Implementing a Copy Assignment Operator ................................................... 108 4.9 Implementing a Function Object ....................................................................... 109 4.10 Providing Class Instances of the iostream Operators ................................. 111 4.11 Pointers to Class Member Functions ............................................................. 112 Chapter 5. Object-Oriented Programming.................................................................. 117 5.1 Object-Oriented Programming Concepts......................................................... 117
ii

5.2 A Tour of Object-Oriented Programming ......................................................... 119 5.3 Polymorphism without Inheritance.................................................................... 123 5.4 Defining an Abstract Base Class ...................................................................... 125 5.5 Defining a Derived Class.................................................................................... 128 5.6 Using an Inheritance Hierarchy......................................................................... 133 5.7 How Abstract Should a Base Class Be?.......................................................... 135 5.8 Initialization, Destruction, and Copy ................................................................. 136 5.9 Defining a Derived Class Virtual Function....................................................... 138 5.10 Run-Time Type Identification .......................................................................... 141 Chapter 6. Programming with Templates ................................................................... 144 6.1 Parameterized Types.......................................................................................... 145 6.2 The Template Class Definition .......................................................................... 147 6.3 Handling Template Type Parameters .............................................................. 148 6.4 Implementing the Template Class .................................................................... 150 6.5 A Function Template Output Operator............................................................. 155 6.6 Constant Expressions and Default Parameters.............................................. 156 6.7 Template Parameters as Strategy .................................................................... 160 6.8 Member Template Functions............................................................................. 161 Chapter 7. Exception Handling..................................................................................... 164 7.1 Throwing an Exception ....................................................................................... 164 7.2 Catching an Exception........................................................................................ 165 7.3 Trying for an Exception....................................................................................... 167 7.4 Local Resource Management............................................................................ 170 7.5 The Standard Exceptions................................................................................... 172 Appendix A. Exercise Solutions ................................................................................... 176 Exercise 1.4 ................................................................................................................ 176 Exercise 1.5 ................................................................................................................ 177 Exercise 1.6 ................................................................................................................ 179 Exercise 1.7 ................................................................................................................ 180 Exercise 1.8 ................................................................................................................ 181 Exercise 2.1 ................................................................................................................ 182 Exercise 2.2 ................................................................................................................ 183 Exercise 2.3 ................................................................................................................ 184 Exercise 2.4 ................................................................................................................ 185 Exercise 2.5 ................................................................................................................ 186 Exercise 2.6 ................................................................................................................ 187 Exercise 3.1 ................................................................................................................ 188 Exercise 3.2 ................................................................................................................ 190 Exercise 3.3 ................................................................................................................ 191 Exercise 3.4 ................................................................................................................ 194 Exercise 4.1 ................................................................................................................ 196 Exercise 4.2 ................................................................................................................ 197 Exercise 4.3 ................................................................................................................ 198 Exercise 4.4 ................................................................................................................ 199 Exercise 4.5 ................................................................................................................ 202 Exercise 5.1 ................................................................................................................ 205 Exercise 5.2 ................................................................................................................ 208 Exercise 5.3 ................................................................................................................ 209 Exercise 5.4 ................................................................................................................ 210 Exercise 6.1 ................................................................................................................ 210 Exercise 6.2 ................................................................................................................ 212 Exercise 7.1 ................................................................................................................ 216 7.2 Exercise 7.2.......................................................................................................... 217 7.3 Exercise 7.3.......................................................................................................... 218
iii

Appendix B. Generic Algorithms Handbook............................................................... 220 accumulate() ................................................................................................................. 221 adjacent_difference() .................................................................................................... 221 adjacent_find().............................................................................................................. 221 binary_search() ............................................................................................................. 221 copy()............................................................................................................................ 222 copy_backward() .......................................................................................................... 222 count()........................................................................................................................... 222 count_if() ...................................................................................................................... 222 equal() ........................................................................................................................... 222 fill()............................................................................................................................. 223 fill_n() ........................................................................................................................... 223 find() ............................................................................................................................. 223 find_end() ..................................................................................................................... 223 find_first_of() ............................................................................................................... 224 find_if()......................................................................................................................... 224 for_each()...................................................................................................................... 224 generate() ...................................................................................................................... 224 generate_n() .................................................................................................................. 225 includes() ...................................................................................................................... 225 inner_product() ............................................................................................................. 225 inplace_merge() ............................................................................................................ 226 iter_swap() .................................................................................................................... 226 lexicographical_compare() ........................................................................................... 226 max(), min().................................................................................................................. 227 max_element() , min_element().................................................................................... 227 merge().......................................................................................................................... 227 nth_element()................................................................................................................ 228 partial_sort(), partial_sort_copy()................................................................................. 228 partial_sum()................................................................................................................. 229 partition(), stable_partition()......................................................................................... 229 random_shuffle() .......................................................................................................... 229 remove(), remove_copy() ............................................................................................. 230 remove_if(), remove_copy_if() .................................................................................... 230 replace(), replace_copy() .............................................................................................. 231 replace_if(), replace_copy_if() ..................................................................................... 231 reverse(), reverse_copy() .............................................................................................. 231 rotate(), rotate_copy() ................................................................................................... 231 search() ......................................................................................................................... 232 search_n() ..................................................................................................................... 232 set_difference() ............................................................................................................. 233 set_intersection()........................................................................................................... 233 set_symmetric_difference() .......................................................................................... 233 set_union() ............................................................................................................ 233 sort(), stable_sort()........................................................................................................ 234 transform() .................................................................................................................... 234 unique(), unique_copy()................................................................................................ 235
iv

Copyright
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and Addison-Wesley was aware of a trademark claim, the designations have been printed in initial capital letters or all capital letters.
The author and publisher have taken care in preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.
The programs and applications presented in this book have been included for their instructional value. They have been tested with care, but are not guaranteed for any particular purpose. The authors and publisher do not offer any warranties or representations, nor do they accept any liabilities with respect to the programs or applications.
The publisher offers discounts on this book when ordered in quantity for special sales. For more information please contact:
Corporate, Government, and Special Sales
Addison Wesley Longman, Inc.
One Jacob Way
Reading, Massachusetts 01867
Copyright © 2000 Addison Wesley Longman
Library of Congress Cataloging-in-Publication Data
Lippman, Stanley B.
Essential C++ / Stanley B. Lippman
p. cm.
Includes bibliographical references and index.
1. C++ (Computer program language) I. Title.
QA76.73.C153 L577 1999
005.13'3--dc21 99–046613
CIP
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior consent of the publisher. Printed in the United States of America. Published simultaneously in Canada.
v

1 2 3 4 5 6 7 8 9—MA—0302010099
First printing, October 1999
Dedication
To Beth, who remains essential
—
To Danny and Anna, hey, kids look, it's done ...
Preface
Gosh, but this book is short. I mean, wow. My C++ Primer is 1237 pages counting the index, title, and dedication pages. This one weighs in at 276 — in boxing terms, we're talking bantamweight.
The first question, of course, is how come? Actually, there's a story to that.
I'd been pestering everyone at Disney Feature Animation for a number of years to let me work on a production. I asked directors, management types — even Mickey, if the truth be told. In part, it was for the glamour, I suppose. Hollywood. The big screen. Also, I hold a Master of Fine Arts as well as my Comp Sci degree, and film work seemed to promise some sort of personal synthesis. What I told management, of course, was that I needed the experience in production in order to provide usable tools. As a compiler writer, I'd always been one of my own main users. It's difficult to get defensive or feel unfairly criticized when you're one of the principal complainers about your software.
The computer effects lead on the Firebird segment of Fantasia 2000 was interested in having me join the production. To kind of try things out, he asked me to write a tool to read the raw Disney camera information for a scene and generate a camera node that could be plugged in to the Houdini animation package. I wrote it in C++, of course. It worked. They liked it. I was invited to come on board.
Once on the production (thanks to Jinko and Chyuan), I was asked to rewrite the tool in Perl. The other TDs, it was explained, weren't heavy-duty programmers but knew Perl, Tcl, and so on. (TD is film industry jargon for technical director. I was the segment's software TD. There was also a lighting TD [hi, Mira] and a model TD [hi, Tim] as well as the actual computer effects animators [hi, Mike, Steve, and Tonya].) And oh, by the way, could I do this quickly, because, gosh, we have a proof of concept test to get out that the directors (hi, Paul and Gaetan) and effects supervisor (hi, Dave) are waiting for to pitch to the then head of Feature Animation (hi, Peter). No emergency, you understand, but ...
This left me in somewhat of a quandary. I can program reasonably quickly in C++ with confidence. Unfortunately, I didn't know Perl. I thought, OK, I'll read a book. But it can't be too big a book, at least not right now. And it had better not tell me too much, although I know I should know everything, only later. After all, this is show biz: The directors need a proof of concept, the artist needs a plug-in to prove the concept, and the producer — heck, she needs a 48-hour day. I
vi

didn't need the best book on Perl — just the right book to get me going and not steer me too far off the righteous path.
I found that book in Learning Perl, by Randal Schwartz. It got me up and running, and it was fun to read. Well, as much as any computer book is fun. It leaves out gobs of good stuff. At the time, though, I didn't need all that stuff — I needed to get my Perl scripts working.
Eventually, I realized sadly that the third edition of C++ Primer could no longer fill a similar role for someone needing to learn C++. It had just become too big. I think it's a grand book, of course — particularly with Josée Lajoie coming on board as coauthor of the third edition. But it's too comprehensive for this kind of just-in-time C++ language learning. That's why I decided to write this book.
You're probably thinking, but C++ is not Perl. That's correct. And this text is not Learning Perl. It's about learning C++. The real question is, How does one shed almost a thousand pages and still claim to be teaching anything?
1. Level of detail. In computer graphics, level of detail refers to how sharply an image is rendered. The invading Hun on horseback in the left front corner of the screen needs a face with eyes, hair, five o'clock shadow, clothes, and so on. The Hun way back there — no, not the rock, silly — well, we don't render both images with the same care for detail. Similarly, the level of detail in this book is clamped down considerably. C++ Primer, in my opinion, has the most complete but readable discussion of operator overloading in existence (I can say that because Josée was the author). However, it takes 46 pages of discussion and code examples. Here, I take 2 pages.
2. Core language. When I was editor of the C++ Report, I used to say that half the job of editing the magazine was in deciding what not to put in. The same is true for this text. The text is organized around a series of a programming problems. Language features are introduced to provide a solution to individual problems. I didn't have a problem that multiple or virtual inheritance could solve, so I do not discuss them. To implement an iterator class, however, I had to introduce nested types. Class conversion operators are easy to misuse and are complicated to explain. I therefore chose not to present them. And so on. The choice and order of presentation of language features are always open to criticism. This is my choice and my responsibility.
3. Number of code examples. C++ Primer has hundreds of pages of code that we step through in detail, including an object-oriented Text Query system and about a half-dozen fully implemented classes. Although this text is code-driven, the set of code examples is simply not as rich as that of C++ Primer. To help compensate, solutions to all the program exercises are provided in Appendix A. As my editor, Deborah Lafferty, said, ''If you are trying to teach something quickly, it is helpful to have the answers at your fingertips to reinforce the learning."
Structure of This Book
The text consists of seven chapters and two appendixes. Chapter 1 provides a description of the predefined language in the context of writing a small interactive program. It covers the built-in data types, the predefined operators, the vector and string library classes, the conditional and looping statements, and the iostream library for input and output. I introduce the vector and string classes in this chapter because I encourage their use over the built-in array and C-style character string.
vii

Chapter 2 explains how to design and use a function and walks through the many flavors of functions supported in C++: inline, overloaded, and template functions as well as pointers to functions.
Chapter 3 covers what is commonly referred to as the Standard Template Library (STL): a collection of container classes, such as a vector, list, set, and map, and generic algorithms to operate on those containers, such as sort(), copy(), and merge(). Appendix B presents an alphabetical listing of the most commonly used generic algorithms and provides an example of how each one is used.
As a C++ programmer, your primary activity is the delivery of classes and object-oriented class hierarchies. Chapter 4 walks through the design and use of the C++ class facility to create data types specific to your application domain. For example, at Dreamworks Animation, where I do some consulting work, we design classes to do four-channel compositing of images and so on. Chapter 5 explains how to extend class design to support families of related classes in objectoriented class hierarchies. Rather than design eight independent image compositing classes, for example, we define a compositing hierarchy using inheritance and dynamic binding.
Class templates are the topic of Chapter 6. A class template is a kind of prescription for creating a class in which one or more types or values are parameterized. A vector class, for example, may parameterize the type of element it contains. A buffer class may parameterize not only the type of element it holds but also the size of its buffer. The chapter is driven by the implementation of a binary tree template class.
Finally, Chapter 7 illustrates how to use the C++ exception handling facility and fit it into the existing standard library exception class hierarchy. Appendix A provides solutions to the programming exercises. Appendix B provides a program example and discussion of the most frequently used generic algorithms.
A Note on the Source Code
The full source code of the programs developed within the text as well as the solutions to the exercises is available on-line for downloading both at the Addison Wesley Longman Web site (www.awl.com/cseng/titles/0-201-48518-4) and at my home page (www.objectwrite.com). All the code has been executed under both Visual C++ 5.0 using the Intel C++ compiler and Visual C++ 6.0 using the Microsoft C++ compiler. You may need to modify the code slightly to have it compile on your system. If you make any modifications, send me a list of them (slippman@objectwrite.com), and I will post them, along with your name, in a modifications file attached to the solutions code. (Note that the full source code is not displayed within the text itself.)
Acknowledgments
Special thanks go to Josée Lajoie, coauthor of C++ Primer, 3rd Edition. She has been a wonderful support because of her insightful comments on the various drafts of this text and her unfailing encouragement. I also offer special thanks to Dave Slayton for going through both the text and the code examples with a razor-sharp green pencil, and to Steve Vinoski for his compassionate but firm comments on the drafts of this text.
Special thanks also go to the Addison-Wesley editorial team: Deborah Lafferty, who, as editor, supported this project from the beginning, Betsy Hardinger, who, as copyeditor, contributed
viii

greatly to the readability of the text, and John Fuller, who, as production manager, shepherded us from manuscript to bound text. During the writing of this text, I worked as an independent consultant, multiplexing between Essential C++ and a set of (reasonably) understanding clients. I'd like to thank Colin Lipworth, Edwin Leonard, and Kenneth Meyer for their patience and good faith.
Where to Find More Information
From a completely biased point of view, the two best one-volume introductions to C++ are Lippman and Lajoie's C++ Primer and Stroustrup's The C++ Programming Language, both in their third edition. Throughout the text I refer you to one or both of the texts for more in-depth information. The following books are cited in the text. (A more extensive bibliography can be found in both C++ Primer and The C++ Programming Language.) [LIPPMAN98] Lippman, Stanley, and Josée Lajoie, C++ Primer, 3rd Edition, Addison Wesley Longman, Inc., Reading, MA 1998) ISBN 0-201-82470-1. [LIPPMAN96a] Lippman, Stanley, Inside the C++ Object Model, Addison Wesley Longman, Inc., Reading, MA(1996) ISBN 0-201-83454-5. [LIPPMAN96b] Lippman, Stanley, Editor, C++ Gems, a SIGS Books imprint, Cambridge University Press, Cambridge, England(1996) ISBN 0-13570581-9. [STROUSTRUP97] Stroustrup, Bjarne, The C++ Programming Language, 3rd Edition, Addison Wesley Longman, Inc., Reading, MA(1997) ISBN 0-201-88954-4. [SUTTER99] Sutter, Herb, Exceptional C++, Addison Wesley Longman, Inc., Reading, MA(2000) ISBN 0-201-61562-2.
Typographical Conventions
The text of the book is set in 10.5 pt. Palatino. Program text and language keywords appear in 8.5 pt. lucida. Functions are identified by following their name with the C++ function call operator (()). Thus, for example, foo represents a program object, and bar() represents a program function. Class names are set in Palatino.
ix

Chapter 1. Basic C++ Programming
In this chapter, we evolve a small program to exercise the fundamental components of the C++ language. These components consist of the following:
1. A small set of data types: Boolean, character, integer, and floating point. 2. A set of arithmetic, relational, and logical operators to manipulate these types. These include not
only the usual suspects, such as addition, equality, less than, and assignment, but also the less conventional increment, conditional, and compound assignment operators. 3. A set of conditional branch and looping statements, such as the if statement and while loop, to alter the control flow of our program. 4. A small number of compound types, such as a pointer and an array. These allow us, respectively, to refer indirectly to an existing object and to define a collection of elements of a single type. 5. A standard library of common programming abstractions, such as a string and a vector.
1.1 How to Write a C++ Program
We've been asked to write a simple program to write a message to the user's terminal asking her to type in her name. Then we read the name she enters, store the name so that we can use it later, and, finally, greet the user by name.
OK, so where do we start? We start in the same place every C++ program starts — in a function called main(). main() is a user-implemented function of the following general form:
int main() {
// our program code goes here }
int is a C++ language keyword. Keywords are predefined names given special meaning within the language. int represents a built-in integer data type. (I have much more to say about data types in the next section.)
A function is an independent code sequence that performs some computation. It consists of four parts: the return type, the function name, the parameter list, and the function body. Let's briefly look at each part in turn.
The return type of the function usually represents the result of the computation. main() has an integer return type. The value returned by main() indicates whether our program is successful. By convention, main() returns 0 to indicate success. A nonzero return value indicates something went wrong.
The name of a function is chosen by the programmer and ideally should give some sense of what the function does. min() and sort(), for example, are pretty good function names. f() and g() are not as good. Why? Because they are less informative as to what the functions do.
main is not a language keyword. The compilation system that executes our C++ programs, however, expects a main() function to be defined. If we forget to provide one, our program will not run.
The parameter list of a function is enclosed in parentheses and is placed after the name of the function. An empty parameter list, such as that of main(), indicates that the function accepts no parameters.
1

The parameter list is typically a comma-separated list of types that the user can pass to the function when the function is executed. (We say that the user has called, or invoked, a function.) For example, if we write a function min() to return the smaller of two values, its parameter list would identify the types of the two values we want to compare. A min() function to compare two integer values might be defined as follows:
int min(int val1, int val2) {
// the program code goes here ... }
The body of the function is enclosed in curly braces ({}). It holds the code sequence that provides the computation of the function. The double forward slash (//) represents a comment, a programmer's annotation on some aspect of the code. It is intended for readers of the program and is discarded during compilation. Everything following the double forward slash to the end of the line is treated as a comment.
Our first task is to write a message to the user's terminal. Input and output are not a predefined part of the C++ language. Rather, they are supported by an object-oriented class hierarchy implemented in C++ and provided as part of the C++ standard library.
A class is a user-defined data type. The class mechanism is a method of adding to the data types recognized by our program. An object-oriented class hierarchy defines a family of related class types, such as terminal and file input, terminal and file output, and so on. (We have a lot more to say about classes and object-oriented programming throughout this text.)
C++ predefines a small set of fundamental data types: Boolean, character, integer, and floating point. Although these provide a foundation for all our programming, they are not the focus of our programs. A camera, for example, must have a location in space, which is generally represented by three floating point numbers. A camera also has a viewing orientation, which is also represented by three floating point numbers. There is usually an aspect ratio describing the ratio of the camera viewing width to height. This is represented by a single floating point number.
On the most primitive level, that is, a camera is represented as seven floating point numbers, six of which form two x,y,z coordinate tuples. Programming at this low level requires that we shift our thinking back and forth from the manipulation of the camera abstraction to the corresponding manipulation of the seven floating point values that represent the camera in our program.
The class mechanism allows us to add layers of type abstraction to our programs. For example, we can define a Point3d class to represent location and orientation in space. Similarly, we can define a Camera class containing two Point3d class objects and a floating point value. We're still representing a camera by seven floating point values. The difference is that in our programming we are now directly manipulating the Camera class rather than seven floating point values.
The definition of a class is typically broken into two parts, each represented by a separate file: a header file that provides a declaration of the operations supported by the class, and a program text file that contains the implementation of those operations.
To use a class, we include its header file within our program. The header file makes the class known to the program. The standard C++ input/output library is called the iostream library. It consists of a collection of related classes supporting input and output to the user's terminal and to files. To use the iostream class library, we must include its associated header file:
#include <iostream>
To write to the user's terminal, we use a predefined class object named cout (pronounced see out). We direct the data we wish cout to write using the output operator (<<), as follows:
2

cout << "Please enter your first name: ";
This represents a C++ program statement, the smallest independent unit of a C++ program. It is analogous to a sentence in a natural language. A statement is terminated by a semicolon. Our output statement writes the string literal (marked by double quotation marks) onto the user's terminal. The quotation marks identify the string; they are not displayed on the terminal. The user sees
Please enter your first name:
Our next task is to read the user's input. Before we can read the name the user types, we must define an object in which to store the information. We define an object by specifying the data type of the object and giving it a name. We've already seen one data type: int. That's hardly a useful way of storing someone's name, however! A more appropriate data type in this case is the standard library string class:
string user_name;
This defines user_name as an object of the string class. The definition, oddly enough, is called a declaration statement. This statement won't be accepted, however, unless we first make the string class known to the program. We do this by including the string class header file:
#include <string>
To read input from the user's terminal, we use a predefined class object named cin (pronounced see in). We use the input operator (>>) to direct cin to read data from the user's terminal into an object of the appropriate type:
cin >> user_name;
The output and input sequence would appear as follows on the user's terminal. (The user's input is highlighted in bold.)
Please enter your first name: anna
All we've left to do now is to greet the user by name. We want our output to look like this:
Hello, anna ... and goodbye!
I know, that's not much of a greeting. Still, this is only the first chapter. We'll get a bit more inventive before the end of the book.
To generate our greeting , our first step is to advance the output to the next line. We do this by writing a newline character literal to cout:
cout << '\n';
A character literal is marked by a pair of single quotation marks. There are two primary flavors of character literals: printing characters such as the alphabet ('a', 'A', and so on), numbers, and punctuation marks (';', '-', and so on), and nonprinting characters such as a newline ('\n') or tab ('\t'). Because there is no literal representation of nonprinting characters, the most common instances, such as the newline and tab, are represented by special two-character sequences.
Now that we've advanced to the next line, we want to generate our Hello:
cout << "Hello, ";
3

Next, we need to output the name of the user. That's stored in our string object, user_name. How do we do that? Just the same as with the other types:
cout << user_name;
Finally, we finish our greeting by saying goodbye (notice that a string literal can be made up of both printing and nonprinting characters):
cout << " ... and goodbye!\n";
In general, all the built-in types are output in the same way — that is, by placing the value on the righthand side of the output operator. For example,
cout << "3 + 4 = "; cout << 3 + 4; cout << '\n';
generates the following output:
3 + 4 = 7
As we define new class types for use in our applications, we also provide an instance of the output operator for each class. (We see how to do this in Chapter 4.) This allows users of our class to output individual class objects in exactly the same way as the built-in types.
Rather than write successive output statements on separate lines, we can concatenate them into one compound output statement:
cout << '\n' << "Hello, " << user_name << " ... and goodbye!\n";
Finally, we can explicitly end main() with the use of a return statement:
return 0;
return is a C++ keyword. The expression following return, in this case 0, represents the result value of the function. Recall that a return value of 0 from main() indicates that the program has executed successfully. [1]
[1] If we don't place an explicit return statement at the end of main(), a return 0; statement is inserted automatically. In the program examples in this book, I do not place an explicit return statement.
Putting the pieces together, here is our first complete C++ program:
#include <iostream> #include <string> using namespace std; // haven't explained this yet ...
int main() {
string user_name; cout << "Please enter your first name: "; cin >> user_name; cout << '\n'
4

<< "Hello, " << user_name << " ... and goodbye!\n";
return 0; }
When compiled and executed, this code produces the following output (my input is highlighted in bold):
Please enter your first name: anna Hello, anna ... and goodbye!
There is one statement I haven't explained:
using namespace std;
Let's see if I can explain this without scaring you off. (A deep breath is recommended at this point!) Both using and namespace are C++ keywords. std is the name of the standard library namespace. Everything provided within the standard library (such as the string class and the iostream class objects cout and cin) is encapsulated within the std namespace. Of course, your next question is, what is a namespace?
A namespace is a method of packaging library names so that they can be introduced within a user's program environment without also introducing name clashes. (A name clash occurs when there are two entities that have the same name in an application so that the program cannot distinguish between the two. When this happens, the program cannot run until the name clash is resolved.) Namespaces are a way of fencing in the visibility of names.
To use the string class and the iostream class objects cin and cout within our program, we must not only include the string and iostream header files but also make the names within the std namespace visible. The using directive
using namespace std;
is the simplest method of making names within a namespace visible. (To read about namespaces in more detail, check out either Section 8.5 of [LIPPMAN98] or Section 8.2 of [STROUSTRUP97].)
Exercise 1.1
Enter the main() program, shown earlier. Either type it in directly or download the program; see the Preface for how to acquire the source programs and solutions to exercises. Compile and execute the program on your system.
Exercise 1.2
Comment out the string header file:
// #include <string>
Now recompile the program. What happens? Now restore the string header and comment out
//using namespace std;
What happens?
5

Exercise 1.3
Change the name of main() to my_main() and recompile the program. What happens?
Exercise 1.4
Try to extend the program: (1) Ask the user to enter both a first and last name and (2) modify the output to write out both names.
1.2 Defining and Initializing a Data Object
Now that we have the user's attention, let's challenge her to a quiz. We display two numbers representing a numerical sequence and then request our user to identify the next value in the sequence. For example,
The values 2,3 form two consecutive elements of a numerical sequence.
What is the next value?
These values are the third and fourth elements of the Fibonacci sequence: 1, 1, 2, 3, 5, 8, 13, and so on. A Fibonacci sequence begins with the first two elements set to 1. Each subsequent element is the sum of its two preceding elements. (In Chapter 2 we write a function to calculate the elements.)
If the user enters 5, we congratulate her and ask whether she would like to try another numerical sequence. Any other entered value is incorrect, and we ask the user whether she would like to guess again.
To add interest to the program, we keep a running score based on the number of correct answers divided by the number of guesses.
Our program needs at least five objects: the string class object to hold the name of the user; three integer objects to hold, in turn, the user's guess, the number of guesses, and the number of correct guesses; and a floating point object to hold the user's score.
To define a data object, we must both name it and provide it with a data type. The name can be any combination of letters, numbers, and the underscore. Letters are case-sensitive. Each one of the names user_name, User_name, uSeR_nAmE, and user_Name refers to a distinct object.
A name cannot begin with a number. For example, 1_name is illegal but name_1 is OK. Also, a name must not match a language keyword exactly. For example, delete is a language keyword, and so we can't use it for an entity in our program. (This explains why the operation to remove a character from the string class is erase() and not delete().)
Each object must be of a particular data type. The name of the object allows us to refer to it directly. The data type determines the range of values the object can hold and the amount of memory that must be allocated to hold those values.
We saw the definition of user_name in the preceding section. We reuse the same definition in our new program:
#include <string> string user_name;
6

A class is a programmer-defined data type. C++ also provides a set of built-in data types: Boolean, integer, floating point, and character. A keyword is associated with each one to allow us to specify the data type. For example, to store the value entered by the user, we define an integer data object:
int usr_val;
int is a language keyword identifying usr_val as a data object of integer type. Both the number of guesses a user makes and the number of correct guesses are also integer objects. The difference here is that we wish to set both of them to an initial value of 0. We can define each on a separate line:
int num_tries = 0; int num_right = 0;
Or we can define them in a single comma-separated declaration statement:
int num_tries = 0, num_right = 0;
In general, it is a good idea to initialize data objects even if the value simply indicates that the object has no useful value as yet. I didn't initialize usr_val because its value is set directly from the user's input before the program makes any use of the object.
An alternative initialization syntax, called a constructor syntax, is
int num_tries(0);
I know. Why are there two initialization syntaxes? And, worse, why am I telling you this now? Well, let's see whether the following explanation satisfies either or both questions.
The use of the assignment operator (=) for initialization is inherited from the C language. It works well with the data objects of the built-in types and for class objects that can be initialized with a single value, such as the string class:
string sequence_name = "Fibonacci";
It does not work well with class objects that require multiple initial values, such as the standard library complex number class, which can take two initial values: one for its real component and one for its imaginary component. The alternative constructor initialization syntax was introduced to handle multiple value initialization:
#include <complex> complex<double> purei(0, 7);
The strange bracket notation following complex indicates that the complex class is a template class. We'll see a great deal more of template classes throughout the book. A template class allows us to define a class without having to specify the data type of one or all of its members.
The complex number class, for example, contains two member data objects. One member represents the real component of the number. The second member represents the imaginary component of the number. These members need to be floating point data types, but which ones? C++ generously supports three floating point size types: single precision, represented by the keyword float; double precision, represented by the keyword double; and extended precision, represented by the two keywords long double.
7

The template class mechanism allows the programmer to defer deciding on the data type to use for a template class. It allows the programmer to insert a placeholder that is later bound to an actual data type. In the preceding example, the user chose to bind the data type of the complex class members to double.

I know, this probably raises scads more questions than it answers. However, it is because of templates that C++ supports two initialization syntaxes for the built-in data types. When the built-in data types and programmer-defined class types had separate initialization syntaxes, it was not possible to write a template that supported both built-in and class data types. Making the syntax uniform simplified template design. Unfortunately, explaining the syntax seems to have become more complicated!

The user's running score must to be a floating point value because it may be some percentage. We'll define it to be of type double:

double usr_score = 0.0;

We also need to keep track of the user's yes/no responses: Make another try? Try another sequence?

We can store the user's response in a character data object:

char usr_more; cout << "Try another sequence? Y/N? "; cin >> usr_more;

The char keyword represents a character type. A character marked by a pair of single quotations represents a character literal: 'a', '7', ';', and so on. Some special built-in character literals are the following (they are sometimes called escape sequences):

'\n' '\t' '\0' '\'' '\"' '\\'

newline tab null single quote double quote backslash

For example, to generate a newline and then tab before printing the user's name, we might write

cout << '\n' << '\t' << user_name;

Alternatively, we can concatentate single characters into a string:

cout << "\n\t" << user_name;

Typically, we use these special characters within string literals. For example, to represent a literal file path under Windows, we need to escape the backslash:

"F:\\essential\\programs\\chapter1\\ch1_main.cpp";

C++ supports a built-in Boolean data type to represent true/false values. In our program, for example, we can define a Boolean object to control whether to display the next numeric sequence:

bool go_for_it = true;

A Boolean object is specified with the bool keyword. It can hold one of two literal values, either true or false.

8

All the data objects defined so far modified during the course of our program. go_for_it, for example, eventually gets set to false. usr_score is potentially updated with each user guess.
Sometimes, however, we need an object to represent a constant value: the maximum number of guesses to allow a user, for example, or the value of pi. The objects holding these values should not be modified during the course of our program. How can we prevent the accidental modification of such objects? We can enlist the aid of the language by declaring these objects as const:
const int max_tries = 3; const double pi = 3.14159;
A const object cannot be modified from its initial value. Any attempt to assign a value to a const object results in a compile-time error. For example:
max_tries = 42; // error: const object

1.3 Writing Expressions

The built-in data types are supported by a collection of arithmetic, relational, logical, and compound assignment operators. The arithmetic operators are unsurprising except for integer division and the remainder operator:

// Arithmetic Operators

+ addition

a + b

- subtraction a - b

* multiplication a * b

/ division

a / b

% remainder

a % b

The division of two integer values yields a whole number. Any remainder is truncated; there is no rounding. The remainder is accessed using the % operator:

5 / 3 evaluates to 1 while 5 % 3 evaluates to 2 5 / 4 evaluates to 1 while 5 % 4 evaluates to 1 5 / 5 evaluates to 1 while 5 % 5 evaluates to 0

When might we actually use the remainder operator? Imagine that we want to print no more than eight strings on a line. If the number of words on the line is less than eight, we output a blank space following the word. If the string is the eighth word on the line, we output a newline. Here is our implementation:

const int line_size = 8; int cnt = 1;
// these statements are executed many times, with // a_string representing a different value each time // and cnt growing by one with each execution ... cout << a_string
<< (cnt % line_size ? ' ' : '\n');

The parenthetical expression following the output operator likely makes no sense to you unless you are already familiar with the conditional operator (?:). The result of the expression is to output either a space or a newline character depending on whether the remainder operator evaluates to a zero or a nonzero value. Let's see what sense we can make of it.

9

The expression
cnt % line_size
evaluates to zero whenever cnt is a multiple of line_size; otherwise, it evaluates to a nonzero value. Where does that get us? The conditional operator takes the following general form:
expr ? execute_if_expr_is_true : execute_if_expr_is_false;
If expr evaluates to true, the expression following the question mark is evaluated. If expr evaluates to false, the expression following the colon is evaluated. In our case, the evaluation is to feed either a space or a newline character to the output operator.
A conditional expression is treated as evaluating to false if its value is zero. Any nonzero value is treated as true. In this example, whenever cnt is not a multiple of eight, the result is nonzero, the true branch of the conditional operator is evaluated, and a space is printed.
A compound assignment operator provides a shorthand notation for applying an arithmetic operation on the object to be assigned. For example, rather than write
cnt = cnt + 2;
a C++ programmer typically writes
cnt += 2; // add 2 to the current value of cnt
A compound assignment operator is associated with each arithmetic operator: +=, -=, *=, /=, and %=.
When an object is being added to or subtracted by 1, the C++ programmer uses the increment and decrement operators:
cnt++; // add 1 to the current value of cnt cnt--; // subtract 1 from the current value of cnt
There is a prefix and postfix version of the increment and decrement operators. In the prefix application, the object is either incremented (or decremented) by 1 before the object's value is accessed:
int tries = 0; cout << "Are you ready for try #"
<< ++tries << "?\n";
In this example, tries is incremented by 1 before its value is printed. In the postfix application, the object's value is first used in the expression, and then incremented (or decremented) by 1:
int tries = 1; cout << "Are you ready for try #"
<< tries++ << "?\n";
In this example, the value of tries is printed before it is incremented by 1. In both examples, the value 1 is printed.
Each of the relational operators evaluates to either true or false. They consist of the following six operators:
10

== equality

a == b

!= inequality

a != b

< less than

a < b

> greater than

a > b

<= less than or equal

a <= b

>= greater than or equal a >= b

Here is how we might use the equality operator to test the user's response:

bool usr_more = true; char usr_rsp;
// ask the user if she wishes to continue // read the response into usr_rsp if (usr_rsp == 'N')
usr_more = false;

The if statement conditionally executes the statement following it if the expression within parentheses evaluates to true. In this example, usr_more is set to false if usr_rsp is equal to 'N'. If usr_rsp is not equal to 'N', nothing is done. The reverse logic using the inequality operator looks like this:

if (usr_rsp != 'Y') usr_more = false;

The problem with testing usr_rsp only for 'N' is that the user might enter a lowercase 'n'. We must recognize both. One strategy is to add an else clause:

if (usr_rsp == 'N') usr_more = false;
else if (usr_rsp == 'n')
usr_more = false;

If usr_rsp is equal to 'N', usr_more is set to false and nothing more is done. If it is not equal to 'N', the else clause is evaluated. If usr_rsp is equal to 'n', usr_more is set to false. If usr_rsp is not equal to either, usr_more is not assigned.

A common beginner programmer error is to use the assignment operator for the equality test, as in the following:

// oops this assigns usr_rsp the literal character 'N' // and therefore always evaluates as true if (usr_rsp = 'N')
// ...

The logical OR operator (||) provides an alternative way of testing the truth condition of multiple expressions:

if (usr_rsp == 'N' || usr_rsp == 'n') usr_more = false;

The logical OR operator evaluates as true if either of its expressions evaluates as true. The leftmost expression is evaluated first. If it is true, the remaining expression is not evaluated. In our example, usr_rsp is tested for equality with 'n' only if it is not equal to 'N'.

The logical AND operator (&&) evaluates as true only if both its expressions evaluate as true. For example,

11

if (password && validate(password) && (acct = retrieve_acct_info(password))) // process account ...
The topmost expression is evaluated first. If it evaluates as false, the AND operator evaluates as false; the remaining expressions are not evaluated. In this example, the account information is retrieved only if the password is set and is determined to be valid.
The logical NOT operator (!) evaluates as true if the expression it is applied to is false. For example, rather than write
if (usr_more == false) cout << "Your score for this session is " << usr_score << " Bye!\n";
we can write
if (! usr_more) ...
Operator Precedence
There is one ''gotcha'' to the use of the built-in operators: When multiple operators are combined in a single expression, the order of expression evaluation is determined by a predefined precedence level for each operator. For example, the result of 5+2*10 is always 25 and never 70 because the multiplication operator has a higher precedence level than that of addition; as a result, 2 is always multiplied by 10 before the addition of 5.
We can override the built-in precedence level by placing parentheses around the operators we wish to be evaluated first. (5+2)*10, for example, evaluates to 70.
For the operators I've introduced, the precedence order is listed next. An operator has a higher precedence than an operator under it. Operators on the same line have equal precedence. In these cases, the order of evaluation is left to right.
logical NOT arithmetic (*, /, %) arithmetic (+, -) relational (<, >, <=, >=) relational (==, !=) logical AND logical OR assignment
For example, to determine whether ival is an even number, we might write
! ival % 2 // not quite right
Our intention is to test the result of the remainder operator. If ival is even, the result is zero and the logical NOT operator evaluates to true; otherwise, the result is nonzero, and the logical NOT operator evaluates to false. Or at least that is our intention.
Unfortunately, the result of our expression is quite different. Our expression always evaluates to false except when ival is 0!
12

The higher precedence of the logical NOT operator causes it to be evaluated first. It is applied to ival. If ival is nonzero, the result is false; otherwise, the result is true. The result value then becomes the left operand of the remainder operator. false is made into 0 when used in an arithmetic expression; true is made into 1. Under default precedence, the expression becomes 0%2 for all values of ival except 0.
Although this is not what we intended, it is also not an error, or at least not a language error. It is an incorrect representation only of our intended program logic. And the compiler cannot know that. Precedence is one of the things that makes C++ programming complicated. To correctly evaluate this expression, we must make the evaluation order explicit using parentheses:
! (ival % 2) // ok
To avoid this problem, you must hunker down and become familiar with C++ operator precedence. I'm not helping you in the sense that this section does not present either the full set of operators or a full treatment of precedence. This should be enough, though, to get you started. For the complete presentation, check out either Chapter 4 of [LIPPMAN98] or Chapter 6 of [STROUSTRUP97].
1.4 Writing Conditional and Loop Statements
By default, statements are executed once in sequence, beginning with the first statement of main(). In the preceding section, we had a peek at the if statement. The if statement allows us to execute conditionally one or a sequence of statements based on the truth evaluation of an expression. An optional else clause allows us to test multiple truth conditions. A looping statement allows us to repeat one or a sequence of statements based on the truth evaluation of an expression. The following pseudo-code program makes use of two looping statements (#1 and #2), one if statement (#5), one if-else statement (#3), and a second conditional statement called a switch statement (#4).
// Pseudo code: General logic of our program while the user wants to guess a sequence { #1
display the sequence while the guess is not correct and
the user wants to guess again { #2
read guess increment number-of-tries count if the guess is correct { #3
increment correct-guess count set got_it to true } else { express regret that the user has guessed wrong
generate a different response based on the current number of guesses by the user // #4 ask the user if she wants to guess again read response if user says no // #5 set go_for_it to false } } }
Conditional Statements
13

The condition expression of the if statement must be within parentheses. If it is true, the statement immediately following the if statement is executed:
// #5 if (usr_rsp == 'N' || usr_rsp == 'n')
go_for_it = false;
If multiple statements must be executed, they must be enclosed in curly braces following the if statement (this is called a statement block):
//#3 if (usr_guess == next_elem) { // begins statement block
num_right++; got_it = true; } // ends statement block
A common beginner mistake is to forget the statement block:
// oops: the statement block is missing // only num_cor++ is part of if statement // got_it = true; is executed unconditionally
if (usr_guess == next_elem) num_cor++; got_it = true;
The indentation of got_it reflects the programmer's intention. Unfortunately, it does not reflect the program's behavior. The increment of num_cor is associated with the if statement and is executed only when the user's guess is equal to the value of next_elem. got_it, however, is not associated with the if statement because we forgot to surround the two statements within a statement block. got_it is always set to true in this example regardless of what the user guesses.
The if statement also supports an else clause. An else clause represents one or a block of statements to be executed if the tested condition is false. For example,
if (usr_guess == next_elem) {
// user guessed correctly } else {
// user guessed incorrectly }
A second use of the else clause is to string together two or more if statements. For example, if the user guesses incorrectly, we want our response to differ based on the number of guesses. We could write the three tests as independent if statements:
if (num_tries == 1) cout << "Oops! Nice guess but not quite it.\n";
if (num_tries == 2) cout << "Hmm. Sorry. Wrong a second time.\n";
if (num_tries == 3) cout << "Ah, this is harder than it looks, isn't it?\n";
14

However, only one of the three conditions can be true at any one time. If one of the if statements is true, the others must be false. We can reflect the relationship among the if statements by stringing them together with a series of else-if clauses:
if (num_tries == 1) cout << "Oops! Nice guess but not quite it.\n";
else if (num_tries == 2)
cout << "Hmm. Sorry. Wrong again.\n"; else if (num_tries == 3)
cout << "Ah, this is harder than it looks, isn't it?\n"; else
cout << "It must be getting pretty frustrating by now!\n";
The first if statement's condition is evaluated. If it is true, the statement following it is executed and the subsequent else-if clauses are not evaluated. If the first if statement's condition evaluates to false, the next one is evaluated, and so on, until one of the conditions evaluates to true, or, if num_tries is greater than 3, all the conditions are false and the final else clause is executed.
One confusing aspect of nested if-else clauses is the difficulty of organizing their logic correctly. For example, we'd like to use our if-else statement to divide the program logic into two cases: when the user guesses correctly and when the user guesses incorrectly. This first attempt doesn't work quite as we intended:
if (usr_guess == next_elem) {
// user guessed correctly } else if (num_tries == 1)
// ... output response else if (num_tries == 2)
// ... output response else if (num_tries == 3)
// ... output response else
// ... output response
// now ask user if she wants to guess again // but only if she has guessed wrong // oops! where can we place it?
Each else-if clause has unintentionally been made an alternative to guessing the value correctly. As a result, we have no place to put the second part of our code to handle the user having guessed incorrectly. Here is the correct organization:
if (usr_guess == next_elem) {
// user guessed correctly } else { // user guessed incorrectly
if (num_tries == 1) // ...
else
15

if (num_tries == 2) // ...
else if (num_tries == 3)
// ... else // ...
cout << "Want to try again? (Y/N) "; char usr_rsp; cin >> usr_rsp;
if (usr_rsp == 'N' || usr_rsp == 'n') go_for_it = false;
}
If the value of the condition being tested is an integral type, we can replace the if-else-if set of clauses with a switch statement:
// equivalent to if-else-if clauses above switch (num_tries) {
case 1: cout << "Oops! Nice guess but not quite it.\n"; break;
case 2: cout << "Hmm. Sorry. Wrong again.\n"; break;
case 3: cout << "Ah, this is harder than it looks, isn't it?\n"; break;
default: cout << "It must be getting pretty frustrating by now!\n"; break;
}
The switch keyword is followed by an expression enclosed in parentheses (yes, the name of an object serves as an expression). The expression must evaluate to an integral value. A series of case labels follows the switch keyword, each specifying a constant expression. The result of the expression is compared against each case label in turn. If there is a match, the statements following the case label are executed. If there is no match and the default label is present, the statements following the default label are executed. If there is no match and no default label, nothing happens.
Why did I place a break statement at the end of each case label? Each case label is tested in turn against the expression's value. Each nonmatching case label is skipped in turn. When a case label matches the value, execution begins with the statement following the case label. The "gotcha" is that execution continues through each subsequent case statement until the end of the switch statement. If num_tries equals 2, for example, and if there was no break statement, the output would look like this:
// output if num_tries == 2 and // we had forgotten the break statements Hmm. Sorry. Wrong again. Ah, this is harder than it looks, isn't it? It must be getting pretty frustrating by now!
16

IAfter a case label is matched, all the case labels following the matched case label are also executed unless we explicitly break off execution. This is what the break statement does. Why, you're probably asking, is the switch statement designed this way? Here is an example of this fall-through behavior being just right:

switch (next_char) {
case 'a': case 'A': case 'e': case 'E': case 'i': case 'I': case 'o': case 'O': case 'u': case 'U':
++vowel_cnt; break; // ... }

Loop Statements

A loop statement executes a statement or statement block as long as the condition expression evaluates as true. Our program requires two loop statements, one nested within the other:

while the user wants to guess a sequence {
display the sequence while the guess is not correct and
the user wants to guess again }

The C++ while loop maps nicely to our needs:

bool next_seq = true; bool go_for_it = true; bool got_it = false; int num_tries = 0; int num_right = 0;

// show next sequence? // user wants to guess? // user guessed correctly? // number of user guesses // number of correct answers

while (next_seq == true) {
// display sequence to user while ((got_it == false) &&
(go_for_it == true)) {
int usr_guess; cin >> usr_guess; num_tries++;

if (usr_guess == next_elem) {
got_it = true; num_cor++; } else { // user guessed incorrectly // tell user answer is wrong // ask user if she wants to try again if (usr_rsp == 'N' || usr_rsp == 'n')
go_for_it = false; }

17

} // end of nested while loop
cout << "Want to try another sequence? (Y/N) " char try_again; cin >> try-again;
if (try_again == 'N' || try_again == 'n') next_seq = false;
} // end of while(next_seq == true)
A while loop begins by evaluating the conditional expression within parentheses. If it is true, the statement or statement block following the while loop is executed. After the statement is executed, the expression is reevaluated. This evaluation/execution cycle continues until the expression evaluates to false. Typically, some condition within the executing statement block sets the expression to false. If the expression never evaluates to false, we say that we have mistakenly fallen into an infinite loop.
Our outer while loop executes until the user says she wishes to stop:
bool next_seq = true; while (next_seq == true) {
// ... if (try_again == 'N' || try_again == 'n')
next_seq = false; }
Were next_seq initialized to false, the statement block would not be executed. The nested while loop allowing our user multiple guesses behaves similarly.
A loop can be terminated within the body of its code sequence by the execution of a break statement. In the following code fragment, for example, the while loop executes until tries_cnt equals max_tries. If the user guesses the correct answer, however, the loop is terminated using the break statement:
int max_tries = 3; int tries_cnt = 0; while (tries_cnt < max_tries) {
// read user guess if (usr_guess == next_elem)
break; // terminate loop
tries_cnt++; // more stuff }
The program can short-circuit execution of the current iteration of the loop by executing a continue statement. For example, consider the following program fragment in which all words of fewer than four characters are discarded:
string word; const int min_size = 4; while (cin >> word) {
if (word.size() < min_size) // terminates this iteration continue;
// reach here only if the word is // greater than or equal min-size ...
18

process_text(word); }
If word is less than min_size, the continue statement is executed. The continue statement causes the current loop iteration to terminate: The remainder of the while loop body — in this case, process_text() — is not evaluated. Rather, the loop begins again with a new evaluation of the condition expression, which reads another string into word. If word is greater than or equal to min_size, the entire while loop body is evaluated. In this way, all words of fewer than four characters are discarded.

1.5 How to Use Arrays and Vectors

Following are the first eight elements from six numerical sequences:

Fibonacci: 1, 1, 2, 3, 5, 8, 13, 21

Lucas:

1, 3, 4, 7, 11, 18, 29, 47

Pell:

1, 2, 5, 12, 29, 70, 169, 408

Triangular: 1, 3, 6, 10, 15, 21, 28, 36

Square:

1, 4, 9, 16, 25, 36, 49, 64

Pentagonal: 1, 5, 12, 22, 35, 51, 70, 92

Our program must display a pair of elements from a sequence and allow the user to guess the next element. If the user guesses right and wishes to continue, the program then displays a second pair of elements, then a third, and so on. How might we do that?

If succeeding element pairs are taken from the same sequence, the user, recognizing one pair, recognizes them all. That is not very interesting. So we'll pick an element pair from a different numeric sequence with each iteration of the main program loop.

For now, we'll display a maximum of six element pairs per session: one pair from each of the six sequences. We'd like to implement this so that we can loop through the display of the element pairs without having to know which sequence we are displaying with each loop iteration. Each iteration must have access to three values: the element pair and the element that follows them in the sequence.

The solution we discuss in this section uses a container type that can hold a contiguous sequence of integer values that we can reference not by name but by position within the container. We store 18 values in the container as a collection of six tuples: The first two represent the element pair to display; the third represents the next sequence element. With each iteration of the loop, we add 3 to the index value, in this way stepping through the six tuples in turn.

In C++, we can define a container as either a built-in array or an object of the stan-dard library vector class. In general, I recommend the use of the vector class over that of the built-in array. However, a great deal of existing code uses the built-in array, and it is important to understand how to use both representations.

To define a built-in array, we must specify the type of element the array is to hold, give the array a name, and specify a dimension — that is, the number of elements the array can hold. The dimension must be a constant expression — that is, an expression that does not require run-time evaluation. For example, the following code declares pell_seq to be an array of 18 integer elements.

const int seq_size = 18; int pell_seq[seq_size];

To define a vector class object, we must first include the vector header file. The vector class is a template, so we indicate the type of its element in brackets following the name of the class. The dimension

19

is placed in parentheses; it does not need to be a constant expression. The following code defines pell_seq as a vector class object holding 18 elements of type int. By default, each element is initialized to 0.
#include <vector> vector<int> pell_seq(seq_size);
We access an element of either an array or a vector by specifying its position within the container. This element indexing uses the subscript operator ([]). One potential "gotcha" is that the first element begins at position 0 and not 1. The last element is indexed at 1 less than the size of the container. For pell_seq, the correct indexes are 0 through 17, not 1 through 18. (Getting this wrong is common enough that it has its own name: the infamous off-by-one error.) For example, to assign the first two elements of the Pell sequence, we write
pell_seq[0] = 1; // assign 1 to first element pell_seq[1] = 2; // assign 2 to second element
Let's calculate the next ten elements of the Pell sequence. To iterate over the elements of a vector or an array, we typically use a for loop, the other primary C++ loop statement. For example,
for (int ix = 2; ix < seq_size; ++ix) pell_seq[ix] = pell_seq[ix - 2] + 2*pell_seq[ix - 1];
The for loop consists of the following elements:
for (init-statement; condition; expression) statement
The init-statement is executed once before the loop is executed. In our example, ix is initialized to 2 before the loop begins executing.
condition serves as the loop control. It is evaluated before each iteration of the loop. For as many iterations as condition evaluates as true, statement is executed. statement can be either a single statement or a statement block. If the first evaluation of condition evaluates to false, statement is never executed. In our example, condition tests whether ix is less than seq_size.
expression is evaluated after each iteration of the loop. It is typically used to modify the objects initialized within init-statement and tested in condition. If the first evaluation of condition evaluates to false, expression is never executed. In our example, ix is incremented following each iteration of the loop.
To print the elements, we iterate over the entire collection:
cout << "The first " << seq_size << " elements of the Pell Series:\n\t";
for (int ix = 0; ix < seq_size; ++ix) cout << pell_seq[ix] << ' ';
cout << '\n';
If we choose, we can leave out the init-statement, expression, or, less frequently, the condition portion of the for loop. For example, we could rewrite the preceding for loop as
int ix = 0;
20

// ...
for (; ix < seq_size; ++ix) // ...
The semicolon is necessary to indicate the empty init-statement.
Our container holds the second, third, and fourth elements of each of our six sequences. How can we fill the container with the appropriate values? A built-in array can specify an initialization list, providing a comma-separated list of values for all or a subset of its elements:
int elem_seq[seq_size] = { 1, 2, 3, // Fibonacci 3, 4, 7, // Lucas 2, 5, 12, // Pell 3, 6, 10, //Triangular 4, 9, 16, // Square 5, 12, 22 // Pentagonal
};
The number of values provided for the initialization list must not exceed the array dimension. If we provide fewer initial values than the dimension, the remaining elements are initialized to 0. If we wish, we can let the compiler calculate the array size based on the number of initial values we provide:
// compiler computes a size of 18 elements int elem_seq[] = {
1, 2, 3, 3, 4, 7, 2, 5, 12, 3, 6, 10, 4, 9, 16, 5, 12, 22 };
The vector class does not support an explicit initialization list. A somewhat tedious solution is to assign each element explicitly:
vector<int> elem_seq(seq_size); elem_seq[0] =1; elem_seq[1] =2; // ... elem_seq[17] =22;
One alternative is to initialize a built-in array and use that to initialize the vector:
int elem_vals[seq_size] = { 1, 2, 3, 3, 4, 7, 2, 5, 12, 3, 6, 10, 4, 9, 16, 5, 12, 22 };
// initialize elem_seq with values of elem_vals vector<int> elem_seq(elem_vals, elem_vals+seq_size);
elem_seq is passed two values. These values are actually addresses. They mark the range of elements with which to initialize the vector. In this case, we have marked the 18 elements contained within elem_vals to be copied into elem_seq. In Chapter 3, we look at the actual details of how this works.
For now, let's see how we can use elem_seq. One difference between the built-in array and a vector class is that a vector knows its size. Our earlier for loop iterating across the built-in array looks slightly different when applied to the vector:
// elem_seq.size() returns the number of elements
21

//

contained within the vector elem_seq

cout << "The first " << elem_seq.size()

<< " elements of the Pell Series:\n\t";

for (int ix = 0; ix < elem_seq.size(); ++ix) cout << pell_seq[ix] << ' ';

cur_tuple represents our index into the current sequence to display. We initialize it to 0. With each loop iteration we add 3 to cur_tuple, setting it to index the first element of the next sequence to display.

int cur_tuple = 0;
while (next_seq == true && cur_tuple < seq_size)
{ cout << "The first two elements of the sequence are: " << elem_seq[cur_tuple] << ", " << elem_seq[cur_tuple + 1] << "\nWhat is the next element? "; // ... if (usr_guess == elem_seq[cur_tuple + 2]) // correct!
// ...
if (usr_rsp == 'N' || usr_rsp == 'n') next_seq = false;
else cur_tuple += 3; }

It would also be useful to keep track of which sequence is currently active. Let's store the name of each sequence as a string:

const int max_seq = 6; string seq_names[max_seq] = {
"Fibonacci", "Lucas", "Pell", "Triangular", "Square", "Pentagonal" };

We can use seq_names as follows:

if (usr_guess == elem_seq[cur_tuple + 2]) {
++num_cor; cout << "Very good. Yes, "
<< elem_seq[cur_tuple + 2] << " is the next element in the " << seq_names[cur_tuple / 3] << "sequence.\n"; }

The expression cur_tuple/3 yields, in turn, 0, 1, 2, 3, 4, and 5, providing the index into the array of string elements that identify the active sequence.

22

1.6 Pointers Allow for Flexibility
Our display solution in the preceding section has two primary drawbacks. First, it has a fixed upper limit of six sequences; if the user should guess all six sequences, the program unexpectedly terminates. Second, it always displays the same six element pairs in the same order. How might we extend our program's flexibility?
One possible solution is to maintain six vectors, one for each sequence, calculated to some number of elements. With each iteration of the loop, we draw our element pair from a different vector. When using a vector a second time, we draw our element pair from a different index within the vector. This approach resolves both drawbacks.
As with our earlier solution, we'd like to access the different vectors transparently. In the preceding section, we achieve transparency by accessing each element by index rather than by name. With each loop iteration, we increment the index value by 3. Otherwise, the code remains invariant.
In this section, we achieve transparency by accessing each vector indirectly by a pointer rather than by name. A pointer introduces a level of indirection to a program. Rather than manipulate an object directly, we manipulate a pointer that holds the address of an object. In our program, we define a pointer that can address a vector of integers. With each loop iteration, we modify the pointer to address a different vector. The actual code that manipulates the pointer does not change.
The use of a pointer does two things to our program. It increases the program's flexibility and adds a level of complexity absent in direct object manipulation. This section should convince you of the truth of both statements.
We already know how to define an object. The following statement, for example, defines ival as an object of type int initialized to a value of 1,024:
int ival = 1024;
A pointer holds the address of an object of a particular type. To define a pointer of a particular type, we follow the type name with an asterisk:
int *pi; // pi is a pointer to an object of type int
pi is a pointer to an object of type int. How do we initialize it to point to ival? The evaluation of an object's name, such as
ival; // evaluates to the value of ival
evaluates to its associated value — 1,024 in this case. To retrieve the address of the object rather than its value, we apply the address-of operator (&):
&ival; // evaluates to the address of ival
To initialize pi to ival's address, we write the following:
int *pi = &ival;
To access the object addressed by a pointer, we must dereference the pointer — that is, retrieve the object sitting at the address held by the pointer. To do that, we apply an asterisk to the pointer as follows:
// dereference pi to access the object it addresses
23

if (*pi != 1024) // read *pi = 1024; // write
The initial complexity of using a pointer, as you can see, comes from its confusing syntax. The complexity in this case stems from the dual nature of a pointer: Either we can manipulate the address contained by the pointer, or we can manipulate the object to which the pointer points. When we write
pi; // evaluates to the address held by pi
we are, in effect, manipulating the pointer object. When we write
*pi; // evaluates to the value of the object addressed by pi
we are manipulating the object pi addresses.
A second complexity introduced by a pointer is the possibility that it addresses no object. For example, when we write *pi, this may or may not cause our program to fail at run-time! If pi addresses an object, our dereference of pi works exactly right. If pi addresses no object, however, our attempt to dereference pi results in undefined run-time behavior. This means that when we use a pointer, we must be sure that it addresses an object before we attempt to dereference it. How do we do that?
A pointer that addresses no object has an address value of 0 (it is sometimes called a null pointer). Any pointer type can be initialized or assigned a value of 0.
// initialize each pointer to address no object int *pi = 0; double *pd = 0; string *ps = 0;
To guard against dereferencing a null pointer, we test a pointer to see whether its address value is zero. For example,
if (pi && *pi != 1024) *pi = 1024;
The expression
if (pi && ...)
evaluates to true only if pi contains an address other than 0. If it is false, the AND operator does not evaluate its second expression. To test whether a pointer is null, we typically use the logical NOT operator:
if (! pi) // true if pi is set to 0
Here are our six vector sequence objects:
vector<int> fibonacci, lucas, pell, triangular, square, pentagonal;
What does a pointer to a vector of integer objects look like? Well, in general, a pointer has this form:
type_of_object_pointed_to * name_of_pointer_object
Our pointer addresses the type vector<int>. Let's name it pv and initialize it to 0:
24

vector<int> *pv = 0;
pv can address each of the sequence vectors in turn. Of course, we can assign pv the address of an explicit sequence:
pv = &fibonacci; // ... pv = &lucas;
But doing the assignment this way sacrifices code transparency. An alternative solution is to store the address of each sequence within a vector. This technique allows us to access them transparently through an index:
const int seq_cnt = 6;
// an array of seq_cnt pointers to // objects of type vector<int> vector<int> *seq_addrs[seq_cnt] = {
&fibonacci, &lucas, &pell, &triangular, &square, &pentagonal };
seq_addrs is a built-in array of elements of type vector<int>*. seq_addrs[0] holds the address of the fibonacci vector, seq_addrs[1] holds the address of the lucas vector, and so on. We use this to access the individual vectors through an index rather than by name:
vector<int> *current_vec = 0; // ...
for (int ix = 0; ix < seq_cnt; ++ix) {
current_vec = seq_addrs[ix]; // all element display is implemented // indirectly through current_vec }
The remaining problem with this implementation is that it is totally predictable. The sequence is always Fibonacci, Lucas, Pell, and so on. We'd like to randomize the display order of our sequences. We can do that using the C language standard library rand() and srand() functions:
#include <cstdlib>
srand(seq_cnt); seq_index = rand() % seq_cnt; current_vec = seq_addrs[seq_index];
rand() and srand() are standard library functions that support pseudo-random number generation. srand() seeds the generator with its parameter. Each call of rand() returns an integer value in a range between 0 and the maximum integer value an int can represent. We must clamp that value between 0 and 5 to have it be a valid index into seq_addrs. The remainder (%) operator ensures that our index is between 0 and 5. The cstdlib header file contains the declaration of both functions.
We handle a pointer to a class object slightly differently than we handle a pointer to an object of a built-in type. This is because a class object has an associated set of operations that we may wish to invoke. For example, to check whether the first element of the fibonacci vector is set to 1, we might write
if (! fibonacci.empty() &&
25

(fibonacci[1] == 1))
How would we achieve the same tests indirectly through pv? The dot connecting fibonacci and empty() is called a member selection operator. It is used to select class operations through an object of the class. To select a class operation through a pointer, we use the arrow member selection operator (->):
! pv->empty()
Because a pointer can address no object, before we invoke empty() through pv we must first check that pv's address is nonzero:
pv && ! pv->empty()
Finally, to apply the subscript operator, we must dereference pv. (The additional parentheses around the dereference of pv are necessary because of the higher precedence of the subscript operator.)
if (pv && ! pv->empty() && ((*pv)[1] == 1))
We look at pointers again in the discussion of the Standard Template Library in Chapter 3, and in Chapter 6, in which we design and implement a binary tree class. For a more in-depth discussion of pointers, refer to Section 3.3 of [LIPPMAN98].
1.7 Writing and Reading Files
If a user should happen to run our program a second time, it would be nice to allow her score to reflect both sessions. To do this, we must (1) write the user's name and session data to a file at the end of the session and (2) read the user's session data back into the program at the start of the next session. Let's see how we might do that.
To read and write to a file, we must include the fstream header file:
#include <fstream>
To open a file for output, we define an ofstream (an output file stream) class object, passing it the name of the file to open:
// seq_data.txt is opened in output mode ofstream outfile("seq_data.txt");
What happens when we declare outfile? If it doesn't exist, the file is created and opened for output. If it does exist, it is opened for output and any existing data in the file is discarded.
If we wish to add to rather than replace the data within an existing file, we must open the file in append mode. We do this by providing an ios_base::app second value to the ofstream object. (At this point in this book, it is better that you just use this and not inquire too deeply as to what the heck it actually is!)
// seq_data.txt is opened in append mode // new data is added at the end of the file ofstream outfile("seq_data.txt", ios_base::app);
A file may fail to open. Before we write to it, we must confirm that it has been opened successfully. The simplest way to check that is to test the truth value of the class object:
26

// if outfile evaluates as false, // the file could not be opened if (! outfile)

If the file could not be opened, the ofstream class object evaluates to false. In this example, we alert the user by writing a message to cerr. cerr represents standard error. cerr, like cout, directs its output to the user's terminal. The difference is that cerr's output is not buffered; it displays on the user's terminal immediately.

if (! outfile) // open failed for some reason ... cerr << "Oops! Unable to save session data!\n";
else // ok: outfile is open, let's write the data outfile << usr_name << ' ' << num_tries << ' ' << num_right << endl;

If the file is opened successfully, we direct output to it in the same way as we do for the ostream class objects cout and cerr. In this example, we write three values to outfile, the second two separated by a space. endl is a predefined manipulator provided by the iostream library.

A manipulator performs some operation on the iostream rather than write or read data. endl inserts a newline character and then flushes the output buffer. Other predefined manipulators include hex, which displays an integer value in hexidecimal notation; oct, which displays an integer value in octal notation; and setprecision(n), which sets the display of floating point precision to n. (For a full list of the predefined iostream manipulators, refer to Section 20.9 of [LIPPMAN98].)

To open a file for input, we define an ifstream class object (an input file stream), passing it the name of a file. If the file cannot be opened, the ifstream class object tests as false. Otherwise, the file is positioned at the beginning of the data stored in the file.

// infile opened in output mode ifstream infile("seq_data.txt"); int num_tries = 0; int num_cor = 0;

if (! infile)

{

// open failed for some reason ...

// we'll presume it is a new user ...

}

else

{

// ok: read each line of the input file

//

see if user has played before ...

// format of each line:

// name num_tries num_correct

// nt: number of tries

// nc: number of correct guesses

string name; int nt; int nc;

while (infile >> name) {

27

infile >> nt >> nc; if (name == usr_name) {
// match! cout << "Welcome back, " << usr_name
<< "\nYour current score is " << nc << " out of " << nt << "\nGood Luck!\n";
num_tries = nt; num_cor = nc; } } }
Each iteration of the while loop reads the next line of the file until the end-of-file is reached. When we write
infile >> name
the return value of the input statement is the class object from which we are reading — infile in this case. When the end-of-file is reached, the truth condition of the class object evaluates to false. This is why the conditional expression of the while loop terminates when end-of-file is reached:
while (infile >> name)
Each line of the file contains a string followed by two integers, of the form
anna 24 19 danny 16 12 ...
The line
infile >> nt >> nc;
reads in turn the number of user guesses into nt and the number of correct guesses into nc.
If we wish to both read from and write to the same file, we define an fstream class object. To open it in append mode, we must provide a second value of the form ios_base::in|ios_base::app: [2]
[2] If I chose not to explain the simpler ios_base::app earlier, I certainly am not going to explain this guy! See [LIPPMAN98], Section 20.6, for a full explanation and detailed example.
fstream iofile("seq_data.txt", ios_base::in|ios_base::app);
if (! iofile) // open failed for some reason ... darn!
else {
// reposition to front of file to begin reading iofile.seekg(0);
// ok: everything else is the same ... }
28

When we open a file in append mode, the current position of the file is at the end. If we try to read the file without repositioning it, we simply encounter the end-of-file. The seekg() operation repositions iofile to the beginning of the file. Because it is opened in append mode, any write operation adds the data to the end of the file. The iostream library is rich in functionality, many of the details of which I haven't the space to cover here. For a detailed discussion of the iostream library, see Chapter 20 of [LIPPMAN98] or Chapter 21 of [STROUSTRUP97].
Exercise 1.5
Write a program to ask the user his or her name. Read the response. Confirm that the input is at least two characters in length. If the name seems valid, respond to the user. Provide two implementations: one using a C-style character string, and the other using a string class object.
Exercise 1.6
Write a program to read in a sequence of integers from standard input. Place the values, in turn, in a builtin array and a vector. Iterate over the containers to sum the values. Display the sum and average of the entered values to standard output.
Exercise 1.7
Using your favorite editor, type two or more lines of text into a file. Write a program to open the file, reading each word into a vector<string> object. Iterate over the vector, displaying it to cout. That done, sort the words using the sort() generic algorithm, #include <algorithm> sort(container.begin(), container.end()); Then print the sorted words to an output file.
Exercise 1.8
The switch statement of Section 1.4 displays a different consolation message based on the number of wrong guesses. Replace this with an array of four string messages that can be indexed based on the number of wrong guesses.
29

Chapter 2. Procedural Programming
Writing an entire program in main(), as we did in Chapter 1, is not very practical except for small programs written by a single individual. Typically, we factor common operations, such as calculating the elements of the Fibonacci sequence or generating a random number, into independent functions. This approach has three primary benefits. First, our programs are simpler to understand because they are a sequence of function calls rather than the code sequence to accomplish each operation. Second, we can use the functions across multiple programs. Third, it is easier to distribute the work across multiple programmers or groups within a project.
This chapter covers the basic rules for writing independent functions. It also briefly discusses overloaded and template functions and illustrates the use of pointers to functions.
2.1 How to Write a Function
In this section, we write a function that returns the Fibonacci element at a position specified by the user. For example, if the user asks, "What is the eighth Fibonacci element?" our function answers, "21." How do we go about defining this function?
We must define the following four parts to our function:
1. The return type of the function. Our function returns the element value at the userspecified position. Its value is of type int, so our function's return type is also of type int. A function that does not return a value has a return type of void. A function that prints a Fibonacci sequence to the terminal, for example, is likely to declare its return type void.
2. The name of the function. foo() is a common name. It is not a good name, however, because it is not helpful in identifying the operation provided by the function. fibon_elem() is a somewhat better name, although no doubt you can think of an even better name.
3. The parameter list of the function. The parameters of a function serve as placeholders for values that are later supplied by the user during each invocation of the function. A parameter, that is, represents what varies with each invocation of a function. Our function, for example, defines one parameter: the element's position in the sequence. The user will supply this position each time our function is invoked. A parameter specifies both a type and a name. For our function, we define a single parameter of type int. A function can have an empty parameter list. For example, a function to greet the user and read in the user's name is unlikely to require parameters.
4. The body of the function. The body of the function implements the logic of the operation. Typically, it manipulates the named parameters of the function. The function body is enclosed in curly braces and appears after the parameter list.
Before a function can be called within our program, it must be declared. A function declaration allows the compiler to verify the correctness of its use — whether there are enough parameters, whether they are of the correct type, and so on. The function declaration specifies the return type, the name, and the parameter list but not the function body. This is called the function prototype.
// a declaration of our function int fibon_elem(int pos);
30

A function definition consists of the function prototype plus the function body. Given an element's position, fibon_elem() must calculate its value. Here is one possible implementation. (The /*,*/ pair is a multiline form of comment. Everything from the /* up to and including the matching */ is treated as a comment.)
/* A second form of comment delimiter * * 1st and 2nd elements of the Fibonacci Sequence * are 1; each subsequent element is the sum of * the preceding two elements * * elem: holds value to be returned * n_2, n_1: holds preceding values * pos: element position user requested */
int elem = 1; // holds return value int n_2 = 1, n_1 = 1; for (int ix = 3; ix <= pos; ++ix) {
elem = n_2 + n_1; n_2 = n_1; n_1 = elem; }
If the user asks for the first or second element, the body of the for loop is never executed. elem is initialized to 1, which is the correct value to return. If the user asks for the third or subsequent position, the loop calculates each value until ix exceeds pos. elem contains the value of the element at pos.
To return a value from a function, we use the return statement. For our function, the return statement looks like this:
return elem;
If we are willing to trust that our user never makes a mistake and if we are willing to calculate any Fibonacci position, however large, then we are finished. Unfortunately, if we ignore both of these issues, our function is likely to fail at one time or another.
What are the mistakes a user might make? The user might enter an invalid position — perhaps a value of 0 or a negative number. If the user does that, fibon_elem() returns 1, and that is wrong. So we check for that possibility:
// check for invalid position if (pos <= 0)
// ok, now what?
What should we do if the user requests an invalid position? The most extreme thing we can do is terminate the program. The standard library exit() function does just that. We pass it a value, and that value becomes the exit status of the program:
// terminate program with exit status of -1 if (pos <= 0)
exit(-1);
To use exit(), we must include the cstdlib header file:
#include <cstdlib>
31

Having our small function terminate an entire program is probably too severe. One alternative is to throw an exception indicating that fibon_elem() has received an invalid position. Unfortunately, exception handling is not discussed until Chapter 7, so that solution isn't an option just now.
We could return 0 and trust that the user recognizes that zero is an invalid value within the Fibonacci sequence. In general, however, trust is not a sound engineering principle. A more reasonable choice is to change our return value to indicate whether fibon_elem() is able to calculate the value:
// revised function prototype bool fibon_elem(int pos, int &elem);
A function can return only one value. In this case, the value returned is either true or false based on whether fibon_elem() can calculate the element's value. That leaves us with the problem of returning the element's actual value. In our revised function prototype, we solve that problem by adding a second parameter of type reference to int. This allows us in effect to have two values returned from the function. I explain the difference in behavior between the parameters pos and elem in the next section. It's a somewhat complicated idea that is best treated in a section of its own.
What happens if the user asks for the element value at position 5,000? That's a large number. When I tried to calculate it, I received the following answer:
element # 5000 is -1846256875
That's not correct. What happened? I call it the ineluctable modality of the computer. Each arithmetic type can represent only a minimum and a maximum value of all possible domain values. [1] int, for example, is a signed type. The result of fibon_elem() overflowed the maximum positive value it can represent. When I changed elem to be of type unsigned int, the answer became
[1] To determine the minimum and maximum values for a particular type, we can query the standard library numeric_limits class (for more details, see [STROUSTRUP97):
#include <limits> int max_int = numeric_limits<int>::max(); double min_dbl = numeric_limits<double>::min(); element # 5000 is 2448710421
What would happen if the user asked for the 10,000th position? The 100,000th? The millionth? There is no end to the Fibonacci sequence. Our implementation, however, must impose an endpoint to the position value we are willing to support. How do we decide on that endpoint? Ultimately, that depends on the requirements of our users. For my purposes here, I've imposed an arbitrary but sufficient upward limit of 1,024 (it allows elem to remain an ordinary int).
Here is the final implementation of fibon_elem():
bool fibon_elem(int pos, int &elem) {
// check if invalid position ... if (pos <= 0 || pos > 1024)
{ elem = 0; return false; }
// elem is 1 for positions 1 and 2 elem = 1;
32

int n_2 = 1, n_1 = 1;
for (int ix = 3; ix <= pos; ++ix) {
elem = n_2 + n_1; n_2 = n_1; n_1 = elem; }
return true; }
The following small program exercises fibon_elem():
#include <iostream> using namespace std;
// forward declaration of fibon_elem() // makes function known to compiler ... bool fibon_elem(int, int&);
int main() {
int pos; cout << "Please enter a position: "; cin >> pos;
int elem; if (fibon_elem(pos, elem))
cout << "element # " << pos << " is " << elem << endl;
else cout << "Sorry. Could not calculate element # " << pos << endl;
}
In our example, the declaration of fibon_elem() does not provide names for its two parameters. This is OK. The name of a parameter is necessary only if we need access to the parameter within the function. Some authors recommend always specifying the parameter names as a form of documentation. In a small program such as this, there seems little real benefit in doing so.
When the program is compiled and executed, the output looks like this (my input is highlighted in bold):
Please enter a position: 12 element # 12 is 144
A function that declares a non-void return type must return a value at each of its exit points. Each return statement within a function represents an explicit exit point. An implicit exit point follows the last statement within the function body if it is not a return statement. The following definition of print_sequence(), for example, fails to compile because its implicit exit point does not return a value.
bool print_sequence(int pos) {
if (pos <= 0 || pos > 1024) {
cerr << "invalid position: " << pos << " -- cannot handle request!\n";
33

return false; } cout << "The Fibonacci Sequence for "
<< pos << " positions: \n\t";
// prints 1 1 for all values except pos == 1 switch (pos) {
default: case 2:
cout << "1 "; // no break; case 1: cout << "1 "; break; }
int elem; int n_2 = 1, n_1 = 1; for (int ix = 3; ix <= pos; ++ix) {
elem = n_2 + n_1; n_2 = n_1; n_1 = elem;
// print 10 elements to a line cout << elem << (!(ix % 10) ? "\n\t" : " "); } cout << endl;
// compiler error is generated here: // implicit exit point ... no return statement! }
print_sequence() contains two exit points, but we have specified only one return statement. An implicit exit point occurs following the last statement. Our implementation returns a value only for an invalid position! Oops. Luckily, the compiler catches this and flags it as an error. We need to add a return true; as the last statement.
To exercise this implementation, I added a call to print_sequence() following the call to fibon_elem() in the earlier main() program. When compiled and executed, our main() program now generates the following output:
Please enter a position: 12 element # 12 is 144 The Fibonacci Sequence for 12 positions:
1 1 2 3 5 8 13 21 34 55 89 144
A second form of the return statement does not return a value. It is used only in functions with a void return type. It is used to terminate a function prematurely.
void print_msg(ostream &os, const string &msg) {
if (msg.empty()) // nothing to print; terminate function ... return;
os << msg; }
34

In this example, a final return statement is unnecessary because no value is being returned. The implicit exit point is sufficient.
Exercise 2.1
main(), presented earlier, allows the user to enter only one position value and then terminates. If a user wishes to ask for two or more positions, she must execute the program two or more times. Modify main() to allow the user to keep entering positions until she indicates she wishes to stop.
2.2 Invoking a Function
In this section we implement a function to sort a vector of integer values so that we can explore the behavior of passing parameters both by reference and by value. The sorting algorithm is a simple bubble sort implemented by two nested for loops. The outer for loop walks through the vector elements from ix, which begins at 0 and ends at size-1. The idea is that upon completion of each iteration of the outer loop, the element indexed by ix is in its proper place. When ix is 0, the smallest element is found and placed at position 0, and when ix is 1, the second smallest element is in place, and so on. The placement is executed by the inner for loop. jx begins at ix+1 and ends at size-1. It compares the element value at ix with the element value at jx. If the element value at jx is smaller, the two element values are swapped. Our first implementation fails. The purpose of this section is to explain why. Here we go.
void display(vector<int> vec) {
for (int ix = 0; ix < vec.size(); ++ix) cout << vec[ix] << ' ';
cout << endl; }
void swap(int val1, int val2) {
int temp = val1; val1 = val2; val2 = temp; }
void bubble_sort(vector<int> vec) {
for (int ix = 0; ix < vec.size(); ++ix) for (int jx = ix+1; jx < vec.size(); ++jx) if (vec[ix] > vec[jx]) swap(vec[ix], vec[jx]);
}
int main() {
int ia[8] = { 8, 34, 3, 13, 1, 21, 5, 2 }; vector<int> vec(ia, ia+8);
cout << "vector before sort: "; display(vec);
bubble_sort(vec);
cout << "vector after sort: ";
35

display(vec); }
When this program is compiled and executed, the following output is generated, showing that the vector defined within main() is not sorted:
vector before sort: 8 34 3 13 1 21 5 2 vector after sort: 8 34 3 13 1 21 5 2
It's not unusual to have a program not work the first time we run it. The question is, what do we do now?
If we have a debugger available, a good next step is to step through the program's execution, examining the run-time values of the various objects in our program and watching the actual control flow of the for loops and if statement. A more practical approach in the context of this text is to add print statements to trace the control logic and display the state of the objects. So where do we begin?
The nested for loops represent the critical area of our program — in particular, the test of the two elements and call of swap(). If the sorting algorithm isn't working, this portion of the program is likely to be failing. I've instrumented it as follows:
ofstream ofil("text_out1"); void bubble_sort(vector<int> vec) {
for (int ix = 0; ix < vec.size(); ++ix) for (int jx = ix+1; jx < vec.size(); ++jx) if (vec[ix] > vec[jx]){ // debugging output ofil << "about to call swap!" << " ix: " << ix << " jx: " << jx << '\t' << " swapping: " << vec[ix] << " with " << vec[jx] << endl;
// ok: actual swap code ... swap(vec[ix], vec[jx]); } }
After we compile and execute the program, the following debugging output is generated. Two things are surprising: swap() is called exactly as it should be, and the vector is nevertheless unchanged from its original order. Who said programming is fun?
vector before sort: 8 34 3 13 1 21 5 2 about to call swap! ix: 0 jx: 2 swapping: 8 with 3 about to call swap! ix: 0 jx: 4 swapping: 8 with 1 about to call swap! ix: 0 jx: 6 swapping: 8 with 5 about to call swap! ix: 0 jx: 7 swapping: 8 with 2 about to call swap! ix: 1 jx: 2 swapping: 34 with 3 about to call swap! ix: 1 jx: 3 swapping: 34 with 13 about to call swap! ix: 1 jx: 4 swapping: 34 with 1 about to call swap! ix: 1 jx: 5 swapping: 34 with 21 about to call swap! ix: 1 jx: 6 swapping: 34 with 5 about to call swap! ix: 1 jx: 7 swapping: 34 with 2 about to call swap! ix: 2 jx: 4 swapping: 3 with 1 about to call swap! ix: 2 jx: 7 swapping: 3 with 2 about to call swap! ix: 3 jx: 4 swapping: 13 with 1 about to call swap! ix: 3 jx: 6 swapping: 13 with 5
36

about to call swap! ix: 3 jx: 7 swapping: 13 with 2 about to call swap! ix: 5 jx: 6 swapping: 21 with 5 about to call swap! ix: 5 jx: 7 swapping: 21 with 2 about to call swap! ix: 6 jx: 7 swapping: 5 with 2 vector after sort: 8 34 3 13 1 21 5 2
An examination of swap() should convince us that it is implemented correctly. If we've started to doubt our judgment, however, we can instrument swap() to confirm that it is correctly swapping values:
void swap(int val1, int val2) {
ofil << "swap(" << val1 << ", " << val2 << ")\n";
int temp = val1; val1 = val2; val2 = temp;
ofil << "after swap(): val1 " << val1 << " val2: " << val2 << "\n";
}
In addition, after calling swap(), I added a call of display() to see the state of the vector. The output shows us that (1) everything is working correctly, and (2) nothing is coming out right:
vector before sort: 8 34 3 13 1 21 5 2 about to call swap! ix: 0 jx: 2swapping: 8 with 3 swap(8, 3) after swap(): val1 3 val2: 8 vector after swap(): 8 34 3 13 1 21 5 2
The trace output shows that bubble_sort() correctly recognizes that the first and third elements, values 8 and 3, must be swapped. swap() is correctly invoked, and, within swap(), the values are correctly swapped. The vector, however, is not changed.
Unfortunately, this is not something we're just going to figure out on our own. If you're like me, you tend to be dogged about problems, hunkering down and thinking you can bull your way through. Sometimes, what we need more than a stubborn streak is someone to show us the missing bit of the puzzle.
The problem has to do with how we are passing the arguments to swap(). A way to approach this issue is to ask this question: What is the relationship between, on the one hand, the two elements of the vector passed to swap() from within bubble_sort() and, on the other hand, the two parameters manipulated within swap()?
void bubble_sort(vector<int> vec) {
// ... if (vec[ix] > vec[jx])
swap(vec[ix], vec[jx]); // ... }
void swap(int val1, int val2) {
// what is the relationship between // the formal parameters val1, val2
37

// and the actual arguments vec[ix] and vec[jx]? }

What is the relationship between vec[ix] and vec[jx], passed to the call of swap(), and the two parameters of swap(), val1 and val2? If both pairs represent the same two objects, then changing val1 and val2 within swap() should change the values within vec[ix] and vec[jx]. But this is not what is happening. It is as if we were manipulating two different pairs of objects that have no relationship to each other except that both pairs hold the same values.

This, in fact, is exactly what is happening. It explains why even though we swap the values, the change is not reflected in the vector. In effect, the objects passed to swap() are copied, and there is no relationship between the two pairs of objects.

When we invoke a function, a special area of memory is set up on what is called the program stack. Within this special area of memory there is space to hold the value of each function parameter. (It also holds the memory associated with each object defined within the function — we call these local objects.) When the function completes, this area of memory is discarded. (We say that it is popped from the program stack.)

By default, when we pass an object to a function, such as vec[ix], its value is copied to the local definition of the parameter. (This is called pass by value semantics.) There is no connection between the objects manipulated within swap() and the objects passed to it within bubble_sort(). That is why our program fails.

For our program to work, we must somehow bind the swap() parameters to the actual objects being passed in. (This is called pass by reference semantics.) The simplest way of doing this is to declare the parameters as references:

/*

* OK: by declaring val1 and val2 as references

*

changes to the two parameters within swap()

*

are reflected in the objects passed to swap()

*/

void swap(int & val1, int & val2)

{

/*

* note that our code within swap()

* does not change -- only the relationship

* between the parameters of swap() and the

* objects passed to swap() changes

*/

int temp = val1;

val1 = val2;

val2 = temp;

}

Before I explain references, let's confirm that in fact this small change corrects our program. Here is a partial trace of a recompilation and execution of our program:

vector before sort: 8 34 3 13 1 21 5 2 about to call swap! ix: 0 jx: 2 swapping: 8 with 3 3 34 8 13 1 21 5 2 about to call swap! ix: 0 jx: 4 swapping: 3 with 1 1 34 8 13 3 21 5 2 about to call swap! ix: 1 jx: 2 swapping: 34 with 8 1 8 34 13 3 21 5 2 about to call swap! ix: 1 jx: 4 swapping: 8 with 3

38

// ... about to call swap! ix: 5 jx: 7 swapping: 21 with 13 1 2 3 5 8 13 34 21 about to call swap! ix: 6 jx: 7 swapping: 34 with 21 1 2 3 5 8 13 21 34 vector after sort: 8 34 3 13 1 21 5 2
Oops. Everything is working great now except that the vector within main() that we pass to bubble_sort() is not being changed. Now that we're experienced, the first thing we look for is a parameter passed by value rather than by reference:
void bubble_sort(vector<int> vec){ /* ... */ }
Changing vec to be a reference is the final correction to our program:
void bubble_sort(vector<int> &vec){ /* ... */ }
To confirm that, let's recompile and execute:
vector before sort: 8 34 3 13 1 21 5 2 vector after sort: 1 2 3 5 8 13 21 34
Whew! That was hard. A lot of programming is like that. Often, the solution is pretty simple, but only after you understand what the problem is.
Pass by Reference Semantics
A reference serves as an indirect handle to an object. We declare a reference by sandwiching an ampersand (&) between the type's name and the name of the reference:
int ival = 1024; // an object of type int int *pi = &ival; // a pointer to an object of type int int &rval = ival; // a reference to an object of type int
When we write
int jval = 4096; rval = ival;
we assign ival, the object rval refers to, the value stored by jval. We do not cause rval to now refer to jval. A reference cannot be reassigned to refer to another object. When we write
pi = &rval;
we assign pi the address of ival, the object rval refers to. We do not cause pi to point to rval. All manipulation of a reference acts on the object the reference refers to. This is also true when the reference is a function parameter.
When we assign val1 with val2 within swap(),
void swap(int &val1, int &val2) {
// the actual arguments are modified ... int temp = val1; val1 = val2;
39

val2 = temp; }
we are really assigning vec[ix] with vec[jx], which are the two objects val1 and val2 refer to in the call of swap() within bubble_sort():
swap(vec[ix], vec[jx]);
Similarly, when val2 is assigned with temp within swap(), we are really assigning vec[jx] with the original value of vec[ix].
When an object is passed to a reference parameter, the object's value is not copied. Rather, the address of the object being passed is copied. Each access of the reference parameter within the function is an indirect manipulation of the object passed in.
One reason to declare a parameter as a reference is to allow us to modify directly the actual object being passed to the function. This is important because, as we've seen, our program otherwise may behave incorrectly.
A second reason to declare a parameter as a reference is to eliminate the overhead of copying a large object. This is a less important reason. Our program is correct; it is simply less efficient.
For example, we currently pass our vector to display() by value. This means that we copy the entire vector object each time we wish to display it. This is not wrong. The output generated is exactly what we want. It is simply faster to pass the address of the vector. Again, one way to do that is to declare the vector parameter to be a reference:
void display(const vector<int> &vec) {
for (int ix = 0; ix < vec.size(); ++ix) cout << vec[ix] << ' ';
cout << endl; }
We declare it to be a reference to const vector because we do not modify it within the body of the function. It is not an error to omit the const. Having the const there informs readers of the program that we are passing the vector by reference to prevent copying it rather than to modify it within the function.
If we wish, we can pass our vector as a pointer parameter. The effect is the same: We pass the address of the object into the function rather than make a copy of the entire object. One difference, of course, is the syntax between a reference and a pointer. For example,
void display(const vector<int> *vec) {
if (! vec){ cout << "display(): the vector pointer is 0\n"; return;
} for (int ix = 0; ix < vec->size(); ++ix)
cout << (*vec)[ix] << ' '; cout << endl; }
int main() {
int ia[8] = { 8, 34, 3, 13, 1, 21, 5, 2 };
40

vector<int> vec(ia, ia+8);
cout << "vector before sort: "; display(&vec); // pass the address now
// ... }
A more important difference between a pointer and a reference parameter is that a pointer may or may not actually address an object. Before we dereference a pointer, we must always make sure that it is not set to 0. A reference, however, always refers to some object, so the check for 0 is unnecessary.
In general, unless you wish to modify the parameter within the function, as we did with fibon_elem() in the preceding section,
bool fibon_elem(int pos, int &elem);
I recommend not passing built-in types by reference. The reference mechanism is primarily intended to support the passing of class objects as parameters to functions.
Scope and Extent
Objects defined within a function, with the requisite one exception, exist only while the function is executing. Returning the address of one of these local objects results in serious run-time program errors. Recall that a function is temporarily placed on the program stack in a special area of memory for the extent of its execution. Local objects are stored in this area of memory. When the function completes, this area of memory is discarded. The local objects no longer exist. Addressing a nonexisting object in general is a bad programming idiom. For example, fibon_seq() returns a vector of Fibonacci elements of some user-specified size:
vector<int> fibon_seq(int size) {
if (size <= 0 || size > 1024) {
cerr << "Warning: fibon_seq(): " << size << " not supported -- resetting to 8\n";
size = 8; }
vector<int> elems(size); for (int ix = 0; ix < size; ++ix)
if (ix == 0 || ix == 1) elems[ix] = 1;
else elems[ix] = elems[ix-1] + elems[ix-2];
return elems; }
It would be incorrect to return elems by either reference or pointer because elems ceases to exist with the completion of fibon_seq(). Returning elems by value is OK: The copy of the object returned exists outside the function. [2]
[2] A class object returned by value is optimized by most C++ compilers into an additional reference parameter. For a discussion of the name return value optimization, see Section 14.8 of [LIPPMAN98].
41

The period of time for which memory is allocated for an object is called its storage duration or extent. The memory for elems is allocated each time fibon_seq() is executed. It is deallocated each time fibon_seq() terminates. We say that it has local extent. (Function parameters, such as size, also have local extent.)
The region of the program over which an object is active is called its scope. We say that size and elems have local scope within the function fibon_seq(). The name of an object that has local scope is not visible outside its local scope.
An object declared outside a function has file scope. An object that has file scope is visible from the point of its declaration to the end of the file within which it is named. An object at file scope has static extent. This means that its memory is allocated before the beginning of main() and remains allocated until the program is terminated.
An object of a built-in type defined at file scope is always initialized to 0. An object of a built-in type defined at local scope, however, is left uninitialized unless explicitly provided with an initial value by the programmer.
Dynamic Memory Management
Both local and file extent are managed for us automatically. There is a third form of storage duration called dynamic extent. This memory comes from the program's free store and is sometimes called heap memory. This memory must be managed explicitly by the programmer. Memory allocation is done using the new expression, whereas memory deallocation is done using the delete expression.
The new expression is written this way:
new Type;
Here, Type can be any built-in or class type known to the program, or the new expression can be written as
new Type(initial_value);
For example,
int *pi; pi = new int;
assigns pi the address of an object of type int allocated in heap memory. By default, an object allocated on the heap is uninitialized. The second form of the new expression allows us to specify an initial value. For example,
pi = new int(1024);
also assigns pi the address of an object of type int allocated in heap memory. This object, however, is initialized to a value of 1,024.
To allocate an array of heap elements, we write
int *pia = new int[24];
42

This code allocates an array of 24 integer objects on the heap. pia is initialized to address the first element of this array. The array elements themselves are uninitialized. There is no syntax for initializing an array of elements allocated on the heap.
A heap object is said to have dynamic extent because it is allocated at run-time through use of the new expression and continues to exist until explicitly deallocated through use of the delete expression. For example, the following delete expression causes the object addressed by pi to be deallocated:
delete pi;
To delete an array of objects, we add an empty subscript operator between the pointer addressing the array and the delete expression:
delete [] pia;
We do not need to check that pi is nonzero:
if (pi != 0) // unnecessary -- compiler checks for us delete pi;
The compiler does this check automatically. If for some reason the programmer does not apply the delete expression, the heap object is never deallocated. This is called a memory leak. In Chapter 6, we look at why we might choose to use dynamic memory allocation in the design of our programs. We look at ways to prevent memory leaks in our discussion of exception handling in Chapter 7.
2.3 Providing Default Parameter Values
Printing a trace of our bubble sort program to ofil required that I make ofil available to the multiple functions I wished to debug. Because I was responding to unexpected and unwelcomed behavior, I chose the quickest solution to the problem of making an object visible across multiple functions: I defined ofil at file scope.
As a general programming rule, however, it is better to communicate between functions using parameters rather than use objects defined at file scope. One reason is that a function that is dependent on an object defined at file scope is harder to reuse in a different context. The function is also harder to modify: We must understand not only the logic specific to the function but also the logic of the objects defined at file scope.
Let's see how we might revise bubble_sort() to do away with its reliance on the file scope instance of ofil:
void bubble_sort(vector<int> &vec, ofstream &ofil) {
for (int ix = 0; ix < vec.size(); ++ix) for (int jx = ix+1; jx < vec.size(); ++jx) if (vec[ix] > vec[jx]) { ofil << "about to call swap! ix: " << ix << " jx: " << jx << "\tswapping: " << vec[ix] << " with " << vec[jx] << endl;
43

swap(vec[ix], vec[jx], ofil); } }
Although this technique removes our reliance on the file scope instance of ofil, it introduces a number of potentially vexing problems. Every call to bubble_sort() now requires our user to pass in an ofstream class object. Also, we're generating this information without the user being able to turn it off. In the general case, when things are going well, no one is interested in this information.
We'd prefer not to bother the user either with having to specify an output stream or with having to turn anything off. By default, we'd like not to generate information. However, we'd like to allow the interested user to generate the information and specify the file into which the information should be stored. How might we do that?
C++ allows us to associate a default value for all or a subset of parameters. In our case, we provide the ofstream pointer parameter with a default value of 0:
void bubble_sort(vector<int> &vec, ofstream *ofil = 0) {
for (int ix = 0; ix < vec.size(); ++ix) for (int jx = ix+1; jx < vec.size(); ++jx) if (vec[ix] > vec[jx]) { if (ofil != 0) (*ofil) << "about to call swap! ix: " << ix << " jx: " << jx << "\tswapping: " << vec[ix] << " with " << vec[jx] <<
endl; swap(vec[ix], vec[jx], ofil);
} }
This revised version of bubble_sort() declares its second parameter as a pointer to an ofstream object rather than as a reference. We must make this change to provide a default value of 0, indicating that no ofstream object is addressed. Unlike a pointer, a reference cannot be set to 0. A reference must always refer to some object.
An invocation of bubble_sort() with a single argument generates no debugging information. An invocation with a second argument that addresses an ofstream object generates the debugging information:
int main() {
int ia[8] = { 8, 34, 3, 13, 1, 21, 5, 2 }; vector<int> vec(ia, ia+8);
// no debug information -// it is as if we invoked bubble_sort(vec, 0); bubble_sort(vec); display(vec);
// ok: debug information generated ... ofstream ofil("data.txt"); bubble_sort(vec, &ofil); display(vec, ofil); }
44

The implementation of display() presents a different situation. Currently, it hard-codes the output to cout. In the general case, cout is fine. In some cases, however, users are likely to prefer to supply an alternative target, such as a file. Our implementation must support both uses of display() in main(). Our solution is to make cout the default ostream parameter:
void display(const vector<int> &vec, ostream &os = cout) {
for (int ix = 0; ix < vec.size(); ++ix) os << vec[ix] << ' ';
os << endl; }
There are two somewhat unintuitive rules about providing default parameters. The first rule is that default values are resolved positionally beginning with the right-most parameter. If a parameter is provided with a default value, all the parameters to its right must also have a default value. The following, for example, is illegal:
// error: no default value for vec void display(ostream &os = cout, const vector<int> &vec);
The second rule is that the default value can be specified only once — either in the declaration or in the definition of the function, but not both. So where should we specify the default value?
Typically, a function declaration is placed in a header file. This header file is then included by files that wish to use the function. (Recall that we included the cstdlib header file to include the declaration of the exit() library function.) The definition of a function typically is placed in a program text file. This file is compiled once and is linked to our program whenever we wish to use the function. The header file, that is, provides the greater visibility of the function. (Header files are discussed in more detail in Section 2.9.)
Because of its greater visibility, we place the default value in the function declaration rather than in the function definition. For example, the declaration and definition of display() generally would look like this:
// header file declaration specifies default value // let's call the header file: NumericSeq.h
void display(const vector<int>&, ostream&=cout);
// program text file definition includes header file // the definition itself does not specify the default value
#include "NumericSeq.h"
void display(const vector<int> &vec, ostream &os) {
for (int ix = 0; ix < vec.size(); ++ix) os << vec[ix] << ' ';
os << endl; }
2.4 Using Local Static Objects
45

Our fibon_seq() function of Section 2.2 calculates a Fibonacci sequence of a user-specified size with each invocation, returning a vector holding the elements. That is a bit more work than is necessary.
We really need only one Fibonacci sequence vector. The elements, after all, are invariant. The only thing that changes from one call of fibon_seq() to the next is the number of elements the user wishes to have available. Consider the following three invocations of fibon_seq():
fibon_seq(24); fibon_seq(8); fibon_seq(18);
The first call calculates all the values necessary to fulfill the request of the second and third invocations. If a fourth invocation requested 32 elements, we really need calculate only elements 25 through 32 — if we could cache the elements calculated between invocations. How might we do that?
A vector object local to the function does not provide a solution. The local object is created with each invocation of the function and is discarded as soon as the function terminates. A tempting alternative is to define a vector object at file scope. It is always tempting to introduce an object at file scope to solve a communications problem between functions. In general, however, file scope objects complicate the independence and understandability of individual functions.
An alternative solution, in this case, is a local static object. For example,
const vector<int>* fibon_seq(int size) {
static vector<int> elems; // do the logic to populate it ...
return &elems; }
elems is now defined as a local static object of fibon_seq(). What does this mean? Unlike a nonstatic local object, the memory associated with a static local object persists across function invocations. elems is no longer destroyed and re-created with each invocation of fibon_seq(). This is why we can now safely return elems's address.
A local static object allows us to define a single vector to hold the elements of the Fibonacci sequence. With each invocation of fibon_seq(), we need calculate only those elements that are not as yet inserted into elems. Here is one possible implementation:
const vector<int>* fibon_seq(int size) {
const int max_size = 1024; static vector<int> elems;
if (size <= 0 || size > max_size){ cerr << "fibon_seq(): oops: invalid size: " << size << " -- can't fulfill request.\n"; return 0;
}
// if size is equal to or greater than elems.size(), // no calculations are necessary ...
46

for (int ix = elems.size(); ix < size; ++ix){ if (ix == 0 || ix == 1) elems.push_back(1); else elems.push_back(elems[ix-1]+elems[ix-2]);
} return &elems; }
Previously, we have always defined a vector to be of a particular size and have assigned values to existing elements. But in this version of fibon_seq(), we have no way of guessing how big a vector we'll need. Rather, we define elems to be an empty vector and insert elements as we need them. push_back() inserts the value at the back of the vector. The memory to support this is managed automatically by the vector class itself. (In Chapter 3 we look in detail at vectors and the other standard library container classes.)
2.5 Declaring a Function Inline
Recall that fibon_elem() returns the Fibonacci element at a user-specified position within the sequence. In our original implementation, it calculates the sequence up to the requested position with each invocation. It also tests whether the requested position is reasonable. We can simplify its implementation by factoring subtasks into separate functions:
bool is_size_ok(int size) {
const int max_size = 1024; if (size <= 0 || size > max_size) {
cerr << "Oops: requested size is not supported : " << size << " -- can't fulfill request.\n";
return false; } return true; }
// calculate up to size elements of Fibonacci sequence // return address of static container holding elements const vector<int> *fibon_seq(int size) {
static vector<int> elems; if (! is_size_ok(size))
return 0;
for (int ix = elems.size(); ix < size; ++ix) if (ix == 0 || ix == 1) elems.push_back(1); else elems.push_back(elems[ix-1]+elems[ix-2]);
return &elems; }
// returns the Fibonacci element at position pos // (we must adjust by 1 because first element is stored at 0) // returns false if position is unsupported bool fibon_elem(int pos, int &elem) {
const vector<int> *pseq = fibon_seq(pos);
47

if (! pseq) { elem = 0; return false; }
elem = (*pseq)[pos-1]; return true; }
By factoring size checking into is_size_ok() and the calculation of the Fibonacci elements into fibon_seq(), we make fibon_elem() simpler to implement and understand. In addition, these two functions are now available to other applications.
The drawback is that fibon_elem() now requires three function calls to complete its operation, whereas previously it required only one. Is this additional overhead critical? That depends on the context of its use. If its performance should prove unacceptable, one solution is to fold the three functions back into one. In C++, an alternative solution is to declare the functions as inline.
An inline function represents a request to the compiler to expand the function at each call point. With an inline function, the compiler replaces the function call with a copy of the code to be executed. In effect, this allows us to benefit from the performance improvement of folding the functions back into fibon_elem() while still maintaining the three functions as independent operations.
We declare a function inline by prefixing its definition with the inline keyword:
// ok: now fibon_elem() is an inline function inline bool fibon_elem(int pos, int &elem)
{ /* definition same as above */ }
The inline specification is only a request to the compiler. Whether the compiler actually honors the request is implementation-dependent. (For a discussion of why the inline specification is only a request, see Section 7.1.1 of [STROUSTRUP97].)
In general, the best candidate functions for inlining, such as fibon_elem() and is_size_ok(), are small, frequently invoked, and not computationally complex.
The definition of an inline function is usually placed within a header file. For it to be expanded, its definition must be available before its call. (This is discussed further in Section 2.9.)
2.6 Providing Overloaded Functions
Rather than have each function generate its own diagnostic messages, let's provide a general display_message() function. It might be used as follows:
bool is_size_ok(int size) {
const int max_size = 1024; const string msg("Requested size is not supported");
if (size <= 0 || size > max_size){ display_message(msg, size); return false;
} return true; }
48

Similarly, our program in Chapter 1 might use it to display its greeting to the user
const string greeting("Hello. Welcome to Guess the Numeric Sequence");
display_message(greeting);
and to display the two elements of the sequence:
const string seq("The two elements of the sequence are "); display_message(seq, elem1, elem2);
In another instance, we might want to use display_message() simply to output a newline or tab character:
display_message('\n'); display_message('\t');
Can we really pass parameters to display_message() that differ both in type and number? Yes. How? Through function overloading.
Two or more functions can be given the same name if the parameter list of each function is unique either by the type or the number of parameters. For example, the following declarations represent the four overloaded instances of display_message() invoked earlier:
void display_message(char ch); void display_message(const string&); void display_message(const string&, int); void display_message(const string&, int, int);
How does the compiler know which instance of the four overloaded functions to invoke? It compares the actual arguments supplied to the function invocation against the parameters of each overloaded instance, choosing the best match. This is why the parameter list of each overloaded function must be unique.
The return type of a function by itself does not distinguish two instances of a function that have the same name. The following, for example, is illegal. It results in a compile-time error:
// error: parameter list not return type must be unique ostream& display_message(char ch); bool display_message(char ch);
Why isn't the return type itself sufficient to overload a function? It is because the return type cannot guarantee a sufficient context with which to distinguish instances. For example, in the following call there is really no way for the compiler to determine which instance the user wished to have invoked:
display_message('\t'); // which one?
Overloading a set of functions that have unique implementations but perform a similar task simplifies the use of these functions for our users. Without overloading, we would have to provide each function with a unique name.
2.7 Defining and Using Template Functions
49

Let's say that a colleague of ours has asked for three additional display_message() instances to handle a vector of integers, a vector of doubles, and a vector of strings:
void display_message(const string&, const vector<int>&); void display_message(const string&, const vector<double>&); void display_message(const string&, const vector<string>&);
On completing the implementation of these three instances, we notice that the function body for each instance is exactly the same. The only difference across these functions is the type of the second parameter: [3]
[3] A more flexible implementation adds a third parameter of type ostream that by default is set to cout:
void display_message(const string&, const vector<string>&, ostream& = cout);
void display_message(const string &msg, const vector<int> &vec) {
cout << msg; for (int ix = 0; ix < vec.size(); ++ix)
cout << vec[ix] << ' '; }
void display_message(const string &msg, const vector<string> &vec) {
cout << msg; for (int ix = 0; ix < vec.size(); ++ix)
cout << vec[ix] << ' '; cout << '\n'; }
void display_message(const string&, const vector<string>&, ostream& = cout);
There's no reason to think that another colleague won't come along asking for yet another instance that supports a vector of some additional type. It would certainly save us a great deal of effort if we could define a single instance of the function body rather than duplicate the code multiple times and make the necessary minor changes to each instance. To do that, however, we need a facility to bind that single instance to each vector type we wish to display. The function template mechanism provides just this facility.
A function template factors out the type information of all or a subset of the types specified in its parameter list. In the case of display_message(), we wish to factor out the type of the element contained within the vector. This allows us to define a single instance of the unchanging part of the function template. It is incomplete, however, because the factored-out type information is missing. This type information is supplied by the user in using a particular instance of the function template.
A function template begins with the keyword template. It is followed by a list of one or more identifiers that represent the types we wish to defer. The list is set off by a less-than/greater-than bracket pair (<, >). The user supplies the actual type information each time he uses a particular instance of the function. These identifiers in effect serve as placeholders for actual data types within the parameter list and body of the function template. For example,
template <typename elemType> void display_message(const string &msg,
const vector<elemType> &vec)
50

{ cout << msg; for (int ix = 0; ix < vec.size(); ++ix) { elemType t = vec[ix]; cout << t << ' '; }
}
The keyword typename specifies elemType as a type placeholder within the function template display_message(). elemType is an arbitrary name. I could have easily chosen foobar or T. We must defer the actual type of the vector to be displayed. We do that by placing elemType within the bracket pair following vector.
What about the first parameter? msg never varies its type with each invocation of display_message(). It is always a constant reference to a string class object, so there is no need to factor its type. A function template typically has a combination of explicit and deferred type specifiers in its parameter list.
How do we use a function template? It looks pretty much the same as the use of an ordinary function. For example, when we write
vector<int> ivec; string msg; // ... display_message(msg, ivec);
the compiler binds elemType to type int. An instance of display_message() is created in which the second parameter is of type vector<int>. Within the function body, the local object t also becomes an object of type int. Similarly, when we write
vector<string> svec; // ... display_message(msg, svec);
elemType becomes bound to type string. An instance of display_message() is created in which the second parameter is of type vector<string>, and so on.
The function template serves as a kind of prescription for the generation of an unlimited number of function instances in which elemType is bound to a built-in or user-defined class type.
In general, we overload a function when there are multiple implementations, but each instance provides the same general service. We make a function a template when the body of the code remains invariant across a variety of types.
A function template can also be an overloaded function. For example, let's provide two instances of display_message(): one with a second parameter of type vector, and the other with a second parameter of type list. (list is another container class defined in the C++ standard library. We look at the list container class in Chapter 3.)
// overloaded instances of a function template template <typename elemType> void display_message(const string &msg, const vector<elemType> &vec);
template <typename elemType> void display_message(const string &msg, const list<elemType> &lt);
51

2.8 Pointers to Functions Add Flexibility
We must provide a function to return a vector of elements similar to fibon_seq() for each of our other five numerical sequences. The full set of functions might be declared as follows:
const vector<int> *fibon_seq(int size); const vector<int> *lucas_seq(int size); const vector<int> *pell_seq(int size); const vector<int> *triang_seq(int size); const vector<int> *square_seq(int size); const vector<int> *pent_seq(int size);
What about fibon_elem()? Must we also provide six separate instances of this, one for each numeric sequence? The definition of fibon_elem() is as follows:
bool fibon_elem(int pos, int &elem) {
const vector<int> *pseq = fibon_seq(pos);
if (! pseq) { elem = 0; return false; }
elem = (*pseq)[pos-1]; return true; }
The only sequence-dependent aspect of fibon_elem() is the call to the associated sequence function to retrieve the vector of elements. If we eliminate this dependency, we eliminate the need for more than a single instance of the function. We achieve this independence using a pointer — specifically, a pointer to function.
The definition of a pointer to function is complicated. It must specify the return type and parameter list of the function it is addressing. In our case, the parameter list is a single int, and the return type is const vector<int>*. In addition, the definition must place a * somewhere to indicate that the object being defined is a pointer. Finally, of course, we must give the pointer a name. Let's call it seq_ptr. As usual, our first attempt is almost correct.
const vector<int>* *seq_ptr(int); // almost correct
This code defines seq_ptr as a function that has a parameter list of a single int and has a return type of a pointer to a pointer to a const vector of elements of type int! To have seq_ptr be recognized as a pointer, we must override the default precedence of * with parentheses:
const vector<int>* (*seq_ptr)(int); // ok
seq_ptr can address any function with the same return type and parameter list. This means that it can address each of the six numeric sequence functions. Let's rewrite fibon_elem() as the more general seq_elem() as follows:
bool seq_elem(int pos, int &elem, const vector<int>* (*seq_ptr)(int))
{
52

// invoke function addressed by seq_ptr
const vector<int> *pseq = seq_ptr(pos); if (! pseq)
{ elem = 0; return false; }
elem = (*pseq)[pos-1]; return true; }
The function addressed by a pointer to function is invoked in the same way as the function itself. That is,
const vector<int> *pseq = seq_ptr(pos);
is an indirect invocation of the function addressed by seq_ptr. We don't know (or care) what function it addresses. It might be wise, however, to confirm that it does at least address some function:
if (! seq_ptr) display_message("Internal Error: seq_ptr is set to null!");
A pointer to function can be initialized or assigned either 0 to indicate that it addresses no function
const vector<int>* (*seq_ptr)(int) = 0;
or the address of a function. The next question is, how do we access a function's address? It's one of the least complicated operations in C++. We just name it
// assigns seq_ptr the address of pell_seq() seq_ptr = pell_seq;
What if we wish to set seq_ptr to a different sequence function with each iteration of our display loop without having to name each function explicitly? To solve this problem, we can again resort to indexing into an array. In this case, we define an array of pointers to functions:
// seq_array is an array of pointers to functions const vector<int>* (*seq_array[])(int) = {
fibon_seq, lucas_seq, pell_seq, triang_seq, square_seq, pent_seq };
seq_array is an array of pointers to functions holding six elements. The first element is the address of fibon_seq(), the second, lucas_seq(), and so on. We can set seq_ptr with each iteration of a while loop while the user still wishes to guess another sequence:
int seq_index = 0; while (next_seq == true) {
seq_ptr = seq_array[++seq_index]; // ... }
Alternatively, what if we wished to access the pointer explicitly to the function generating the Pell sequence? It is somewhat clumsy having to remember that the Pell instance is addressed by the third array element. A more intuitive method of indexing is to provide a set of mnemonic constant values. For example,
53

enum ns_type { ns_fibon, ns_lucas, ns_pell, ns_triang, ns_square, ns_pent
};
An enumerated type is defined by the keyword enum followed by an optional identifier, such as ns_type. eThe items in the comma-separated list of named values within curly braces are called enumerators. By default, the first enumerator is assigned a value of 0. Each subsequent enumerator is given a value that is 1 greater than its predecessor. For ns_type, ns_fib has an associated value of 0, ns_lucas, 1, ns_pell, 2, and so on through ns_pent, which has an associated value of 5.
To access a particular pointer to function explicitly, we use the associated enumerator as the index:
seq_ptr = seq_array[ns_pell];

2.9 Setting Up a Header File

Before I can invoke seq_elem(), I must first declare it to the program. If it is invoked in five program text files, there must be five declarations available. Rather than separately declare seq_elem() in each of the five files, we place the function declaration in a header file. The header file is then included in each program text file that wishes to use the function.

Using this convention, we need maintain only a single declaration of a function. If its parameter list or return type changes, only this one declaration needs to be modified. All users of the function automatically include the updated function declaration.

Header files by convention are given a .h suffix — except for the standard library header files, which have no suffix. We'll call our header file NumSeq.h and place in it a declaration of all the functions related to our numeric sequences:

// NumSeq.h

bool

seq_elem(int pos, int &elem);

const vector<int> *fibon_seq(int size);

const vector<int> *lucas_seq(int size);

const vector<int> *pell_seq(int size);

const vector<int> *triang_seq(int size);

const vector<int> *square_seq(int size);

const vector<int> *pent_seq(int size);

// and so on ...

There can be only one definition of a function in a program. However, there can be multiple declarations. We don't put definitions in a header file because the header file is included in multiple text files within a program.

One exception to this one-definition rule is the definition of an inline function. To expand an inline function, the definition must be available to the compiler at each invocation point. This means that we must place the inline function definitions inside a header file rather than in a separate program text file.

Objects defined at file scope are also declared in a header file if multiple files may need to access the objects. This is because an object can not be referred to until it has been declared to the

54

program. For example, if seq_array were defined at file scope, we would likely provide a declaration within NumSeq.h. Not unexpectedly, our first try is not quite correct:
// This is not quite right ... const int seq_cnt = 6; const vector<int>* (*seq_array[seq_cnt])(int);
This is not correct because it is interpreted as the definition of seq_array and not as a declaration. Just as with a function, an object can be defined only once in a program. The definition of an object, as well as the definition of a function, must be placed in a program text file. We turn the definition of seq_array into a declaration by prefacing it with the keyword extern:
// OK: this is a declaration extern const vector<int>* (*seq_array[seq_cnt])(int);
OK, granted, you might say. This is analogous to the distinction of placing function declarations in the header file but function definitions in a program text file. But. But. (You're on your feet by this point.) But if all this is true, then isn't seq_cnt also declared extern rather than explicitly defined?
Obviously, this is just to confuse you. Me. The whole gaggle of us.
A const object, like an inline function, is treated as an exception to the rule. The definition of a const object is not visible outside the file it is defined in. This means that we can define it in multiple program files without error.
Why do we want that? It is because we want the compiler to use the value of the const object in our array declarations and other situations in which a constant expression is needed, possibly across multiple files.
A file using either seq_elem() or seq_array includes the header file before a first use of either name:
#include "NumSeq.h" void test_it() {
int elem = 0; if (seq_elem(1, elem) && elem == 1) // ... }
Why is NumSeq.h in quotation marks rather than angle brackets (<,>)? The short answer is that if the header file is in the same directory as the program text file including it, we use quotation marks. If it is anywhere else, we use angle brackets. The slightly more technical answer is that if the file name is enclosed by angle brackets, the file is presumed to be a project or standard header file. The search to find it examines a predefined set of locations. If the file name is enclosed by a pair of quotation marks, the file is presumed to be a user-supplied header file. The search to find it begins in the directory in which the including file is located.
Exercise 2.2
The formula for the Pentagonal numeric sequence is Pn=n*(3n-1)/2. This yields the sequence 1, 5, 12, 22, 35, and so on. Define a function to fill a vector of elements passed in to the function calculated to some user-specified position. Be sure to verify that the position specified is valid. Write a second function that, given a vector, displays its elements. It should take a second parameter identifying the type of numeric series the vector represents. Write a main() function to exercise these functions.
55

Exercise 2.3
Separate the function to calculate the Pentagonal numeric sequence implemented in Exercise 2.2 into two functions. One function should be inline; it checks the validity of the position. A valid position not as yet calculated causes the function to invoke a second function that does the actual calculation.
Exercise 2.4
Introduce a static local vector to hold the elements of your Pentagonal series. This function returns a const pointer to the vector. It accepts a position by which to grow the vector if the vector is not as yet that size. Implement a second function that, given a position, returns the element at that position. Write a main() function to exercise these functions.
Exercise 2.5
Implement an overloaded set of max() functions to accept (a) two integers, (b) two floats, (c) two strings, (d) a vector of integers, (e) a vector of floats, (f) a vector of strings, (g) an array of integers and an integer indicating the size of the array, (h) an array of floats and an integer indicating the size of the array, and (i) an array of strings and an integer indicating the size of the array. Again, write a main() function to exercise these functions.
2.6 Exercise 2.6
Reimplement the functions of Exercise 2.5 using templates. Modify the main() function accordingly.
56

Chapter 3. Generic Programming
The Standard Template Library (STL) consists of two primary components: a set of container classes, including the vector, list, set, and map classes, and a set of generic algorithms to operate over these containers, including find(), sort(), replace(), and merge().
The vector and list container classes represent sequential containers. A sequential container maintains a first element, a second element, and so on through a last element. We primarily iterate over a sequential container. The map and set classes represent associative containers. An associative container supports fast lookup of a value.
A map is a key/value pair: The key is used for lookup, and the value represents the data we store and retrieve. A telephone directory, for example, is easily represented by a map. The key is the individual's name. The value is the associated phone number.
A set contains only key values. We query it as to whether a value is present. For example, if we were to build an index of words that occur in news stories, we would want to exclude neutral words such as the, an, but, and so on. Before a word is entered into the index, we query an excluded_word set. If the word is present, we discard it; otherwise, we include the word in our index.
The generic algorithms provide a large number of operations that can be applied both to the container classes and to the built-in array. The algorithms are called generic because they are independent of both the type of element they are operating on (for example, whether it is an int, double, or string) and the type of container within which the elements are held (whether it is a vector, list, or built-in array).
The generic algorithms achieve type independence by being implemented as function templates. They achieve container independence by not operating directly on the container. Rather, they are passed an iterator pair (first,last), marking the range of elements over which to iterate. While first is unequal to last, the algorithm operates on the element addressed by first, increments first to address the next element, and then recompares first and last for equality. A good first question is, what is an iterator? The next two sections try to answer that.
3.1 The Arithmetic of Pointers
We are assigned the following programming task. We are given a vector of integers and an integer value. If the value is contained within the vector, we must return a pointer to it; otherwise, we return 0, indicating that the value is not present. Here is an implementation:
int* find(const vector<int> &vec, int value) {
for (int ix = 0; ix < vec.size(); ++ix) if (vec[ix] == value) return &vec[ix];
return 0; }
We test the function and are satisfied that it works. We are next assigned the task of having the function work not only with integers but also with any type in which the equality operator is
57

defined. If you have read Section 2.7, you should recognize this task as requiring us to transform find() into a function template:
template <typename elemType> elemType* find(const vector<elemType> &vec,
const elemType &value) {
for (int ix = 0; ix < vec.size(); ++ix) if (vec[ix] == value) return &vec[ix];
return 0; }
Again, we test the function and are satisfied that it works. Our next assignment is to have find() work both for a vector and an array of elements of any type for which an equality operator is defined. Our first thought is to overload the function, providing an instance that takes a vector and an instance that takes an array.
We are advised against overloading in this case. With a little thought, we're told, we can implement find() so that a single instance can handle the elements of either a vector or a builtin array. Gosh, but that seems hard.
One strategy for solving a hard problem is to divide it into a number of smaller and hopefully simpler problems. In this example, our one big problem breaks down into (1) passing the elements of an array to find() without specifying the array and (2) passing the elements of a vector to find() without specifying the vector. Ideally, the solutions to these two problems contain a common solution to our initial problem.
Let's first solve the problem of the built-in array. How can we pass in the elements of an array to find() without specifying the array itself?
Programming a solution to a problem is immeasurably easier when we understand the problem that we are trying to solve. In our case, it will help to first understand how arrays are passed into and returned from functions. When I write
int min(int array[24]) { ... }
it seems as if min() accepts only arrays of 24 elements and that the actual array is being passed by value. In fact, neither assumption is true: The array is not copied by value, and an array of any size can be passed to min(). I know, you're thinking huh?
When an array is passed into or returned from a function, only the address of the first element is passed. The following is the more accurate declaration of min():
int min(int *array) { ... }
min() accepts integer arrays of any dimension: 1, 32, 1,024, and so on. The alternative would be vexing because it would require us to provide a separate instance of min() for each uniquely dimensioned array.
The pointer to the beginning of the array allows min() to begin reading the array. Somehow, we must indicate to min() when the reading of the array should stop. One way is to add an additional parameter that holds the size of the array. For example, here is our declaration of find() using this strategy:
58

template <typename elemType> elemType* find(const elemType *array, int size,
const elemType &value);
An alternative solution is to pass an address that, when reached, indicates that we have completed reading the elements of the array. (We call such a value a sentinel.)
template <typename elemType> elemType* find(const elemType *first, const elemType *sentinel,
const elemType &value);
One interesting aspect of this solution is that we have eliminated the declaration of the array from the parameter list — solving the first of our smaller problems.
Let's look at how each version of find() is implemented. In the first version, we access each element in turn beginning at 0 and proceeding to size-1. The first question is this: Inasmuch as the array is passed to find() as a pointer to its first element, how do we access the elements by position? Even though we are accessing the array through a pointer, we can still apply the subscript operator exactly as we did before:
template <typename elemType> elemType* find(const elemType *array, int size,
const elemType &value) {
if (! array || size < 1) return 0;
for (int ix = 0; ix < size; ++ix) // we can apply subscript operator to pointer if (array[ix] == value) return &array[ix];
return 0; // value not found }
Although the array is passed to find() as a pointer to its first element, we see that individual elements can still be accessed through the subscript operator as if the array were an object. Why? In practice, subscripting is carried out by adding the index to the beginning address of the array to yield the address of the element. That address is then dereferenced to return the value of the element. For example,
array[2];
returns the value of the third element of the array (indexing, remember, begins at 0). The following also returns the value of the third element:
*(array + 2)
If the address of the first element of array is 1000, what address does array+2 yield? 1002 is a reasonable answer, but it is not the correct answer. 1002 is integer arithmetic; array+2, however, represents pointer arithmetic. Pointer arithmetic adds increments of the size of the type being addressed.
Let's say that array contains integer elements. array+2, then, adds the size of two integer elements to the address of array. Under pointer arithmetic, on a machine in which an integer is 4 bytes, the answer is 1008.
59

When we have the address of the element, we must then dereference the address to get the value of the elements. When we write array[2], the pointer arithmetic and address dereferencing are done automatically.
Here is an alternative implementation of find() in which we address each element through a pointer. To address each element of array in turn, we increment it by 1 with each iteration of our loop. To read the element addressed, we must dereference the pointer. That is, array returns the address of the element, and *array returns its value.
template <typename elemType> elemType* find(const elemType *array, int size,
const elemType &value) {
if (! array || size < 1) return 0;
// ++array increments array by one elememt for (int ix = 0; ix < size; ++ix, ++array)
// *array dereferences the address if (*array == value)
return array; return 0; }
In this next version, we replace the size parameter with a second pointer that serves as the sentinel address. This is the version that allows us to remove the declaration of the array from the parameter list:
template <typename elemType> elemType* find(const elemType *first,
const elemType *last, const elemType &value) {
if (! first || ! last) return 0;
// while first does not equal last, // compare value with element addressed by first // if the two are equal, return first // otherwise, increment first to address next element
for (; first != last; ++first) if (*first == value) return first;
return 0; }
This implements the first of our two programming subtasks: we've implemented find() to access each element of our array independent of the array object the elements are contained within. How might find() be invoked? The following code uses the pointer arithmetic we illustrated earlier:
int ia[8] = { 1, 1, 2, 3, 5, 8, 13, 21 }; double da[6] = { 1.5, 2.0, 2.5, 3.0, 3.5, 4.0 }; string sa[4] = { "pooh", "piglet", "eeyore", "tigger" };
int *pi = find(ia, ia+8, ia[3]); double *pd = find(da, da+6, da[3]); string *ps = find(sa, sa+4, sa[3]);
60

The second address marks 1 past the last element of the array. Is that legal? Yes. If we should ever try to read or write to that address, however, all bets are off. But if all we do with that address is to compare it against other element addresses, we're fine. The address 1 past the last element of the array serves as a sentinel indicating that we have completed our iteration.
How might we implement the second programming subtask, that of accessing each element of a vector independent of the vector object the elements are contained within? A vector also holds its elements in a contiguous area of memory, so we can pass find() a begin/end pair of addresses in the same way as we do for the built-in array, except in one case. Unlike an array, a vector can be empty. For example,
vector<string> svec;
defines an empty vector of string elements. The following invocation of find(), if svec is empty, is incorrect and results in a run-time program failure:
find(&svec[0], &svec[svec.size()], search_value);
A safer implementation is first to confirm that svec is not empty.
if (! svec.empty()) // ... ok, call find()
Although this is safer, it is somewhat cumbersome for the user. A more uniform way of accessing the address of the first element is to wrap the operation into a function, something like the following:
template <typename elemType> inline elemType* begin(const vector<elemType> &vec)
{ return vec.empty() ? 0 : &vec[0]; }
A second function, end(), returns either 0 or a pointer to 1 past the last element of the vector. In this way, we can safely and uniformly invoke find() for any vector:
find(begin(svec), end(svec), search_value);
Moreover, this solves our original programming task of implementing find() so that a single instance can accept either a vector or a built-in array. Again, we test the function and are satisfied that it works.
Excellent, we are told. Now extend find() so that a single instance can also support the standard library list class. Now that's hard.
A list class is also a container. The difference is that the elements of a list are linked through a pair of pointers: a forward pointer addressing the next element and a backward pointer addressing the preceding element.
Pointer arithmetic doesn't work with a list. Pointer arithmetic presumes that the elements are contiguous. By adding the size of one element to the current pointer, we reset the pointer to address the next element. This is the underlying assumption of our implementation of find(). Unfortunately, that assumption doesn't hold when we access the next element of a list.
Our first thought again is to provide an overloaded second instance of find() that accepts a list object. The behaviors of the pointers of a built-in array, a vector, and a list are, we claim, simply too different to achieve a uniform syntax for next element access.
61

Yes and no. Yes, the behavior of the underlying pointers is too different for a uniform syntax. And no, we don't need to provide a second instance to support the list class. In fact, we don't need to alter the implementation of find() at all, except for its parameter list.
The solution is to provide a layer of abstraction over the behavior of the underlying pointers. Rather than program the underlying pointers directly, we program the layer of abstraction. We place the unique handling of the underlying pointers within that layer, shielding it from our users. This technique allows us to handle any of the standard library container classes with a single instance of find().
3.2 Making Sense of Iterators
The obvious question is, how do we implement this layer of abstraction? We need a collection of objects that support the same set of operators as the built-in pointer (++, *, ==, !=) but allow us to provide a unique implementation of those operators. We can do exactly this with the C++ class mechanism. We'll design a set of iterator classes that are programmed using the same syntax as that of a pointer. For example, if first and last are list class iterators, we can write
// first and last are iterator class objects while (first != last) {
cout << *first << ' '; ++first; }
the same as if first and last are actual pointers. The difference is that the dereference operator (*), the inequality operator (!=), and the increment operator (++) represent inline function calls associated with the iterator classes. For the list class iterator, for example, the associated increment function advances to the next element by following the list pointer. For the vector class iterator, the increment function advances to the next element by adding the size of one element to the current address.
In Chapter 4 we look at how to implement an iterator class, including how to provide function instances of particular operators. In this section, we look at how to define and use the iterators associated with the standard library container classes.
Where do we get iterators? Each container class provides a begin() operation that returns an iterator that addresses the first element of the container and an end() operation that returns an iterator that addresses 1 past the last element of the container. For example, disregarding how we define an iterator object for the moment, we assign, compare, increment, and dereference an iterator as follows:
for (iter = svec.begin(); iter != svec.end(); ++iter) cout << *iter << ' ';
Before we look at how to define an iterator, let's think for a moment about the information its definition must provide: the type of the container over which it iterates, which determines how it accesses the next element; and the type of the element being addressed, which determines the value returned from a dereference of the iterator.
One possible syntax for an iterator definition might be to pass these two types as parameters to an iterator class:
62

// one possible iterator syntax // note: not actually used in the STL iterator< vector, string > iter;
The actual syntax looks considerably more complicated, at least at first sight. It also provides a more elegant solution, although that may not be apparent, or at least not until we implement and use an iterator class in Chapter 4.
vector<string> svec;
// the standard library iterator syntax // iter addresses vector elements of type string // it is initialized to the first element of svec
vector<string>::iterator iter = svec.begin();
iter is defined to be an iterator for vectors of string elements. It is initialized to address the first element of svec. (The double colon [::] indicates that iterator is a type nested within the string vector definition. This will make more sense when you read Chapter 4 and we implement our own iterator class. For now, we'll just use the iterator.) For a const vector, such as
const vector<string> cs_vec;
we traverse the elements using a const_iterator:
vector<string>::const_iterator = cs_vec.begin();
A const_iterator allows us to read the vector elements but not write to them.
To access the element through the iterator, we dereference it just as we do a built-in pointer:
cout << "string value of element: " << *iter;
Similarly, to invoke an operation of the underlying string element through iter, we use the member selection arrow syntax:
cout << "(" << iter->size() << "): " << *iter << endl;
Here is a reimplementation of display() as a function template using iterators rather than the subscript operator:
template <typename elemType> void display(const vector<elemType> &vec, ostream &os) {
vector<elemType>::const_iterator iter = vec.begin(); vector<elemType>::const_iterator end_it = vec.end();
// if vec is empty, iter and end_it are equal // and the for-loop never executes for (; iter != end_it; ++iter)
os << *iter << ' '; os << endl; }
Our reimplementation of find() supports either a pair of built-in pointers, or a pair of iterators to a container of a particular type:
63

template <typename IteratorType, typename elemType > IteratorType find(IteratorType first, IteratorType last,
const elemType &value) {
for (; first != last; ++first) if (value == *first) return first;
return last; }
Let's see how we might use this reimplementation of find() with a built-in array, a vector, and a list:
const int asize = 8; int ia[asize] = { 1, 1, 2, 3, 5, 8, 13, 21 };
// initialize the list and vector with the 8 elements of ia vector<int> ivec(ia, ia+asize); list<int> ilist(ia, ia+asize);
int *pia = find(ia, ia+asize, 1024); if (pia != ia+asize)
// found ...
vector<int>::iterator it; it = find(ivec.begin(), ivec.end(), 1024); if (it != ivec.end())
// found ...
list<int>::iterator iter; iter = find(ilist.begin(), ilist.end(), 1024); if (iter != ilist.end())
// found ...
Not bad. We've carried the generality of find() pretty far — a lot further than we imagined we could when we began the preceding section. This is not the end of the story, however, although it is pretty much the end of this section.
find()'s implementation uses the equality operator of the underlying element type. If the underlying element type does not provide an equality operator or if the user wished to define element equality differently, this instance of find() proves too inflexible. How can we add that flexibility? One solution is to replace the use of the equality operator with a function passed in as a pointer to function. A second solution is something called a function object, a special class implementation. In Chapter 4 we look at how to design a function object.
What we've accomplished in our successive iterations of find() is to evolve it into the generic find() algorithm. (find_if() provides the additional flexibility of passing in a pointer to function or function object in place of using the equality operator of the underlying element.)
There are more than 60 generic algorithms. The following represents a partial listing (the full listing and an example of using each one can be found in Appendix B).
• Search algorithms: find(), count(), adjacent_find(), find_if(), count_if(), binary_search(), and find_first_of().
64

• Sorting and general ordering algorithms: merge(), partial_sort(), partition(), random_shuffle(), reverse(), rotate(), and sort().
• Copy, deletion, and substitution algorithms: copy(), remove(), remove_if(), replace(), replace_if(), swap(), and unique().
• Relational algorithms: equal(), includes(), and mismatch(). • Generation and mutation algorithms: fill(), for_each(), generate(), and
transform(). • Numeric algorithms: accumulate(), adjacent_difference(),
partial_sum(), and inner_product(). • Set algorithms: set_union() and set_difference().
The algorithms ending with the _if suffix take either a pointer to function or a function object to determine equality. In addition, algorithms that modify the container, such as replace() and unique(), come in two versions: an in-place version that changes the original container and a version that returns a copy of the modified container. There are, for example, both a replace() and a replace_copy() algorithm.
3.3 Operations Common to All Containers
The following operations are common to all the container classes (as well as the string class):
• The equality (==) and inequality (!=) operators return true or false. • The assignment (=) operator copies one container into another. • empty() returns true if the container holds no elements. • size() returns a count of the elements currently held within the container. • clear() deletes all the elements.
The following function exercises each of these operations:
void comp(vector<int> &v1, vector<int> &v2) {
// are the two vectors equal? if (v1 == v2)
return;
// is either vector empty? if (v1.empty() || v2.empty()) return;
// no point defining it unless we are going to use it! vector<int> t;
// assign t the largest vector t = v1.size() > v2.size() ? v1 : v2;
// ... use t ...
// ok. empty t of its elements // t.empty() will now return true // t.size() will now return 0 t.clear();
// ... ok, fill up t and use it some more ... }
65

Each container supports a begin() and an end() operation to return, respectively, an iterator to the first element of the container, and 1 past the last valid element:
• begin() returns an iterator to the first element. • end() returns an iterator that addresses 1 past the last element.
Typically, we iterate across a container starting at begin() and stopping when we reach end(). All containers support an insert() operation to add elements and an erase() operation to delete elements.
• insert() adds one or a range of elements to a container. • erase() deletes one or a range of elements from a container.
The behavior of insert() and erase() vary depending on whether the container is sequential or associative. Sequential containers are discussed in the next section.
3.4 Using the Sequential Containers
A sequential container holds an ordered collection of elements of a single type. There is a first element, a second element, and so on, until the last element. The vector and the list are the two primary sequential containers. A vector holds its elements in a contiguous area of memory. Random access — for example, accessing element 5, then 17, and then 9 — is efficient; each element is a fixed offset from the beginning of the vector. Insertion of an element at any position other than the end of the vector, however, is inefficient; each element to the right of the inserted element must be shifted one by copying the value of each element in turn. Similarly, the deletion of any element other than the last element of a vector is inefficient.
A list represents noncontiguous memory double-linked to allow both forward and backward traversal. Each element of a list contains three fields: the value, a back pointer to the preceding element of the list, and a front pointer to the next element of the list. Insertion and deletion of elements at any position within the list is efficient. The list must simply set the appropriate back and front pointers. Random access, on the other hand, is less efficiently supported. To access element 5, then 17, and then 9 requires traversal of the intervening elements. (Think of the difference between a CD and a cassette tape in going from one track to another.)
To represent the elements of a numeric sequence, a vector is the more appropriate container. Why? There is a great deal of random access of the elements. fibon_elem(), for example, indexes into the container based on the position passed to it by the user. Moreover, we never delete elements, and the elements are always inserted at the end of the vector.
When is a list more appropriate? If we were reading test scores from a file and wished to store each score in ascending order, we are likely to be randomly inserting into the container with each score we read. In this case, the list container is preferred.
A third sequential container is a deque (pronouced deck). A deque behaves pretty much like a vector — the elements are stored contiguously. Unlike a vector, however, a deque supports efficient insertion and deletion of its front element (as well as its back element). If, for example, we need to insert elements at the front of the container and delete them from the back, a deque is the most appropriate container type. (The standard library queue class is implemented using a deque to hold the queue's elements.)
To use a sequential container, we must include its associated header file, one of the following:
66

#include <vector> #include <list> #include <deque>

There are five ways to define a sequential container object:

1. Create an empty container:

list<string> slist; vector<int> ivec;

2. Create a container of some size. Each element is initialized to its default value. (Recall that the default value for the built-in arithmetic types such as int and double is zero.)

list<int>

ilist(1024);

vector<string> svec(32);

3. Create a container of a given size and specify an initial value for each element:

vector<int> ivec(10, -1); list<string> slist(16, "unassigned");

4. Create a container, providing an iterator pair marking a range of elements with which to initialize the container:

int ia[8] = { 1, 1, 2, 3, 5, 8, 13, 21 }; vector<int> fib(ia, ia+8);

5. Create a container, providing a second container object. The new container is initialized by copying the second:

list<string> slist; // empty // fill slist ... list<string> slist2(slist); // copy of slist ...

Two special operations support insertion and deletion at the back of the container: push_back() and pop_back(). push_back() inserts an element at the back. pop_back() deletes the element. In addition, the list and deque containers (but not the vector) support push_front() and pop_front(). The pop_back() and pop_front() operations do not return the deleted value. To read the front value, we use front(), and to read the back value, we use back(). For example,

#include <deque> deque<int> a_line; int ival; while (cin >> ival) {
// insert ival at back of a_line a_line.push_back(ival);
// ok: read the value at front of a_line int curr_value = a_line.front();
// ... do something ...
// delete the value at front of a_line

67

a_line.pop_front(); }
push_front() and push_back() are specialized insertion operations. There are four variations of the more general insert() operation supported by each of the containers.
• iterator insert(iterator position, elemType value) inserts value before position. It returns an iterator addressing the inserted element. For example, the following inserts ival in sorted order within ilist:
list<int> ilist; // ... fill up ilist
list<int>::iterator it = ilist.begin(); while (it != ilist.end())
if (*it >= ival) {
ilist.insert(it, ival); break; // exit loop }
if (it == ilist.end()) ilist.push_back(ival);
• void insert(iterator position, int count, elemType value) inserts count elements of value before position. For example,
string sval("Part Two"); list<string> slist; // ... fill slist ...
list<string>::iterator it = find(slist.begin(), slist.end(), sval);
slist.insert(it, 8, string("dummy"));
• void insert(iterator1 position, iterator2 first, iterator2 last) inserts the range of elements marked by first, last before position:
int ia1[7] = { 1, 1, 2, 3, 5, 55, 89 }; int ia2[4] = { 8, 13, 21, 34 }; list<int> elems(ia1, ia1+7);
list<int>::iterator it = find(elems.begin(), elems.end(), 55);
elems.insert(it, ia2, ia2 + 4);
• iterator insert(iterator position) inserts an element before position. The element is initialized to the default value of its type.
pop_front() and pop_back() are specialized element erase operations. There are two versions of the more general erase() operation.
• iterator erase(iterator posit) erases the element addressed by posit. For example, using the slist defined earlier, let's erase() the first instance of str:
68

list<string>::iterator it = find(slist.begin(), slist.end(), str);
slist.erase(it);
• iterator erase(iterator first, iterator last) erases the elements starting with first up to but not including last. For example, again using the slist defined earlier, let's erase() the num_times instances of str:
list<string>::iterator first = slist.begin(), last = slist.end();
// it1: first element to erase, // it2: first element beyond elements to erase list<string>::iterator it1 = find(first, last, str); list<string>::iterator it2 = find(first, last, sval);
slist.erase(it1, it2);
The returned iterator in both instances of erase() addresses the element following the element or element range deleted.
The list class does not support offset arithmetic of its iterators. This is why we do not write
// error: offset arithmetic is not // supported for list class slist.erase(it1, it1+num_tries);
but instead provide erase() with both it1 and it2.
3.5 Using the Generic Algorithms
To use the generic algorithms, we must include the associated algorithm header file:
#include <algorithm>
Let's exercise the generic algorithms with our numeric sequence vector. is_elem() must return true if a value is an element in the sequence; otherwise, it returns false. Four possible generic search algorithms are as follows:
1. find() searches an unordered collection marked by the iterator pair first,last for some value. If the value is found, find() returns an iterator addressing the value; otherwise, it returns an iterator addressing last.
2. binary_search() searches a sorted collection. It returns true if the value is found; otherwise, it returns false. binary_search() is more efficient than find().
3. count() returns a count of the number of elements matching some value. 4. search() matches a subsequence within a container. For example, given the sequence
{1,3,5,7,2,9}, a search for the subsequence {5,7,2} returns an iterator to the beginning of the subsequence. If the subsequence is not present, an iterator to the end of the container is returned.
69

Because our vector is guaranteed to be in ascending order, our best choice is the binary_search():
#include <algorithm> bool is_elem(vector<int> &vec, int elem) {
// if the elem passed in is 34, the 9th element of // the Fibonacci sequence, but the stored sequence // only holds the first 6 elements: 1,1,2,3,5,8 // our search will not succeed. // Before we invoke binary_search(), // we must check here if we need to grow the sequence
return binary_search(vec.begin(), vec.end(), elem); }
As the comment before the invocation of binary_search() explains, we must be sure that the numeric series contains element values sufficient to include elem were it a member of the series. One way to do that is to test the largest element in the sequence against elem. If the largest element is smaller than elem, we expand the sequence until its largest element equals or exceeds elem.
One strategy for determining the largest element of the series is to use the max_element() generic algorithm. max_element() is passed an iterator pair marking the range of elements to traverse. It returns the largest element within the vector. Here is our revised is_elem():
#include <algorithm>
// forward declaration extern bool grow_vec(vector<int>&, int);
bool is_elem(vector<int> &vec, int elem) {
int max_value = max_element(vec.begin(), vec.end()); if (max_value < elem)
return grow_vec(vec, elem);
if (max_value == elem) return true;
return binary_search(vec.begin(), vec.end(), elem); }
grow_vec() adds elements to the vector until an element in the sequence is either equal to or greater than elem. If the sequence element is equal to elem, it returns true; otherwise, it returns false.
Of course, because our vector is in ascending order, we don't really need to use max_element() to find the largest element; it is guaranteed to be at position vec.size()-1 for a non-empty vector:
int max_value = vec.empty() ? 0 : vec[vec.size()-1];
binary_search() requires that the container be sorted, but it is left to the programmer to guarantee that. If we are unsure, we can copy() our container into a second container:
vector<int> temp(vec.size());
70

copy(vec.begin(), vec.end(), temp.begin());
Now we sort() our temporary container before invoking binary_search():
sort(temp.begin(), temp.end()); return binary_search(temp.begin(), temp.end(), elem);
copy() takes two iterators that mark the range of elements to copy. A third iterator points to the first element of the target container. The elements are then assigned in turn. It is our responsibility to make sure that the target container is large enough to hold each element to be copied. If we are not sure, we can use an inserter to override default assignment with insertion (see Section 3.9 for a discussion).
Appendix B provides an example of using each generic algorithm.
3.6 How to Design a Generic Algorithm
Here is our task. We are given a vector of integer values. We are asked to return a new vector holding all the values that are less than 10. A quick but inflexible solution is the following:
vector<int> less_than_10(const vector<int> &vec) {
vector<int> nvec; for (int ix = 0; ix < vec.size(); ++ix)
if (vec[ix] < 10) nvec.push_back(vec[ix]);
return nvec; }
If the user wants all the elements less than 11, we must either create a new function or generalize this one to allow the user to specify a value against which to compare the elements. For example,
vector<int> less_than(const vector<int> &vec, int less_than_val);
But our next task is actually somewhat more difficult. We must allow the user to specify an alternative operation, such as greater-than, less-than, and so on. How can we parameterize an operation?
One solution is to replace the less-than operator with a function call. We add a third parameter, pred, specifying a pointer to function having a parameter list of two integers and returning a bool. less_than() isn't the right name any longer, so let's call it filter():
vector<int> filter(const vector<int> &vec, int filter_value, bool (*pred)(int, int));
For our user's convenience, we also define a number of relational functions that can be passed to filter():
bool less_than(int v1, int v2) { return v1 < v2 ? true : false; }
bool greater_than(int v1, int v2)
71

{ return v1 > v2 ? true : false; }
and so on. The user can then either pass one or the other of these functions to an invocation of filter() or define her own relational function. The only constraint is that the function passed must return bool and accept two integers in its parameter list. Here is how filter() might be invoked:
vector<int> big_vec; int value; // ... fill big_vec and value vector<int> lt_10 = filter(big_vec, value, less_than);
The only task left for us is actually to implement filter():
vector<int> filter(const vector<int> &vec, int filter_value, bool (*pred)(int, int))
{ vector<int> nvec;
for (int ix = 0; ix < vec.size(); ++ix) // invokes the function addressed by pred // tests element vec[ix] against filter_value if (pred(vec[ix], filter_value)) nvec.push_back(vec[ix]);
return nvec; }
This implementation of filter() explicitly iterates across each element using a for loop. Let's replace the use of the for loop with the find_if() generic algorithm. We repeatedly apply find_if() to the sequence to identify each element that meets the criteria defined by the userspecified pointer to function. How might we do that?
Let's start with finding every element equal to 10. The find() generic algorithm takes three arguments: the two iterators marking the first and 1 past the last element to examine, and the value we are looking for. In the following code, count_occurs() illustrates how to apply find() repeatedly to a container without looking at any element twice:
int count_occurs(const vector<int> &vec, int val) {
vector<int>::const_iterator iter = vec.begin(); int occurs_count = 0; while ((iter = find(iter, vec.end(), val)) != vec.end()) {
++occurs_count; ++iter; // address next element } return ocurs_count; }
The while loop assigns iter the return value of find(). find() returns an iterator addressing an element equal to val or, if no matching element is found, an iterator equal to vec.end(). When iter is equal to vec.end(), the loop terminates.
72

The success of the while loop depends on our advancing iter 1 past the matching element with each iteration of the loop. For example, let's say that vec contains the following elements: {6,10,8,4,10,7,10}. The declaration statement
vector<int>::const_iterator iter = vec.begin();
initializes iter to address the first element of the vector that holds the value 6. find() returns an iterator addressing the second element. Before we reinvoke find(), we must advance iter by 1. find() is next invoked with iter addressing the third element. find() returns an iterator addressing the fifth element, and so on.
Function Objects
Before we reimplement filter() to support find_if(), let's look at the predefined function objects provided by the standard library. A function object is an instance of a class that provides an overloaded instance of the function call operator. Overloading the call operator allows a function object to be used just as if it were a function.
A function object implements what we would otherwise define as an independent function. Why do we bother? The primary reason is efficiency. We can inline the call operator, thereby eliminating the function call overhead that comes with invoking the operation through a pointer to function.
The standard library predefines a set of arithmetic, relational, and logical function objects. In the following list, type is replaced by a built-in or class type in an actual use of the function object:
• Six arithmetic function objects: plus<type>, minus<type>, negate<type>, multiplies<type>, divides<type>, modulus<type>
• Six relational function objects: less<type>, less_equal<type>, greater<type>, greater_equal<type>, equal_to<type>, not_equal_to<type>
• Three logical function objects, using the &&, ||, and ! operators, respectively: logical_and<type>, logical_or<type>, and logical_not<type>
To use the predefined function objects, we must include the associated header file:
#include <functional>
For example, by default, sort() orders its elements in ascending order using the less-than operator of the underlying element type. If we pass sort() the greater-than function object, the elements are now sorted in descending order:
sort(vec.begin(), vec.end(), greater<int>());
The syntax
greater<int>()
causes an unnamed greater class template object to be created and passed into sort().
binary_search() expects the elements it searches to be sorted by the less-than operator. For it to search our vector correctly, we must now pass it an instance of the function object used to sort our vector:
binary_search(vec.begin(), vec.end(), elem, greater<int>());
73

Let's display the Fibonacci series in a series of increasingly inpenetrable disguises: each element added to itself, each element multipled by itself, each element added to its associated Pell series element, and so on. One way to do this is by using the transform() generic algorithm and the function objects plus<int> and multiplies<int>.

transform() must be passed (1) a pair of iterators to mark the element range to transform, (2) an iterator to point to the beginning of the container from which to fetch the values to apply to the transformation, (3) an iterator to point to the beginning of the container where we are to place the result of each transformation, and (4) the function object (or pointer to function) representing the operation to apply. For example, here is our addition of the Pell elements to those of the Fibonacci:

transform(fib.begin(), fib.end(), // (1)

pell.begin(),

// (2)

fib_plus_pell.begin(), // (3)

plus<int>());

// (4)

In this example, the target vector, pell, must be at least as large as fib, or else the transform() algorithm will overflow pell.

In this next call of transform(), we multiply each element by itself and store the result by overriding the original element:

transform(fib.begin(), fib.end(), // (1)

fib.begin(), fib.begin(), // (2), (3)

multiplies<int>());

// (4)

Function Object Adapters

These function objects do not quite work with what we need to do with find_if(). The less<type> function object, for example, expects two values. It evaluates to true if the first value is less than the second. In our case, each element must be compared against the value specified by the user. Ideally, what we need to do is to turn less<type> into a unary operator by binding the second value to that specified by the user. In this way, less<type> compares each element against that value. Can we actually do that? Yes. The standard library provides an adapter mechanism to do just that.

A function object adapter modifies a function object. A binder adapter converts a binary function object into a unary object by binding one of the arguments to a particular value. This is just what we need. There are two binder adapters: bind1st, which binds the value to the first operand, and bind2nd, which binds the value to the second. Here is a possible modification of filter() using the bind2nd adapter:

vector<int> filter(const vector<int> &vec, int val, less<int> &lt)
{ vector<int> nvec; vector<int>::const_iterator iter = vec.begin();
// bind2nd(less<int>, val) // binds val to the second value of less<int> // less<int> now compares each value against val
while ((iter = find_if(iter, vec.end(), bind2nd(lt, val))) != vec.end())
{

74

// each time iter != vec.end(), // iter addresses an element less than val nvec.push_back(*iter); iter++; } return nvec; }
How might we generalize filter() further to eliminate its dependence both on the element type of the vector and on the vector container itself? To eliminate the dependency on the element type, we turn filter() into a template function and add the type to our template declaration. To eliminate the vector container dependency, we pass in a first, last iterator pair. Instead, we add another iterator to the parameter list indicating where we should begin copying the elements. Here is our reimplementation:
template <typename InputIterator, typename OutputIterator, typename ElemType, typename Comp>
OutputIterator filter(InputIterator first, InputIterator last,
OutputIterator at, const ElemType &val, Comp pred) {
while ((first = find_if(first, last, bind2nd(pred, val))) != last)
{ // just to see what is going on ... cout << "found value: " << *first << endl;
// assign value, then advance both iterators *at++ = *first++; } return at; }
Can you see how you might actually call filter()? Let's write a small program to test it using both a built-in array and a vector. We need two of each container type: one to hold the values to be filtered, and one to hold the elements that get filtered. For the moment, we define the target container to be the same size as the original container. In Section 3.9, we look at an alternative solution using insert iterator adapters.
int main() {
const int elem_size = 8;
int ia[elem_size] = { 12, 8, 43, 0, 6, 21, 3, 7 }; vector<int> ivec(ia, ia+elem_size);
// containers to hold the results of our filter() int ia2[elem_size]; vector<int> ivec2(elem_size);
cout << "filtering integer array for values less than 8\n"; filter(ia, ia+elem_size, ia2, elem_size, less<int>());
cout << "filtering integer vector for values greater than 8\n"; filter(ivec.begin(), ivec.end(), ivec2.begin(),
elem_size, greater<int>()); }
75

When compiled and executed, this program generates the following output:
filtering integer array for values less than 8 found value: 0 found value: 6 found value: 3 found value: 7
filtering integer vector for values greater than 8 found value: 12 found value: 43 found value: 21
A negator adapter reverses the truth value of a function object. not1 reverses the truth value of a unary function object. not2 reverses the truth value of a binary function object. For example, to identify the elements greater than or equal to 10, we can negate the result of the less<int>() function object:
while ((iter = find_if(iter, vec.end(), not1(bind2nd(less<int>, 10)))) != vec.end())
In general, there is no one solution to a problem. Our approach to finding all the elements less than a value, for example, involves looking at each element in turn and copying each value if it is less than the specified value. That solves our problem but is not the only approach we might have taken.
An alternative approach is the following: First, we sort the vector. Next, using find_if(), we locate the first element that is greater than the value. Finally, we delete all the elements from that found element to the end of the vector. Actually, we'll sort a local copy of the vector. Users might not appreciate our changing the element order of their vector. Here is a nontemplate version of this solution:
vector<int> sub_vec(const vector<int> &vec, int val) {
vector<int> local_vec(vec); sort(local_vec.begin(), local_vec.end());
vector<int>::iterator iter = find_if(local_vec.begin(), local_vec.end(), bind2nd(greater<int>, val));
local_vec.erase(iter, local_vec.end()); return local_vec; }
OK, whew. This is an intense section, and making sense of it might require a second reading and possibly writing some code. A good exercise is to try your hand at turning sub_vec() into a template function along the lines of filter(). Let me summarize what we've done.
We start with a function to find the elements in a vector of integers that have a value less than 10. We decide that hard-coding the value is too restrictive.
We first add a value parameter to allow the user to indicate a value against which to compare the vector elements.
76

We next add a pointer to function parameter to allow the user to indicate which comparison filter to apply.
We then introduce function objects, which provide an alternative, more efficient method of passing an operation into a function. We briefly review the built-in function objects provided by the standard library. (In Chapter 4 we look at how to write our own function objects.)
Finally, we reimplement the function as a template function. To support multiple container types, we pass an iterator pair marking the first and 1 past the last element to traverse. To support multiple element types, we parameterize the element type. To support both pointers to functions and function objects, we parameterize the comparison operation to apply to the elements.
Our function is now independent of the element type, the comparison operation, and the container. In short, we have transformed our original function into a generic algorithm.
3.7 Using a Map
A map is defined as a pair of values: a key, typically a string that serves as an index and a value associated with that key. A dictionary is one example of a map. A program analyzing the occurrence count of words in a text keeps a map with a string key and an integer value representing an occurrence count:
#include <map> #include <string> map<string,int> words;
The simplest way to enter a key/value pair is
words["vermeer"] = 1;
For our word occurrence program, we can write the following:
string tword; while (cin >> tword)
words[tword]++;
The expression
words[tword]
retrieves the value associated with the string tword contains. If tword is not present in the map, it is entered into the map with a default value of 0. The increment operator increments that value by 1.
The following for loop prints the word and its occurrence count:
map<string,int>::iterator it = words.begin(); for (; it != words.end(); ++it)
cout << "key: " << it->first << "value: " << it->second << endl;
The member named first accesses the map's key, in this case the string representing the word. The member named second accesses the value, in this case the word's occurrence count.
77

There are three ways to query a map as to whether a key is present. The obvious way is to apply the key as an index:
int count = 0; if (!(count = words[ "vermeer"]))
// vermeer not present
The disadvantage is that indexing a map inserts the key into the map if it is not already present. Its value is given the default value associated with its type. If "vermeer" is not present, for example, this form of search enters it into the map with an occurrence count of zero.
A second way to query the map is to use the find() operation associated with a map (this is not the find() generic algorithm). find() is invoked with the key value:
words.find("vermeer");
If the key value is present, find() returns an iterator to the key/value pair. Otherwise, it returns end():
int count = 0; map<string,int>::iterator it;
it = words.find("vermeer"); if (it != words.end())
count = it->second;
A third alternative is to query the map using the count() operation associated with a map. count() returns the number of occurrences of the item within the map:
int count = 0; string search_word("vermeer");
if (words.count(search_word)) // ok: present ... count = words[search_word];
A map can have only one occurrence of each key. If we need to store multiple instances of a key, we must use a multimap. (I don't discuss multimaps in this text. See [LIPPMAN98], Section 6.15, for a discussion and example of use.)
3.8 Using a Set
A set is a collection of key values. A set is used when we need to know whether a value is present. In a graph traversal algorithm, for example, we might use a set to hold each visited node. Before we move to the next node, we query the set to see whether the node has already been visited.
The word occurrence program of the preceding section, for example, may choose not to count common words. To do this, we define a word-exclusion set of type string:
#include <set> #include <string> set<string> word_exclusion;
78

Before entering a word into our map, we check whether it is present within the word_exclusion set:
while (cin >> tword) {
if (word_exclusion.count(tword)) // present in the set of excluded words? // then skip the rest of this iteration continue;
// ok: if here, not an excluded word words[tword]++; }
The continue statement causes the loop to skip the remaining statements of the current loop iteration. In this case, if tword is within the word_exclusion set, the
words[tword]++;
statement is never executed. The while loop instead begins the next loop iteration by evaluating
while (cin >> tword)
A set contains only one instance of each key value. (To store multiple key values, we must use a multiset. Again, see [LIPPMAN98], Section 6.15, for a discussion and an example of use.)
By default, the elements are ordered using the less-than operator of the underlying element type. For example, given
int ia[10] = { 1, 3, 5, 8, 5, 3, 1, 5, 8, 1 } ; vector<int> vec(ia, ia+10); set<int> iset(vec.begin(), vec.end());
the elements contained in iset are {1,3,5,8}.
Individual elements of a set are added using the single argument insert():
iset.insert(ival);
A range of elements is added using the insert() operation taking two iterators:
iset.insert(vec.begin(), vec.end());
Iteration over a set is as you might expect:
set<int>::iterator it = iset.begin(); for (; it != iset.end(); ++it)
cout << *it << ' '; cout << endl;
The generic algorithms provide a number of set algorithms: set_intersection(), set_union(), set_difference(), and set_symmetric_difference().
79

3.9 How to Use Iterator Inserters
In our implementation of filter() back in Section 3.6, we assign each element of the source container that matches the predicate test into the target container:
while ((first = find_if(first, last, bind2nd(pred, val))) != last) *at++ = *first++;
This requires that the target container be large enough to hold each assigned value. filter() has no way of knowing whether, after each increment, at continues to address a valid container slot. It is up to the programmer to ensure that the target container pointed to by at is large enough. In our test program of Section 3.6, we ensure that by defining the target container to be the same size as the source container:
int ia[elem_size] = { 12, 8, 43, 0, 6, 21, 3, 7 }; vector<int> ivec(ia, ia+elem_size);
int ia2[elem_size]; vector<int> ivec2(elem_size);
The problem with this solution is that in most cases the target container is too large. An alternative approach is to define an empty container and expand it as needed through element insertion. Unfortunately, filter() is currently implemented to assign into an existing container slot. If we reimplement filter() to do insertion, what happens to our existing programs using the assignment implementation of filter()? Moreover, what sort of insertion should we provide?
The generic algorithms that copy elements, such as copy(), copy_backwards(), remove_copy(), replace_copy(), unique_copy(), and so on, are similar in implementation to filter(). Each is passed an iterator that marks the position within a container to begin copying. With each element copy, the value is assigned and the iterator incremented. Each copy requires that we guarantee that the target container is of a sufficient size to hold the set of assigned elements. With these algorithms we don't have the option of reimplementing them.
Does this mean that we must always pass in a fixed-size container for those algorithms? That's hardly in the spirit of the STL. Rather, the standard library provides three insertion adapters. These adapters allow us to override a container's assignment operator.
• back_inserter() causes the container's push_back() operator to be invoked in place of the assignment operator. This is the preferred inserter for vectors. The argument to back_inserter is the container:
vector<int> result_vec; unique_copy(ivec.begin(), ivec.end(),
back_inserter(result_vec));
• inserter() causes the container's insert() operation to be invoked. inserter() takes two arguments: the container, and an iterator into the container indicating the position at which insertion should begin. For a vector, we would write the following:
vector<string> svec_res; unique_copy(svec.begin(), svec.end(),
80

inserter(svec_res, svec_res.end()));
• front_inserter() causes the container's push_front() operator to be invoked. This inserter can be used only with the list and deque containers:
list<int> ilist_clone;
copy(ilist.begin(), ilist.end(), front_inserter(ilist_clone));
To use these adapters, we must include the iterator header file:
#include <iterator>
These adapters, however, cannot be used with a built-in array. The built-in array provides no support for element insertion. Here is a reimplementation of the program in Section 3.6 making use of a back_inserter for the vector use of filter():
int main() {
const int elem_size = 8;
int ia[elem_size] = { 12, 8, 43, 0, 6, 21, 3, 7 }; vector<int> ivec(ia, ia+elem_size);
// built-in arrays do not support insertion ... int ia2[elem_size]; vector<int> ivec2;
cout << "filtering integer array for values less than 8\n"; filter(ia, ia+elem_size, ia2,
elem_size, less<int>());
cout << "filtering integer vector for values greater than 8\n"; filter(ivec.begin(), ivec.end(),
back_inserter(ivec2), elem_size, greater<int>()); }
filter() assigns each element in turn to the target vector — in this case, ivec2. In this example, we have not initialized ivec2 to an element size, so an assignment would result in a run-time failure. By passing in ivec2 using an inserter adapter, we turn the element assignment into an insertion. Because insertion into a vector is efficient only at the back, we choose to use a back_inserter.
3.10 Using the iostream Iterators
Imagine that we have been given the task of reading a sequence of string elements from standard input, storing them into a vector, sorting them, and then writing the words back to standard output. A typical solution looks like this:
#include <iostream> #incluse <string> #include <vector>
81

#include <algorithm> using namespace std;
int main() {
string word; vector<string> text;
// ok: let's read each word in turn until done while (cin >> word)
text.push_back(word);
// ok: sort it sort(text.begin(), text.end());
// ok: let's write them back for (int ix = 0; ix < text.size(); ++ix)
cout << text[ix] << ' '; }
The standard library defines both input and output iostream iterator classes, called istream_iterator and ostream_iterator, that provide a shorthand method of reading and writing elements of a single type. To use either iterator class, we must include the iterator header file:
#include <iterator>
For example, let's see how we can use the istream_iterator class to read our string sequence from standard input. As with all iterators, we need a first, last pair of istream_iterators that mark the range of elements. The definition
istream_iterator<string> is(cin);
provides us with a first iterator. It defines is as an istream_iterator bound to standard input that reads elements of type string. We also need a last iterator that represents 1 past the last element to be read. For standard input, end-of-file represents 1 past the last element to be read. How do we indicate that? The definition of an istream_iterator without an istream object, such as eof,
istream_iterator<string> eof;
represents end-of-file. How do we actually use this pair? In the following example, we pass them to the generic algorithm copy() together with the vector to store the string elements. Because we don't know what size to make the vector, we adapt it with a back_inserter:
copy(is, eof, back_inserter(text));
Now we need an ostream_iterator to mark where to write each string element. We stop when there are no more elements to write out. The following defines os to be an ostream_iterator tied to standard output that holds elements of type string.
ostream_iterator<string> os(cout, " ");
The second argument is either a C-style character string or a string literal that indicates the delimiter to output between the elements. By default, the elements are written without any delimiter between them. In this example, I've chosen to output each element separated by a space. Here is how we might use it:
82

copy(text.begin(), text.end(), os);
copy() writes each element stored within text to the ostream indicated by os. Each element is separated by a space. Here is the complete program:
#include <iostream> #include <iterator> #include <algorithm> #include <vector> #include <string> using namespace std;
int main() {
istream_iterator<string> is(cin); istream_iterator<string> eof;
vector<string> text; copy(is, eof, back_inserter(text));
sort(text.begin(), text.end());
ostream_iterator<string> os(cout, " "); copy(text.begin(), text.end(), os); }
Often, rather than read from standard input or write to standard output, we read from and write to a file. How can we do that? We simply bind the istream_iterator to an ifstream class object and the ostream_iterator to an ofstream class object:
#include <iostream> #include <fstream> #include <iterator> #include <algorithm> #include <vector> #include <string> using namespace std;
int main() {
ifstream in_file("as_you_like_it.txt"); ofstream out_file("as_you_like_it_sorted.txt");
if (! in_file || ! out_file) {
cerr << "!!unable to open the necessary files.\n"; return -1; }
istream_iterator<string> is(in_file); istream_iterator<string> eof;
vector<string> text; copy(is, eof, back_inserter(text));
sort(text.begin(), text.end());
ostream_iterator<string> os(out_file, " "); copy(text.begin(), text.end(), os);
83

I }
Exercise 3.1
Write a program to read a text file. Store each word in a map. The key value of the map is the count of the number of times the word appears in the text. Define a word exclusion set containing words such as a, an, or, the, and, and but. Before entering a word in the map, make sure it is not present in the word exclusion set. Display the list of words and their associated count when the reading of the text is complete. As an extension, before displaying the text, allow the user to query the text for the presence of a word.
Exercise 3.2
Read in a text file — it can be the same one as in Exercise 3.1 — storing it in a vector. Sort the vector by the length of the string. Define a function object to pass to sort(); it should accept two strings and return true if the first string is shorter than the second. Print the sorted vector.
Exercise 3.3
Define a map for which the index is the family surname and the key is a vector of the children's names. Populate the map with at least six entries. Test it by supporting user queries based on a surname and printing all the map entries.
Exercise 3.4
Write a program to read a sequence of integer numbers from standard input using an istream_iterator. Write the odd numbers into one file using an ostream_iterator. Each value should be separated by a space. Write the even numbers into a second file, also using an ostream_iterator. Each of these values should be placed on a separate line.
84

Chapter 4. Object-Based Programming
Although we've yet to write a class of our own, we've used classes extensively since Chapter 1: the string and vector classes, the iostream classes supporting input and output, and so on. In this chapter, we design and implement our own classes.
What do we know about classes from our use of them? Before we can use a class, we must make it known to the program because the class is not built into the language. Usually, we do this by including a header file:
#include <string> string pooh[4] =
{ "winnie", "robin", "eeyore", "piglet" };
The class name serves as a type name in the same way as the built-in type names such as int and double. Often, there are multiple ways to initialize an object of a class:
#include <vector>
string dummy("dummy"); vector<string> svec1(4); vector<string> svec2(4, dummy); vector<string> svec3(pooh, pooh+4);
Each class provides a set of operations we can apply to objects of the class. These operations typically consist of named functions, such as size() and empty(), and overloaded instances of the predefined operators, such as inequality and assignment:
if (svec2 != svec3 && ! svec3.empty()) svec2 = svec3;
if (svec2.size() == 4) // all is well ...
What we don't know, generally, is how the class is implemented. Does the string class calculate its size at each request, or does it store the size within each class object? Are the elements of the vector stored within the vector object, or are the elements stored elsewhere and addressed within the vector object by a pointer?
In general, a class consists of two parts: a public set of operations and operators, and a private implementation. These operations and operators are called class member functions and represent the public interface of the class. As users of a class, we can access only the public interface. This, in fact, is how we have used the string class, the vector class, and so on. For example, all we know about the size() member function of string is its prototype: It has a void parameter list and returns an integer value.
The private implementation of a class consists of the member function definitions and any data associated with the class. For example, if the string class object calculates the length of its string with each invocation of size(), no associated data is required and the definition of size() is likely to involve a for loop walking the length of the string. If the string class object stores the length of its string, a private data member must be defined within each class object. This definition of size() returns the value of that member. Each time the length of the string is modified, the data member must be updated.
85

These kinds of implementation details are usually of no concern to the user of the class. As users, we simply program to the public interface. In this way, as long as the interface does not change, our code using that interface also does not need to change, even if the underlying implementation is reengineered.
In this chapter, we turn from just using classes to providing classes for ourselves and others to use. Designing and implementing classes are the primary activities of C++ programmers.
4.1 How to Implement a Class
OK, where do we start? In general, we start with an abstraction. Consider a stack. A stack is a fundamental abstraction of computer science. It allows for the nesting and retrieval of values in a last-in, first-out sequence. We nest values by pushing a new value onto the stack, and we retrieve them by popping the last value pushed on the stack. Other operations that users often require are to ask whether a stack is full or empty and to determine the size of the stack. A stack may also support peeking at the last value pushed on the stack.
In the description of a stack I italicized the words that represent operations that users will likely want to apply to objects of our stack class.
What type of elements should we store? A general stack should store all types. We do this by defining the stack as a class template. Because class templates are the topic of Chapter 6 and we're only in Chapter 4, we'll define a nontemplate stack class to hold string class objects.
A class declaration begins with the keyword class followed by a user-specified class name:
class Stack;
This statement serves as a forward declaration of the Stack class; it introduces the class name to the compiler but provides no details of the operations it supports or the data members it contains. A forward declaration allows us to define class pointers and to use the class as a type specifier for class declarations:
// ok: these uses require a forward declaration of the class Stack *pt = 0; void process(const Stack&);
The class definition is necessary before we can define an actual Stack class object or refer to any members of the class. The skeleton of a class definition looks like this:
class Stack { public:
// ... public interface private:
// ... private implementation };
The definition of a class consists of the class declaration followed by the class body enclosed in curly braces and terminated by a semicolon. The public and private keywords within the class body control access to the members declared within each section. Public members can be accessed from anywhere within the program. Private members can be accessed only by the member functions and friends of the class — later I explain what a friend is (or at least what a friend within the C++ language is). Here is the beginning of our Stack class definition:
86

class Stack { public:
// each operation returns true if able to be carried out // pop and peek place the string value within elem bool push(const string&); bool pop(string &elem); bool peek(string &elem);
bool empty(); bool full();
// definition of size() is placed within class // other members are simply declared ... int size() { return _stack.size(); } private: vector<string> _stack; };
Our Stack class definition supports the six operations we identified at the start of this section. The elements themselves are stored in a vector of strings we've named _stack. (My coding convention is to prepend data members with an underscore.) Here is how we might define and use a Stack class object:
void fill_stack(Stack &stack, istream &is = cin) {
string str; while (is >> str && ! stack.full())
stack.push(str);
cout << "Read in " << stack.size() << " elements\n"; }
All member functions must be declared within the class definition. Optionally, a member function can also be defined inside the class definition. If defined within the body of the class, the member function is automatically treated as being inline. size(), for example, is an inline member of Stack.
To define a member function outside the class definition, we use a special declaration syntax. Its purpose is to identify the function as a member of a particular class. If the function is intended to be inline, the inline keyword must be specified:
inline bool Stack::empty() {
return _stack.empty(); }
bool Stack::pop(string &elem) {
if (empty()) return false;
elem = _stack.back(); _stack.pop_back(); return true; }
The syntax
87

Stack::empty()
tells the compiler (and reader) that we are referring to the member empty() of the Stack class — as opposed, say, to that of the vector or the string class. The name of the class followed by the double colon (Stack::) is called the class scope operator.
There is no difference in the treatment of an inline function if it is defined within or outside the class definition. As with the definition of a nonmember inline function, an inline member function should be placed in a header file. The class definition and the inline member functions are typically placed in a header file given the name of the class. For example, the Stack class definition and the definition of empty() would be placed inside a header file named Stack.h. This is what the user includes whenever he wishes to use our class.
The non-inline member functions are defined within a program text file, usually given the name of the class followed by one of the following suffixes: .C, .cc, .cpp, and .cxx (the x represents the reclining +). Microsoft Visual C++, for example, uses .cpp by default. The convention at Disney Feature Animation is to use .C. The convention at Dreamworks Animation is to use .cc.
Here are the remaining Stack member function definitions. full() compares the current size of the underlying vector with max_size(), the largest possible size of the vector. push() inserts an element provided that the _stack is not full.
inline bool Stack::full() { return _stack.size() == _stack.max_size(); }
bool Stack::peek(string &elem) {
if (empty()) return false;
elem = _stack.back(); return true; }
bool Stack::push(const string &elem) {
if (full()) return false;
_stack.push_back(elem); return true; }
Although we've provided definitions for the full set of user operations, this is not yet a complete Stack class definition. In the next section, we walk through how to provide special initialization and deinitialization functions called the class constructor and destructor.
Exercise 4.1
Create a Stack.h and a Stack.suffix, where suffix is whatever convention your compiler or project follows. Write a main() function to exercise the full public interface, and compile and execute it. Both the program text file and main() must include Stack.h:
#include "Stack.h"
Exercise 4.2
88

Extend the Stack class to support both a find() and a count() operation. find() returns true or false depending on whether the value is found. count() returns the number of occurrences of the string. Reimplement the main() of Exercise 4.1 to invoke both functions.
4.2 What Are Class Constructors and the Class Destructor?
Each of our numeric sequences is a good candidate for a class. A numeric sequence class object represents a range of elements within its associated sequence. By default, the beginning position is 1. For example,
Fibonacci fib1(7, 3);
defines a Fibonacci class object of 7 elements beginning at position 3, and
Pell pel(10);
defines a Pell class object of 10 elements beginning at the default position of 1. Finally,
Fibonacci fib2(fib1);
initializes fib2 to a copy of fib1.
Each class must keep track both of its length — how many elements of the series are represented — and of a beginning position. A 0 or negative beginning position or length is not permitted. We store both the length and the beginning position as integers. For the moment, we define a third member, _next, which keeps track of the next element to iterate over:
class Triangular { public:
// ... private:
int _length; // number of elements int _beg_pos; // beginning position of range int _next; // next element to iterate over };
The data members are stored within each Triangular class object. When I write
Triangular tri(8, 3);
tri contains an instance of _length (initialized to 8), _beg_pos (initialized to 3), and _next (initialized to 2 because the third element is indexed within the vector at position 2). Notice that it doesn't contain an instance of the actual vector holding the triangular sequence elements. Why? It's because we don't want a copy of that vector in each class object; one instance is enough for all class objects. (In Section 4.5 we look at how to support that.)
How do these data members get initialized? No, magic is not an option; the compiler does not do it for us. However, if we provide one or more special initialization functions, the compiler does invoke the appropriate instance each time a class object is defined. These special initialization functions are called constructors.
89

We identify a constructor by giving it the same name as the class.The syntactic rules are that the constructor must not specify a return type nor return a value. It can be overloaded. For example, here are three possible Triangular class constructors:
class Triangular { public:
// overloaded set of constructors Triangular(); // default constructor Triangular(int len); Triangular(int len, int beg_pos);
// ... };
A constructor is invoked automatically based on the values supplied to the class object being defined. For example,
Triangular t;
causes the default constructor to be applied to t. Similarly,
Triangular t2(10, 3);
causes the two-argument constructor to be applied. The values in parentheses are treated as the values to be passed to the constructor. Similarly,
Triangular t3 = 8;
causes the one-argument integer constructor to be applied.
Surprisingly, the following does not define a Triangular class object:
Triangular t5(); // not what it seems :-)
Rather, this defines t5 to be a function with an empty parameter list and returning a Triangular object. Obviously, this is a weird interpretation. Why is it interpreted this way? It's because C++ once needed to be compatible with the C language, and in C the parentheses following t5 in this case identify it as a function. The correct declaration of t5 is the same as t, shown earlier:
Triangular t5; // ok
The simplest constructor is the default constructor. A default constructor requires no arguments. This means one of two things. Either it takes no arguments:
Triangular::Triangular() { // default constructor
_length = 1; _beg_pos = 1; _next = 0; }
or, more commonly, it provides a default value for each parameter:
class Triangular { public:
// also a default constructor
90

Triangular(int len = 1, int bp = 1); // ... }; Triangular::Triangular(int len, int bp) {
// _length and _beg_pos both must be at least 1 // best not to trust the user to always be right _length = len > 0 ? len : 1; _beg_pos = bp > 0 ? bp : 1; _next = _beg_pos-1; }

Because we provide a default value for both integer parameters, the single default constructor instance supports the original three constructors:

Triangular tri1;

// Triangular::Triangular(1, 1);

Triangular tri2(12); // Triangular::Triangular(12, 1);

Triangular tri3(8, 3); // Triangular::Triangular(8, 3);

The Member Initialization List

A second initialization syntax within the constructor definition uses the member initialization list:

Triangular::Triangular(const Triangular &rhs) : _length (rhs._length), _beg_pos(rhs._beg_pos),_next(rhs._beg_pos-1)
{} // yes, empty!

The member initialization list is set off from the parameter list by a colon. It is a comma-separated list in which the value to be assigned the member is placed in parentheses following the member's name; it looks like a constructor call.

In this example, the two alternative constructor definitions are equivalent. There is no significant benefit in choosing one form over the other.

The member initialization list is used primarily to pass arguments to member class object constructors. For example, let's redefine the Triangular class to contain a string class member:

class Triangular { public:
// ... private:
string _name; int _next, _length, _beg_pos; };

To pass the string constructor the value with which to initialize _name, we use the member initialization list. For example,

Triangular::Triangular(int len, int bp) : _name("Triangular")
{ _length = len > 0 ? len : 1; _beg_pos = bp > 0 ? bp : 1; _next = _beg_pos-1;
}

91

