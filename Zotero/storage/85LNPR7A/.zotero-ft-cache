AAL2E_03.book Page i Thursday, February 18, 2010 12:49 PM
PRAISE FOR THE FIRST EDITION OF THE ART OF ASSEMBLY LANGUAGE
“My flat-out favorite book of 2003 was Randall Hyde’s The Art of Assembly Language.” —SOFTWARE DEVELOPER TIMES “You would be hard-pressed to find a better book on assembly out there.” —SECURITY-FORUMS.COM “This is a large book that is comprehensive and detailed. The author and publishers have done a remarkable job of packing so much in without making the explanatory text too terse. If you want to use assembly language, or add it to your list of programming skills, this is the book to have.” —BOOK NEWS (AUSTRALIA) “Allows the reader to focus on what’s really important, writing programs without hitting the proverbial brick wall that dooms many who attempt to learn assembly language to failure. . . . Topics are discussed in detail and no stone is left unturned.” —MAINE LINUX USERS GROUP-CENTRAL “The text is well authored and easy to understand. The tutorials are thoroughly explained, and the example code segments are superbly commented.” —TECHIMO “This big book is a very complete treatment [of assembly language].” —MSTATION.ORG

AAL2E_03.book Page ii Thursday, February 18, 2010 12:49 PM

AAL2E_03.book Page iii Thursday, February 18, 2010 12:49 PM
THE ART OF ASSEMBLY LANGUAGE, 2ND EDITION

AAL2E_03.book Page iv Thursday, February 18, 2010 12:49 PM

AAL2E_03.book Page v Thursday, February 18, 2010 12:49 PM
THE ART OF
ASSEMBLY L ANGUAGE
2ND EDITION
by Randall Hyde
San Francisco

aal2e_TITLE_COPY.fm Page vi Wednesday, February 24, 2010 12:52 PM

THE ART OF ASSEMBLY LANGUAGE, 2ND EDITION. Copyright © 2010 by Randall Hyde.

All rights reserved. No part of this work may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior written permission of the copyright owner and the publisher.

14 13 12 11 10 1 2 3 4 5 6 7 8 9

Printed in Canada

ISBN-10: 1-59327-207-3 ISBN-13: 978-1-59327-207-4

Publisher: William Pollock Production Editor: Riley Hoffman Cover and Interior Design: Octopod Studios Developmental Editor: William Pollock Technical Reviewer: Nathan Baker Copyeditor: Linda Recktenwald Compositor: Susan Glinert Stevens Proofreader: Nancy Bell

For information on book distributors or translations, please contact No Starch Press, Inc. directly:

No Starch Press, Inc. 555 De Haro Street, Suite 250, San Francisco, CA 94107 phone: 415.863.9900; fax: 415.863.9950; info@nostarch.com; www.nostarch.com

Library of Congress Cataloging-in-Publication Data

Hyde, Randall. The art of Assembly language / by Randall Hyde. -- 2nd ed. p. cm. ISBN 978-1-59327-207-4 (pbk.)
1. Assembler language (Computer program language) 2. Programming languages (Electronic computers) QA76.73.A8H97 2010
005.13'6--dc22 2009040777

I. Title.

No Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other product and company names mentioned herein may be the trademarks of their respective owners. Rather than use a trademark symbol with every occurrence of a trademarked name, we are using the names only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The information in this book is distributed on an “As Is” basis, without warranty. While every precaution has been taken in the preparation of this work, neither the author nor No Starch Press, Inc. shall have any liability to any person or entity with respect to any loss or damage caused or alleged to be caused directly or indirectly by the information contained in it.

AAL2E_03.book Page vii Thursday, February 18, 2010 12:49 PM
BRIEF CONTENTS
Acknowledgments .........................................................................................................xix Chapter 1: Hello, World of Assembly Language .................................................................1 Chapter 2: Data Representation ......................................................................................53 Chapter 3: Memory Access and Organization................................................................111 Chapter 4: Constants, Variables, and Data Types ...........................................................155 Chapter 5: Procedures and Units...................................................................................255 Chapter 6: Arithmetic ..................................................................................................351 Chapter 7: Low-Level Control Structures..........................................................................413 Chapter 8: Advanced Arithmetic ...................................................................................477 Chapter 9: Macros and the HLA Compile-Time Language ................................................551 Chapter 10: Bit Manipulation .......................................................................................599 Chapter 11: The String Instructions ................................................................................633 Chapter 12: Classes and Objects .................................................................................651 Appendix: ASCII Character Set.....................................................................................701 Index .........................................................................................................................705

AAL2E_03.book Page viii Thursday, February 18, 2010 12:49 PM

AAL2E_03.book Page ix Thursday, February 18, 2010 12:49 PM

CONTENTS IN DETAIL

ACKNOWLEDGMENTS

xix

1

HELLO, WORLD OF ASSEMBLY LANGUAGE

1

1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9
1.10
1.11
1.12 1.13

The Anatomy of an HLA Program...................................................................... 2 Running Your First HLA Program ....................................................................... 4 Some Basic HLA Data Declarations ................................................................... 5 Boolean Values .............................................................................................. 7 Character Values ............................................................................................ 8 An Introduction to the Intel 80x86 CPU Family ................................................... 8 The Memory Subsystem ................................................................................ 11 Some Basic Machine Instructions .................................................................... 14 Some Basic HLA Control Structures ................................................................. 17
1.9.1 Boolean Expressions in HLA Statements ......................................... 18 1.9.2 The HLA if..then..elseif..else..endif Statement ................................. 20 1.9.3 Conjunction, Disjunction, and Negation in Boolean Expressions....... 22 1.9.4 The while..endwhile Statement ..................................................... 24 1.9.5 The for..endfor Statement............................................................. 25 1.9.6 The repeat..until Statement........................................................... 26 1.9.7 The break and breakif Statements ................................................. 27 1.9.8 The forever..endfor Statement....................................................... 27 1.9.9 The try..exception..endtry Statement.............................................. 28 Introduction to the HLA Standard Library.......................................................... 32 1.10.1 Predefined Constants in the stdio Module ...................................... 33 1.10.2 Standard In and Standard Out ..................................................... 34 1.10.3 The stdout.newln Routine ............................................................. 35 1.10.4 The stdout.putiX Routines ............................................................. 35 1.10.5 The stdout.putiXSize Routines ....................................................... 35 1.10.6 The stdout.put Routine ................................................................. 37 1.10.7 The stdin.getc Routine ................................................................. 38 1.10.8 The stdin.getiX Routines............................................................... 39 1.10.9 The stdin.readLn and stdin.flushInput Routines ................................ 40 1.10.10 The stdin.get Routine ................................................................... 41 Additional Details About try..endtry................................................................. 42 1.11.1 Nesting try..endtry Statements ...................................................... 43 1.11.2 The unprotected Clause in a try..endtry Statement........................... 45 1.11.3 The anyexception Clause in a try..endtry Statement ........................ 48 1.11.4 Registers and the try..endtry Statement .......................................... 48 High-Level Assembly Language vs. Low-Level Assembly Language ....................... 50 For More Information .................................................................................... 51

AAL2E_03.book Page x Thursday, February 18, 2010 12:49 PM

2

DATA REPRESENTATION

53

2.1
2.2 2.3
2.4 2.5 2.6 2.7 2.8 2.9 2.10 2.11 2.12
2.13 2.14
2.15 2.16

Numbering Systems ...................................................................................... 54 2.1.1 A Review of the Decimal System................................................... 54 2.1.2 The Binary Numbering System ..................................................... 54 2.1.3 Binary Formats ........................................................................... 55
The Hexadecimal Numbering System .............................................................. 56 Data Organization........................................................................................ 58
2.3.1 Bits ........................................................................................... 58 2.3.2 Nibbles ..................................................................................... 59 2.3.3 Bytes......................................................................................... 60 2.3.4 Words ...................................................................................... 61 2.3.5 Double Words ........................................................................... 62 2.3.6 Quad Words and Long Words .................................................... 63 Arithmetic Operations on Binary and Hexadecimal Numbers ............................. 64 A Note About Numbers vs. Representation ...................................................... 65 Logical Operations on Bits ............................................................................. 67 Logical Operations on Binary Numbers and Bit Strings...................................... 70 Signed and Unsigned Numbers ...................................................................... 72 Sign Extension, Zero Extension, Contraction, and Saturation .............................. 76 Shifts and Rotates ......................................................................................... 80 Bit Fields and Packed Data ............................................................................ 85 An Introduction to Floating-Point Arithmetic ...................................................... 89 2.12.1 IEEE Floating-Point Formats .......................................................... 93 2.12.2 HLA Support for Floating-Point Values............................................ 96 Binary-Coded Decimal Representation ........................................................... 100 Characters ................................................................................................. 101 2.14.1 The ASCII Character Encoding ................................................... 101 2.14.2 HLA Support for ASCII Characters .............................................. 105 The Unicode Character Set .......................................................................... 109 For More Information .................................................................................. 110

3 MEMORY ACCESS AND ORGANIZATION

111

3.1 The 80x86 Addressing Modes ..................................................................... 112 3.1.1 80x86 Register Addressing Modes ............................................. 112 3.1.2 80x86 32-Bit Memory Addressing Modes ................................... 113
3.2 Runtime Memory Organization..................................................................... 119 3.2.1 The code Section ...................................................................... 120 3.2.2 The static Section...................................................................... 122 3.2.3 The readonly Data Section......................................................... 123 3.2.4 The storage Section .................................................................. 123 3.2.5 The @nostorage Attribute........................................................... 124 3.2.6 The var Section ........................................................................ 125 3.2.7 Organization of Declaration Sections Within Your Programs.......... 126
3.3 How HLA Allocates Memory for Variables ..................................................... 127 3.4 HLA Support for Data Alignment ................................................................... 128

x Contents in Detail

AAL2E_03.book Page xi Thursday, February 18, 2010 12:49 PM

3.5 3.6 3.7 3.8
3.9
3.10 3.11 3.12 3.13 3.14

Address Expressions.................................................................................... 131 Type Coercion............................................................................................ 133 Register Type Coercion................................................................................ 136 The stack Segment and the push and pop Instructions...................................... 137
3.8.1 The Basic push Instruction .......................................................... 137 3.8.2 The Basic pop Instruction ........................................................... 138 3.8.3 Preserving Registers with the push and pop Instructions ................. 140 The Stack Is a LIFO Data Structure................................................................. 140 3.9.1 Other push and pop Instructions ................................................. 143 3.9.2 Removing Data from the Stack Without Popping It ........................ 144 Accessing Data You’ve Pushed onto the Stack Without Popping It..................... 146 Dynamic Memory Allocation and the Heap Segment....................................... 147 The inc and dec Instructions ......................................................................... 152 Obtaining the Address of a Memory Object................................................... 152 For More Information .................................................................................. 153

4 CONSTANTS, VARIABLES, AND DATA TYPES

155

4.1 4.2
4.3 4.4 4.5
4.6 4.7 4.8 4.9 4.10 4.11 4.12 4.13 4.14 4.15 4.16 4.17 4.18

Some Additional Instructions: intmul, bound, into ............................................ 156 HLA Constant and Value Declarations ........................................................... 160
4.2.1 Constant Types......................................................................... 164 4.2.2 String and Character Literal Constants......................................... 165 4.2.3 String and Text Constants in the const Section .............................. 167 4.2.4 Constant Expressions ................................................................ 169 4.2.5 Multiple const Sections and Their Order in an HLA Program .......... 171 4.2.6 The HLA val Section .................................................................. 172 4.2.7 Modifying val Objects at Arbitrary Points in Your Programs ........... 173 The HLA Type Section.................................................................................. 173 enum and HLA Enumerated Data Types ......................................................... 174 Pointer Data Types ...................................................................................... 175 4.5.1 Using Pointers in Assembly Language.......................................... 177 4.5.2 Declaring Pointers in HLA .......................................................... 178 4.5.3 Pointer Constants and Pointer Constant Expressions ...................... 179 4.5.4 Pointer Variables and Dynamic Memory Allocation....................... 180 4.5.5 Common Pointer Problems ......................................................... 180 Composite Data Types................................................................................. 185 Character Strings ........................................................................................ 185 HLA Strings ................................................................................................ 188 Accessing the Characters Within a String ...................................................... 194 The HLA String Module and Other String-Related Routines...................................... 196 In-Memory Conversions ............................................................................... 208 Character Sets............................................................................................ 209 Character Set Implementation in HLA ............................................................ 210 HLA Character Set Constants and Character Set Expressions............................ 212 Character Set Support in the HLA Standard Library ......................................... 213 Using Character Sets in Your HLA Programs................................................... 217 Arrays ....................................................................................................... 218 Declaring Arrays in Your HLA Programs ........................................................ 219

Co nt en ts i n D et ail xi

AAL2E_03.book Page xii Thursday, February 18, 2010 12:49 PM

4.19 4.20 4.21 4.22
4.23 4.24 4.25 4.26 4.27 4.28 4.29 4.30 4.31 4.32 4.33 4.34 4.35 4.36

HLA Array Constants ................................................................................... 220 Accessing Elements of a Single-Dimensional Array .......................................... 221 Sorting an Array of Values........................................................................... 222 Multidimensional Arrays .............................................................................. 224
4.22.1 Row-Major Ordering................................................................. 225 4.22.2 Column-Major Ordering ............................................................ 228 Allocating Storage for Multidimensional Arrays .............................................. 229 Accessing Multidimensional Array Elements in Assembly Language................... 231 Records ..................................................................................................... 233 Record Constants ........................................................................................ 235 Arrays of Records ....................................................................................... 236 Arrays/Records as Record Fields .................................................................. 237 Aligning Fields Within a Record ................................................................... 241 Pointers to Records...................................................................................... 242 Unions....................................................................................................... 243 Anonymous Unions ..................................................................................... 246 Variant Types ............................................................................................. 247 Namespaces .............................................................................................. 248 Dynamic Arrays in Assembly Language ......................................................... 251 For More Information .................................................................................. 254

5 PROCEDURES AND UNITS

255

5.1 5.2 5.3 5.4 5.5 5.6
5.7
5.8 5.9 5.10 5.11 5.12 5.13 5.14 5.15 5.16 5.17

Procedures ................................................................................................. 255 Saving the State of the Machine ................................................................... 258 Prematurely Returning from a Procedure ........................................................ 262 Local Variables........................................................................................... 262 Other Local and Global Symbol Types .......................................................... 268 Parameters................................................................................................. 268
5.6.1 Pass by Value .......................................................................... 269 5.6.2 Pass by Reference..................................................................... 273 Functions and Function Results ...................................................................... 275 5.7.1 Returning Function Results .......................................................... 276 5.7.2 Instruction Composition in HLA ................................................... 277 5.7.3 The HLA @returns Option in Procedures....................................... 280 Recursion................................................................................................... 282 Forward Procedures .................................................................................... 286 HLA v2.0 Procedure Declarations ................................................................. 287 Low-Level Procedures and the call Instruction .................................................. 288 Procedures and the Stack............................................................................. 290 Activation Records ...................................................................................... 293 The Standard Entry Sequence ....................................................................... 296 The Standard Exit Sequence......................................................................... 298 Low-Level Implementation of Automatic (Local) Variables.................................. 299 Low-Level Parameter Implementation.............................................................. 301 5.17.1 Passing Parameters in Registers .................................................. 301 5.17.2 Passing Parameters in the Code Stream....................................... 304 5.17.3 Passing Parameters on the Stack................................................. 307

xii Con te nts in D et ai l

AAL2E_03.book Page xiii Thursday, February 18, 2010 12:49 PM

5.18 5.19 5.20 5.21 5.22 5.23 5.24
5.25 5.26

Procedure Pointers ...................................................................................... 329 Procedural Parameters................................................................................. 333 Untyped Reference Parameters ..................................................................... 334 Managing Large Programs........................................................................... 335 The #include Directive ................................................................................. 336 Ignoring Duplicate #include Operations ........................................................ 337 Units and the external Directive .................................................................... 338
5.24.1 Behavior of the external Directive ............................................... 343 5.24.2 Header Files in HLA .................................................................. 344 Namespace Pollution .................................................................................. 345 For More Information .................................................................................. 348

6 ARITHMETIC

351

6.1 80x86 Integer Arithmetic Instructions............................................................. 351 6.1.1 The mul and imul Instructions...................................................... 352 6.1.2 The div and idiv Instructions ....................................................... 355 6.1.3 The cmp Instruction ................................................................... 357 6.1.4 The setcc Instructions ................................................................. 362 6.1.5 The test Instruction..................................................................... 364
6.2 Arithmetic Expressions ................................................................................. 365 6.2.1 Simple Assignments .................................................................. 366 6.2.2 Simple Expressions ................................................................... 366 6.2.3 Complex Expressions ................................................................ 369 6.2.4 Commutative Operators ............................................................ 374
6.3 Logical (Boolean) Expressions....................................................................... 375 6.4 Machine and Arithmetic Idioms .................................................................... 377
6.4.1 Multiplying without mul, imul, or intmul........................................ 378 6.4.2 Division Without div or idiv........................................................ 379 6.4.3 Implementing Modulo-N Counters with and ................................. 380 6.5 Floating-Point Arithmetic .............................................................................. 380 6.5.1 FPU Registers ........................................................................... 380 6.5.2 FPU Data Types ........................................................................ 387 6.5.3 The FPU Instruction Set .............................................................. 389 6.5.4 FPU Data Movement Instructions ................................................. 389 6.5.5 Conversions ............................................................................. 391 6.5.6 Arithmetic Instructions................................................................ 394 6.5.7 Comparison Instructions............................................................. 399 6.5.8 Constant Instructions ................................................................ 402 6.5.9 Transcendental Instructions......................................................... 402 6.5.10 Miscellaneous Instructions .......................................................... 404 6.5.11 Integer Operations.................................................................... 405 6.6 Converting Floating-Point Expressions to Assembly Language ........................... 406 6.6.1 Converting Arithmetic Expressions to Postfix Notation ................... 407 6.6.2 Converting Postfix Notation to Assembly Language....................... 409 6.7 HLA Standard Library Support for Floating-Point Arithmetic .............................. 411 6.8 For More Information .................................................................................. 411

Contents in De tail xiii

AAL2E_03.book Page xiv Thursday, February 18, 2010 12:49 PM

7 LOW-LEVEL CONTROL STRUCTURES

413

7.1 7.2 7.3 7.4 7.5 7.6 7.7
7.8 7.9 7.10
7.11
7.12 7.13

Low-Level Control Structures.......................................................................... 414 Statement Labels ......................................................................................... 414 Unconditional Transfer of Control (jmp) ......................................................... 416 The Conditional Jump Instructions.................................................................. 418 “Medium-Level” Control Structures: jt and jf.................................................... 421 Implementing Common Control Structures in Assembly Language...................... 422 Introduction to Decisions .............................................................................. 422
7.7.1 if..then..else Sequences ............................................................. 424 7.7.2 Translating HLA if Statements into Pure Assembly Language ........... 427 7.7.3 Implementing Complex if Statements Using
Complete Boolean Evaluation .......................................... 432 7.7.4 Short-Circuit Boolean Evaluation ................................................. 433 7.7.5 Short-Circuit vs. Complete Boolean Evaluation.............................. 435 7.7.6 Efficient Implementation of if Statements in Assembly Language...... 437 7.7.7 switch/case Statements ............................................................. 442 State Machines and Indirect Jumps................................................................ 452 Spaghetti Code .......................................................................................... 455 Loops ........................................................................................................ 456 7.10.1 while Loops.............................................................................. 457 7.10.2 repeat..until Loops .................................................................... 458 7.10.3 forever..endfor Loops ................................................................ 459 7.10.4 for Loops ................................................................................. 460 7.10.5 The break and continue Statements ............................................. 461 7.10.6 Register Usage and Loops.......................................................... 465 Performance Improvements .......................................................................... 466 7.11.1 Moving the Termination Condition to the End of a Loop................. 466 7.11.2 Executing the Loop Backwards ................................................... 469 7.11.3 Loop-Invariant Computations ...................................................... 470 7.11.4 Unraveling Loops...................................................................... 471 7.11.5 Induction Variables ................................................................... 472 Hybrid Control Structures in HLA................................................................... 473 For More Information .................................................................................. 476

8 ADVANCED ARITHMETIC

477

8.1 Multiprecision Operations............................................................................ 478 8.1.1 HLA Standard Library Support for Extended-Precision Operations ... 478 8.1.2 Multiprecision Addition Operations............................................. 480 8.1.3 Multiprecision Subtraction Operations......................................... 483 8.1.4 Extended-Precision Comparisons ................................................ 485 8.1.5 Extended-Precision Multiplication ................................................ 488 8.1.6 Extended-Precision Division........................................................ 492 8.1.7 Extended-Precision neg Operations ............................................. 501 8.1.8 Extended-Precision and Operations............................................. 503 8.1.9 Extended-Precision or Operations ............................................... 503

xiv Con te nt s i n De tai l

AAL2E_03.book Page xv Thursday, February 18, 2010 12:49 PM

8.1.10 Extended-Precision xor Operations.............................................. 504 8.1.11 Extended-Precision not Operations.............................................. 504 8.1.12 Extended-Precision Shift Operations ............................................ 504 8.1.13 Extended-Precision Rotate Operations ......................................... 508 8.1.14 Extended-Precision I/O ............................................................. 509 8.2 Operating on Different-Size Operands .......................................................... 530 8.3 Decimal Arithmetic...................................................................................... 532 8.3.1 Literal BCD Constants................................................................ 533 8.3.2 The 80x86 daa and das Instructions ........................................... 534 8.3.3 The 80x86 aaa, aas, aam, and aad Instructions .......................... 535 8.3.4 Packed Decimal Arithmetic Using the FPU .................................... 537 8.4 Tables ....................................................................................................... 539 8.4.1 Function Computation via Table Lookup....................................... 539 8.4.2 Domain Conditioning ................................................................ 544 8.4.3 Generating Tables .................................................................... 545 8.4.4 Table Lookup Performance ......................................................... 548 8.5 For More Information .................................................................................. 549

9 MACROS AND THE HLA COMPILE-TIME LANGUAGE

551

9.1 9.2 9.3 9.4 9.5
9.6 9.7 9.8
9.9
9.10 9.11

Introduction to the Compile-Time Language (CTL) ............................................ 551 The #print and #error Statements .................................................................. 553 Compile-Time Constants and Variables .......................................................... 555 Compile-Time Expressions and Operators ...................................................... 555 Compile-Time Functions ............................................................................... 558
9.5.1 Type-Conversion Compile-Time Functions ..................................... 559 9.5.2 Numeric Compile-Time Functions ................................................ 561 9.5.3 Character-Classification Compile-Time Functions........................... 561 9.5.4 Compile-Time String Functions .................................................... 561 9.5.5 Compile-Time Symbol Information............................................... 562 9.5.6 Miscellaneous Compile-Time Functions ........................................ 563 9.5.7 Compile-Time Type Conversions of Text Objects ........................... 564 Conditional Compilation (Compile-Time Decisions).......................................... 565 Repetitive Compilation (Compile-Time Loops).................................................. 570 Macros (Compile-Time Procedures) ............................................................... 573 9.8.1 Standard Macros...................................................................... 574 9.8.2 Macro Parameters .................................................................... 576 9.8.3 Local Symbols in a Macro ......................................................... 582 9.8.4 Macros as Compile-Time Procedures ........................................... 585 9.8.5 Simulating Function Overloading with Macros.............................. 586 Writing Compile-Time “Programs” ................................................................ 592 9.9.1 Constructing Data Tables at Compile Time ................................... 592 9.9.2 Unrolling Loops ........................................................................ 596 Using Macros in Different Source Files........................................................... 598 For More Information .................................................................................. 598

Co nt en ts i n De tai l xv

AAL2E_03.book Page xvi Thursday, February 18, 2010 12:49 PM

10 BIT MANIPULATION

599

10.1 What Is Bit Data, Anyway? .......................................................................... 600 10.2 Instructions That Manipulate Bits ................................................................... 601 10.3 The Carry Flag as a Bit Accumulator ............................................................. 609 10.4 Packing and Unpacking Bit Strings................................................................ 609 10.5 Coalescing Bit Sets and Distributing Bit Strings ............................................... 612 10.6 Packed Arrays of Bit Strings ......................................................................... 615 10.7 Searching for a Bit ...................................................................................... 617 10.8 Counting Bits.............................................................................................. 620 10.9 Reversing a Bit String .................................................................................. 623 10.10 Merging Bit Strings ..................................................................................... 625 10.11 Extracting Bit Strings ................................................................................... 626 10.12 Searching for a Bit Pattern ........................................................................... 627 10.13 The HLA Standard Library Bits Module........................................................... 628 10.14 For More Information .................................................................................. 631

11 THE STRING INSTRUCTIONS

633

11.1
11.2 11.3

The 80x86 String Instructions ....................................................................... 634 11.1.1 How the String Instructions Operate ............................................ 634 11.1.2 The rep/repe/repz and repnz/repne Prefixes .............................. 635 11.1.3 The Direction Flag..................................................................... 636 11.1.4 The movs Instruction .................................................................. 638 11.1.5 The cmps Instruction .................................................................. 644 11.1.6 The scas Instruction ................................................................... 647 11.1.7 The stos Instruction .................................................................... 648 11.1.8 The lods Instruction ................................................................... 648 11.1.9 Building Complex String Functions from lods and stos ................... 649
Performance of the 80x86 String Instructions.................................................. 650 For More Information .................................................................................. 650

xvi Con te nt s i n De tai l

AAL2E_03.book Page xvii Thursday, February 18, 2010 12:49 PM

12 CLASSES AND OBJECTS

651

12.1 General Principles....................................................................................... 652 12.2 Classes in HLA ........................................................................................... 654 12.3 Objects ..................................................................................................... 657 12.4 Inheritance................................................................................................. 659 12.5 Overriding ................................................................................................. 660 12.6 Virtual Methods vs. Static Procedures ............................................................ 661 12.7 Writing Class Methods and Procedures ......................................................... 663 12.8 Object Implementation ................................................................................ 668
12.8.1 Virtual Method Tables ............................................................... 671 12.8.2 Object Representation with Inheritance........................................ 673 12.9 Constructors and Object Initialization............................................................ 677 12.9.1 Dynamic Object Allocation Within the Constructor ....................... 679 12.9.2 Constructors and Inheritance ..................................................... 681 12.9.3 Constructor Parameters and Procedure Overloading ..................... 685 12.10 Destructors ................................................................................................. 686 12.11 HLA’s _initialize_ and _finalize_ Strings......................................................... 687 12.12 Abstract Methods........................................................................................ 693 12.13 Runtime Type Information............................................................................. 696 12.14 Calling Base Class Methods......................................................................... 698 12.15 For More Information .................................................................................. 699

APPENDIX ASCII CHARACTER SET

701

INDEX

705

Contents in De tail xvii

AAL2E_03.book Page xviii Thursday, February 18, 2010 12:49 PM

AAL2E_03.book Page xix Thursday, February 18, 2010 12:49 PM
ACKNOWLEDGMENTS
First Edition This book has literally taken over a decade to create. It started out as “How to Program the IBM PC, Using 8088 Assembly Language” way back in 1989. I originally wrote this book for the students in my assembly language course at Cal Poly Pomona and UC Riverside. Over the years, hundreds of students have made small and large contributions (it’s amazing how a little extra credit can motivate some students). I've also received thousands of comments via the Internet after placing an early, 16-bit edition of this book on my website at UC Riverside. I owe everyone who has contributed to this effort my gratitude.
I would also like to specifically thank Mary Phillips, who spent several months helping me proofread much of the 16-bit edition upon which I’ve based this book. Mary is a wonderful person and a great friend.
I also owe a deep debt of gratitude to William Pollock at No Starch Press, who rescued this book from obscurity. He is the one responsible for convincing me to spend some time beating on this book to create a publishable entity from it. I would also like to thank Karol Jurado for shepherding this project from its inception—it’s been a long, hard road. Thanks, Karol. Second Edition I would like to thank the many thousands of readers who’ve made the first edition of The Art of Assembly Language so successful. Your comments, suggestions, and corrections have been a big help in the creation of this

AAL2E_03.book Page xx Thursday, February 18, 2010 12:49 PM
second edition. Thank you for purchasing this book and keeping assembly language alive and well.
When I first began work on this second edition, my original plan was to make the necessary changes and get the book out as quickly as possible. However, the kind folks at No Starch Press have spent countless hours improving the readability, consistency, and accuracy of this book. The second edition you hold in your hands is a huge improvement over the first edition and a large part of the credit belongs to No Starch. In particular, the following No Starch personnel are responsible for improving this book: Bill Pollock, Alison Peterson, Ansel Staton, Riley Hoffman, Megan Dunchak, Linda Recktenwald, Susan Glinert Stevens, and Nancy Bell. Special thanks goes out to Nathan Baker who was the technical reader for this book; you did a great job, Nate.
I’d also like to thank Sevag Krikorian, who developed the HIDE integrated development environment for HLA and has tirelessly promoted the HLA language, as well as all the contributors to the Yahoo AoAProgramming group; you’ve all provided great support for this book.
As I didn't mention her in the acknowledgments to the first edition, let me dedicate this book to my wife Mandy. It’s been a great 30 years and I’m looking forward to another 30. Thanks for giving me the time to work on this project.
xx Ack nowledg ments

AAL2E_03.book Page 1 Thursday, February 18, 2010 12:49 PM
1
HELLO, WORLD OF ASSEMBLY LANGUAGE
This chapter is a “quick-start” chapter that lets you start writing basic assembly language programs as rapidly as possible. This chapter does the following:
z Presents the basic syntax of an HLA (High Level Assembly) program z Introduces you to the Intel CPU architecture z Provides a handful of data declarations, machine instructions, and high-
level control statements z Describes some utility routines you can call in the HLA Standard Library z Shows you how to write some simple assembly language programs
By the conclusion of this chapter, you should understand the basic syntax of an HLA program and should understand the prerequisites that are needed to start learning new assembly language features in the chapters that follow.

AAL2E_03.book Page 2 Thursday, February 18, 2010 12:49 PM

1.1 The Anatomy of an HLA Program

A typical HLA program takes the form shown in Figure 1-1.

These identifiers specify the name of the program. They must all be the same identifier.

program pgmID ; << Declarations >>
begin pgmID ; << Statements >>
end pgmID ;

The Declarations section is where you declare constants, types, variables, procedures, and other objects in an HLA program.
The Statements section is where you place the executable statements for your main program.

program, begin, and end are HLA reserved words that delineate the program. Note the placement of the semicolons in this program.
Figure 1-1: Basic HLA program
pgmID in the template above is a user-defined program identifier. You must pick an appropriate descriptive name for your program. In particular, pgmID would be a horrible choice for any real program. If you are writing programs as part of a course assignment, your instructor will probably give you the name to use for your main program. If you are writing your own HLA program, you will have to choose an appropriate name for your project.
Identifiers in HLA are very similar to identifiers in most high-level languages. HLA identifiers may begin with an underscore or an alphabetic character and may be followed by zero or more alphanumeric or underscore characters. HLA’s identifiers are case neutral. This means that the identifiers are case sensitive insofar as you must always spell an identifier exactly the same way in your program (even with respect to upper- and lowercase). However, unlike in case-sensitive languages such as C/C++, you may not declare two identifiers in the program whose name differs only by alphabetic case.
A traditional first program people write, popularized by Kernighan and Ritchie’s The C Programming Language, is the “Hello, world!” program. This program makes an excellent concrete example for someone who is learning a new language. Listing 1-1 presents the HLA helloWorld program.

program helloWorld; #include( "stdlib.hhf" ); begin helloWorld;
stdout.put( "Hello, World of Assembly Language", nl ); end helloWorld; Listing 1-1: The helloWorld program

2 Chapter 1

AAL2E_03.book Page 3 Thursday, February 18, 2010 12:49 PM
The #include statement in this program tells the HLA compiler to include a set of declarations from the stdlib.hhf (standard library, HLA Header File). Among other things, this file contains the declaration of the stdout.put code that this program uses.
The stdout.put statement is the print statement for the HLA language. You use it to write data to the standard output device (generally the console). To anyone familiar with I/O statements in a high-level language, it should be obvious that this statement prints the phrase Hello, World of Assembly Language. The nl appearing at the end of this statement is a constant, also defined in stdlib.hhf, that corresponds to the newline sequence.
Note that semicolons follow the program, begin, stdout.put, and end statements. Technically speaking, a semicolon does not follow the #include statement. It is possible to create include files that generate an error if a semicolon follows the #include statement, so you may want to get in the habit of not putting a semicolon here.
The #include is your first introduction to HLA declarations. The #include itself isn’t actually a declaration, but it does tell the HLA compiler to substitute the file stdlib.hhf in place of the #include directive, thus inserting several declarations at this point in your program. Most HLA programs you will write will need to include one or more of the HLA Standard Library header files (stdlib.hhf actually includes all the standard library definitions into your program).
Compiling this program produces a console application. Running this program in a command window prints the specified string, and then control returns to the command-line interpreter (or shell in Unix terminology).
HLA is a free-format language. Therefore, you may split statements across multiple lines if this helps to make your programs more readable. For example, you could write the stdout.put statement in the helloWorld program as follows:
stdout.put (
"Hello, World of Assembly Language", nl );
Another construction you’ll see appearing in example code throughout this text is that HLA automatically concatenates any adjacent string constants it finds in your source file. Therefore, the statement above is also equivalent to
stdout.put (
"Hello, " "World of Assembly Language", nl );
Hello, World of Assembly Language 3

AAL2E_03.book Page 4 Thursday, February 18, 2010 12:49 PM

Indeed, nl (the newline) is really nothing more than a string constant, so (technically) the comma between the nl and the preceding string isn’t necessary. You’ll often see the above written as
stdout.put( "Hello, World of Assembly Language" nl );
Notice the lack of a comma between the string constant and nl; this turns out to be legal in HLA, though it applies only to certain constants; you may not, in general, drop the comma. Chapter 4 explains in detail how this works. This discussion appears here because you’ll probably see this “trick” employed by sample code prior to the formal explanation.

1.2 Running Your First HLA Program

The whole purpose of the “Hello, world!” program is to provide a simple example by which someone who is learning a new programming language can figure out how to use the tools needed to compile and run programs in that language. True, the helloWorld program in Section 1.1 helps demonstrate the format and syntax of a simple HLA program, but the real purpose behind a program like helloWorld is to learn how to create and run a program from beginning to end. Although the previous section presents the layout of an HLA program, it did not discuss how to edit, compile, and run that program. This section will briefly cover those details.
All of the software you need to compile and run HLA programs can be found at http://www.artofasm.com/ or at http://webster.cs.ucr.edu/. Select High Level Assembly from the Quick Navigation Panel and then the Download HLA link from that page. HLA is currently available for Windows, Mac OS X, Linux, and FreeBSD. Download the appropriate version of the HLA software for your system. From the Download HLA web page, you will also be able to download all the software associated with this book. If the HLA download doesn’t include them, you will probably want to download the HLA reference manual and the HLA Standard Library reference manual along with HLA and the software for this book. This text does not describe the entire HLA language, nor does it describe the entire HLA Standard Library. You’ll want to have these reference manuals handy as you learn assembly language using HLA.
This section will not describe how to install and set up the HLA system because those instructions change over time. The HLA download page for each of the operating systems describes how to install and use HLA. Please consult those instructions for the exact installation procedure.
Creating, compiling, and running an HLA program is very similar to the process you’d use when creating, compiling, or running a program in any computer language. First, because HLA is not an integrated development environment (IDE) that allows you to edit, compile, test and debug, and run your application all from within the same program, you’ll create and edit HLA programs using a text editor.1

4 Chapter 1

1 HIDE (HLA Integrated Development Environment) is an IDE available for Windows users. See the High Level Assembly web page for details on downloading HIDE.

AAL2E_03.book Page 5 Thursday, February 18, 2010 12:49 PM
Windows, Mac OS X, Linux, and FreeBSD offer many text editor options. You can even use the text editor provided with other IDEs to create and edit HLA programs (such as those found in Visual C++, Borland’s Delphi, Apple’s Xcode, and similar languages). The only restriction is that HLA expects ASCII text files, so the editor you use must be capable of manipulating and saving text files. Under Windows you can always use Notepad to create HLA programs. If you’re working under Linux and FreeBSD you can use joe, vi, or emacs. Under Mac OS X you can use XCode or Text Wrangler or another editor of your preference.
The HLA compiler2 is a traditional command-line compiler, which means that you need to run it from a Windows command-line prompt or a Linux/ FreeBSD/Mac OS X shell. To do so, enter something like the following into the command-line prompt or shell window:
hla hw.hla
This command tells HLA to compile the hw.hla (helloWorld) program to an executable file. Assuming there are no errors, you can run the resulting program by typing the following command into your command prompt window (Windows):
hw
or into the shell interpreter window (Linux/FreeBSD/Mac OS X):
./hw
If you’re having problems getting the program to compile and run properly, please see the HLA installation instructions on the HLA download page. These instructions describe in great detail how to install, set up, and use HLA.
1.3 Some Basic HLA Data Declarations
HLA provides a wide variety of constant, type, and data declaration statements. Later chapters will cover the declaration sections in more detail, but it’s important to know how to declare a few simple variables in an HLA program.
HLA predefines several different signed integer types including int8, int16, and int32, corresponding to 8-bit (1-byte) signed integers, 16-bit (2-byte) signed integers, and 32-bit (4-byte) signed integers, respectively.3 Typical variable declarations occur in the HLA static variable section. A typical set of variable declarations takes the form shown in Figure 1-2.
2 Traditionally, programmers have always called translators for assembly languages assemblers rather than compilers. However, because of HLA’s high-level features, it is more proper to call HLA a compiler rather than an assembler. 3 A discussion of bits and bytes will appear in Chapter 2 for those who are unfamiliar with these terms.
Hello, World of Assembly Language 5

AAL2E_03.book Page 6 Thursday, February 18, 2010 12:49 PM

i8, i16, and i32 are the names of the variables to declare here.

static i8: int8; i16: int16; i32: int32;

Figure 1-2: Static variable declarations

static is the keyword that begins the variable declaration section.
int8, int16, and int32 are the names of the data types for each declaration.

Those who are familiar with the Pascal language should be comfortable with this declaration syntax. This example demonstrates how to declare three separate integers: i8, i16, and i32. Of course, in a real program you should use variable names that are more descriptive. While names like i8 and i32 describe the type of the object, they do not describe its purpose. Variable names should describe the purpose of the object.
In the static declaration section, you can also give a variable an initial value that the operating system will assign to the variable when it loads the program into memory. Figure 1-3 provides the syntax for this.

The constant assignment operator, :=, tells HLA that you wish to initialize the specified variable with an initial value.

static i8: int8 := 8; i16: int16 := 1600; i32: int32 := -320000;

Figure 1-3: Static variable initialization

The operand after the constant assignment operator must be a constant whose type is compatible with the variable you are initializing.

It is important to realize that the expression following the assignment operator (:=) must be a constant expression. You cannot assign the values of other variables within a static variable declaration.
Those familiar with other high-level languages (especially Pascal) should note that you can declare only one variable per statement. That is, HLA does not allow a comma-delimited list of variable names followed by a colon and a type identifier. Each variable declaration consists of a single identifier, a colon, a type ID, and a semicolon.
Listing 1-2 provides a simple HLA program that demonstrates the use of variables within an HLA program.

Program DemoVars; #include( "stdlib.hhf" )

static

InitDemo:

int32 := 5;

NotInitialized: int32;

begin DemoVars;

// Display the value of the pre-initialized variable:

stdout.put( "InitDemo's value is ", InitDemo, nl );

// Input an integer value from the user and display that value:

6 Chapter 1

AAL2E_03.book Page 7 Thursday, February 18, 2010 12:49 PM

stdout.put( "Enter an integer value: " ); stdin.get( NotInitialized ); stdout.put( "You entered: ", NotInitialized, nl );
end DemoVars;
Listing 1-2: Variable declaration and use
In addition to static variable declarations, this example introduces three new concepts. First, the stdout.put statement allows multiple parameters. If you specify an integer value, stdout.put will convert that value to its string representation on output.
The second new feature introduced in Listing 1-2 is the stdin.get statement. This statement reads a value from the standard input device (usually the keyboard), converts the value to an integer, and stores the integer value into the NotInitialized variable. Finally, Listing 1-2 also introduces the syntax for (one form of) HLA comments. The HLA compiler ignores all text from the // sequence to the end of the current line. (Those familiar with Java, C++, and Delphi should recognize these comments.)

1.4 Boolean Values
HLA and the HLA Standard Library provide limited support for boolean objects. You can declare boolean variables, use boolean literal constants, use boolean variables in boolean expressions, and you can print the values of boolean variables.
Boolean literal constants consist of the two predefined identifiers true and false. Internally, HLA represents the value true using the numeric value 1; HLA represents false using the value 0. Most programs treat 0 as false and anything else as true, so HLA’s representations for true and false should prove sufficient.
To declare a boolean variable, you use the boolean data type. HLA uses a single byte (the least amount of memory it can allocate) to represent boolean values. The following example demonstrates some typical declarations:

static BoolVar: HasClass: IsClear:

boolean; boolean := false; boolean := true;

As this example demonstrates, you can initialize boolean variables if you desire.
Because boolean variables are byte objects, you can manipulate them using any instructions that operate directly on 8-bit values. Furthermore, as long as you ensure that your boolean variables only contain 0 and 1 (for false and true, respectively), you can use the 80x86 and, or, xor, and not instructions to manipulate these boolean values (these instructions are covered in Chapter 2).

Hello, World of Assembly Language 7

AAL2E_03.book Page 8 Thursday, February 18, 2010 12:49 PM
You can print boolean values by making a call to the stdout.put routine. For example:
stdout.put( BoolVar )
This routine prints the text true or false depending upon the value of the boolean parameter (0 is false; anything else is true). Note that the HLA Standard Library does not allow you to read boolean values via stdin.get.
1.5 Character Values
HLA lets you declare 1-byte ASCII character objects using the char data type. You may initialize character variables with a literal character value by surrounding the character with a pair of apostrophes. The following example demonstrates how to declare and initialize character variables in HLA:
static c: char; LetterA: char := 'A';
You can print character variables use the stdout.put routine, and you can read character variables using the stdin.get procedure call.
1.6 An Introduction to the Intel 80x86 CPU Family
Thus far, you’ve seen a couple of HLA programs that will actually compile and run. However, all the statements appearing in programs to this point have been either data declarations or calls to HLA Standard Library routines. There hasn’t been any real assembly language. Before we can progress any further and learn some real assembly language, a detour is necessary; unless you understand the basic structure of the Intel 80x86 CPU family, the machine instructions will make little sense.
The Intel CPU family is generally classified as a Von Neumann Architecture Machine. Von Neumann computer systems contain three main building blocks: the central processing unit (CPU), memory, and input/output (I/0) devices. These three components are interconnected using the system bus (consisting of the address, data, and control buses). The block diagram in Figure 1-4 shows this relationship.
The CPU communicates with memory and I/O devices by placing a numeric value on the address bus to select one of the memory locations or I/O device port locations, each of which has a unique binary numeric address. Then the CPU, memory, and I/O devices pass data among themselves by placing the data on the data bus. The control bus contains signals that determine the direction of the data transfer (to/from memory and to/from an I/O device).
8 Chapter 1

AAL2E_03.book Page 9 Thursday, February 18, 2010 12:49 PM
CPU

Memory

I/O Devices
Figure 1-4: Von Neumann computer system block diagram
The 80x86 CPU registers can be broken down into four categories: general-purpose registers, special-purpose application-accessible registers, segment registers, and special-purpose kernel-mode registers. Because the segment registers aren’t used much in modern 32-bit operating systems (such as Windows, Mac OS X, FreeBSD, and Linux) and because this text is geared to writing programs written for 32-bit operating systems, there is little need to discuss the segment registers. The special-purpose kernel-mode registers are intended for writing operating systems, debuggers, and other systemlevel tools. Such software construction is well beyond the scope of this text.
The 80x86 (Intel family) CPUs provide several general-purpose registers for application use. These include eight 32-bit registers that have the following names: EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.
The E prefix on each name stands for extended. This prefix differentiates the 32-bit registers from the eight 16-bit registers that have the following names: AX, BX, CX, DX, SI, DI, BP, and SP.
Finally, the 80x86 CPUs provide eight 8-bit registers that have the following names: AL, AH, BL, BH, CL, CH, DL, and DH.
Unfortunately, these are not all separate registers. That is, the 80x86 does not provide 24 independent registers. Instead, the 80x86 overlays the 32-bit registers with the 16-bit registers, and it overlays the 16-bit registers with the 8-bit registers. Figure 1-5 shows this relationship.
The most important thing to note about the general-purpose registers is that they are not independent. Modifying one register may modify as many as three other registers. For example, modification of the EAX register may very well modify the AL, AH, and AX registers. This fact cannot be overemphasized here. A very common mistake in programs written by beginning assembly language programmers is register value corruption because the programmer did not completely understand the ramifications of the relationship shown in Figure 1-5.
Hello, World of Assembly Language 9

AAL2E_03.book Page 10 Thursday, February 18, 2010 12:49 PM

EAX
AX

AH

AL

ESI SI

EBX
BX

BH

BL

EDI DI

ECX
CX

CH

CL

EBP BP

EDX
DX

DH

DL

ESP SP

Figure 1-5: 80x86 (Intel CPU) general-purpose registers

The EFLAGS register is a 32-bit register that encapsulates several singlebit boolean (true/false) values. Most of the bits in the EFLAGS register are either reserved for kernel mode (operating system) functions or are of little interest to the application programmer. Eight of these bits (or flags) are of interest to application programmers writing assembly language programs. These are the overflow, direction, interrupt disable,4 sign, zero, auxiliary carry, parity, and carry flags. Figure 1-6 shows the layout of the flags within the lower 16 bits of the EFLAGS register.

15

0

Overflow Direction Interrupt Disable
Sign Zero
Auxiliary Carry

Not very interesting to application programmers

Parity

Carry

Figure 1-6: Layout of the FLAGS register (lower 16 bits of EFLAGS)

Of the eight flags that are of interest to application programmers, four flags in particular are extremely valuable: the overflow, carry, sign, and zero flags. Collectively, we will call these four flags the condition codes.5 The state of these flags lets you test the result of previous computations. For example, after comparing two values, the condition code flags will tell you whether one value is less than, equal to, or greater than a second value.

10 Chapter 1

4 Application programs cannot modify the interrupt flag, but we’ll look at this flag in Chapter 2; hence the discussion of this flag here.
5 Technically the parity flag is also a condition code, but we will not use that flag in this text.

AAL2E_03.book Page 11 Thursday, February 18, 2010 12:49 PM
One important fact that comes as a surprise to those just learning assembly language is that almost all calculations on the 80x86 CPU involve a register. For example, to add two variables together, storing the sum into a third variable, you must load one of the variables into a register, add the second operand to the value in the register, and then store the register away in the destination variable. Registers are a middleman in nearly every calculation. Therefore, registers are very important in 80x86 assembly language programs.
Another thing you should be aware of is that although the registers have the name “general purpose,” you should not infer that you can use any register for any purpose. All the 80x86 registers have their own special purposes that limit their use in certain contexts. The SP/ESP register pair, for example, has a very special purpose that effectively prevents you from using it for anything else (it’s the stack pointer). Likewise, the BP/EBP register has a special purpose that limits its usefulness as a general-purpose register. For the time being, you should avoid the use of the ESP and EBP registers for generic calculations; also, keep in mind that the remaining registers are not completely interchangeable in your programs.
1.7 The Memory Subsystem
A typical 80x86 processor running a modern 32-bit OS can access a maximum of 232 different memory locations, or just over 4 billion bytes. A few years ago, 4 gigabytes of memory would have seemed like infinity; modern machines, however, exceed this limit. Nevertheless, because the 80x86 architecture supports a maximum 4GB address space when using a 32-bit operating system like Windows, Mac OS X, FreeBSD, or Linux, the following discussion will assume the 4GB limit.
Of course, the first question you should ask is, “What exactly is a memory location?” The 80x86 supports byte-addressable memory. Therefore, the basic memory unit is a byte, which is sufficient to hold a single character or a (very) small integer value (we’ll talk more about that in Chapter 2).
Think of memory as a linear array of bytes. The address of the first byte is 0 and the address of the last byte is 232−1. For an 80x86 processor, the following pseudo-Pascal array declaration is a good approximation of memory:
Memory: array [0..4294967295] of byte;
C/C++ and Java users might prefer the following syntax:
byte Memory[4294967296];
To execute the equivalent of the Pascal statement Memory [125] := 0; the CPU places the value 0 on the data bus, places the address 125 on the address bus, and asserts the write line (this generally involves setting that line to 0), as shown in Figure 1-7.
Hello, Wo rld of Asse mbly Lang uag e 11

AAL2E_03.book Page 12 Thursday, February 18, 2010 12:49 PM

Address = 125 Data = 0 CPU Write = 0

Memory
Location 125

Figure 1-7: Memory write operation

To execute the equivalent of CPU := Memory [125]; the CPU places the address 125 on the address bus, asserts the read line (because the CPU is reading data from memory), and then reads the resulting data from the data bus (see Figure 1-8).

Address = 125

Memory

Data = Memory[125] CPU
Read = 0

Location 125

Figure 1-8: Memory read operation
This discussion applies only when accessing a single byte in memory. So what happens when the processor accesses a word or a double word? Because memory consists of an array of bytes, how can we possibly deal with values larger than a single byte? Easy—to store larger values, the 80x86 uses a sequence of consecutive memory locations. Figure 1-9 shows how the 80x86 stores bytes, words (2 bytes), and double words (4 bytes) in memory. The memory address of each of these objects is the address of the first byte of each object (that is, the lowest address).
Modern 80x86 processors don’t actually connect directly to memory. Instead, there is a special memory buffer on the CPU known as the cache (pronounced “cash”) that acts as a high-speed intermediary between the CPU and main memory. Although the cache handles the details automatically for you, one fact you should know is that accessing data objects in memory is sometimes more efficient if the address of the object is an even multiple of the object’s size. Therefore, it’s a good idea to align 4-byte objects (double words) on addresses that are multiples of 4. Likewise, it’s most

12 Chapter 1

AAL2E_03.book Page 13 Thursday, February 18, 2010 12:49 PM

efficient to align 2-byte objects on even addresses. You can efficiently access single-byte objects at any address. You’ll see how to set the alignment of memory objects in Section 3.4.

195

194

193

Double Word at

Address 192

192

191 Address
190

189

Word at

Address 188

188

187

Byte at

Address 186

186

Figure 1-9: Byte, word, and double-word storage in memory
Before leaving this discussion of memory objects, it’s important to understand the correspondence between memory and HLA variables. One of the nice things about using an assembler/compiler like HLA is that you don’t have to worry about numeric memory addresses. All you need to do is declare a variable in HLA, and HLA takes care of associating that variable with some unique set of memory addresses. For example, if you have the following declaration section:

static i8 i16 i32

:int8; :int16; :int32;

HLA will find some unused 8-bit byte in memory and associate it with the i8 variable; it will find a pair of consecutive unused bytes and associate i16 with them; finally, HLA will find 4 consecutive unused bytes and associate the value of i32 with those 4 bytes (32 bits). You’ll always refer to these variables by their name. You generally don’t have to concern yourself with their numeric address. Still, you should be aware that HLA is doing this for you behind your back.

Hello, Wo rld of Asse mbly Lang uag e 13

AAL2E_03.book Page 14 Thursday, February 18, 2010 12:49 PM
1.8 Some Basic Machine Instructions
The 80x86 CPU family provides from just over a hundred to many thousands of different machine instructions, depending on how you define a machine instruction. Even at the low end of the count (greater than 100), it appears as though there are far too many machine instructions to learn in a short time. Fortunately, you don’t need to know all the machine instructions. In fact, most assembly language programs probably use around 30 different machine instructions.6 Indeed, you can certainly write several meaningful programs with only a few machine instructions. The purpose of this section is to provide a small handful of machine instructions so you can start writing simple HLA assembly language programs right away.
Without question, the mov instruction is the most oft-used assembly language statement. In a typical program, anywhere from 25 percent to 40 percent of the instructions are mov instructions. As its name suggests, this instruction moves data from one location to another.7 The HLA syntax for this instruction is:
mov( source_operand, destination_operand );
The source_operand can be a register, a memory variable, or a constant. The destination_operand may be a register or a memory variable. Technically the 80x86 instruction set does not allow both operands to be memory variables. HLA, however, will automatically translate a mov instruction with two-word or double-word memory operands into a pair of instructions that will copy the data from one location to another. In a high-level language like Pascal or C/C++, the mov instruction is roughly equivalent to the following assignment statement:
destination_operand = source_operand ;
Perhaps the major restriction on the mov instruction’s operands is that they must both be the same size. That is, you can move data between a pair of byte (8-bit) objects, word (16-bit) objects, or double-word (32-bit) objects; you may not, however, mix the sizes of the operands. Table 1-1 lists all the legal combinations for the mov instruction.
You should study this table carefully because most of the general-purpose 80x86 instructions use this syntax.

14 Chapter 1

6 Different programs may use a different set of 30 instructions, but few programs use more than 30 distinct instructions.
7 Technically, mov actually copies data from one location to another. It does not destroy the original data in the source operand. Perhaps a better name for this instruction would have been copy. Alas, it’s too late to change it now.

AAL2E_03.book Page 15 Thursday, February 18, 2010 12:49 PM

Table 1-1: Legal 80x86 mov Instruction Operands

Source

Destination

Reg8*

Reg8

Reg8

Mem8

Mem8 Constant†

Reg8 Reg8

Constant

Mem8

Reg16

Reg16

Reg16

Mem16

Mem16

Reg16

Constant

Reg16

Constant

Mem16

Reg32

Reg32

Reg32

Mem32

Mem32

Reg32

Constant

Reg32

Constant

Mem32

* The suffix denotes the size of the register or memory location.

† The constant must be small enough to fit in the specified destination operand.

The 80x86 add and sub instructions let you add and subtract two operands. Their syntax is nearly identical to the mov instruction:

add( source_operand, destination_operand ); sub( source_operand, destination_operand );
The add and sub operands take the same form as the mov instruction.8 The add instruction does the following:

destination_operand = destination_operand + source_operand ; destination_operand += source_operand; // For those who prefer C syntax.

The sub instruction does the calculation:

destination_operand = destination_operand - source_operand ; destination_operand -= source_operand ; // For C fans.

With nothing more than these three instructions, plus the HLA control structures that the next section discusses, you can actually write some sophisticated programs. Listing 1-3 provides a sample HLA program that demonstrates these three instructions.

8 Remember, though, that add and sub do not support memory-to-memory operations.
Hello, Wo rld of Asse mbly Lang uag e 15

AAL2E_03.book Page 16 Thursday, February 18, 2010 12:49 PM

program DemoMOVaddSUB;

#include( "stdlib.hhf" )

static i8: i16: i32:

int8 int16 int32

:= -8; := -16; := -32;

begin DemoMOVaddSUB;

// First, print the initial values // of our variables.

stdout.put (
nl, "Initialized values: i8=", i8, ", i16=", i16, ", i32=", i32, nl );

// Compute the absolute value of the // three different variables and // print the result. // Note: Because all the numbers are // negative, we have to negate them. // Using only the mov, add, and sub // instructions, we can negate a value // by subtracting it from zero.

mov( 0, al ); // Compute i8 := -i8; sub( i8, al ); mov( al, i8 );

mov( 0, ax ); // Compute i16 := -i16; sub( i16, ax ); mov( ax, i16 );

mov( 0, eax ); // Compute i32 := -i32; sub( i32, eax ); mov( eax, i32 );

// Display the absolute values:

stdout.put (
nl, "After negation: i8=", i8, ", i16=", i16, ", i32=", i32, nl

16 Chapter 1

AAL2E_03.book Page 17 Thursday, February 18, 2010 12:49 PM
);
// Demonstrate add and constant-to-memory // operations:
add( 32323200, i32 ); stdout.put( nl, "After add: i32=", i32, nl );
end DemoMOVaddSUB;
Listing 1-3: Demonstration of the mov, add, and sub instructions
1.9 Some Basic HLA Control Structures
The mov, add, and sub instructions, while valuable, aren’t sufficient to let you write meaningful programs. You will need to complement these instructions with the ability to make decisions and create loops in your HLA programs before you can write anything other than a simple program. HLA provides several high-level control structures that are very similar to control structures found in high-level languages. These include if..then..elseif..else..endif, while..endwhile, repeat..until, and so on. By learning these statements you will be armed and ready to write some real programs.
Before discussing these high-level control structures, it’s important to point out that these are not real 80x86 assembly language statements. HLA compiles these statements into a sequence of one or more real assembly language statements for you. In Chapter 7, you’ll learn how HLA compiles the statements, and you’ll learn how to write pure assembly language code that doesn’t use them. However, there is a lot to learn before you get to that point, so we’ll stick with these high-level language statements for now.
Another important fact to mention is that HLA’s high-level control structures are not as high level as they first appear. The purpose behind HLA’s high-level control structures is to let you start writing assembly language programs as quickly as possible, not to let you avoid the use of assembly language altogether. You will soon discover that these statements have some severe restrictions associated with them, and you will quickly outgrow their capabilities. This is intentional. Once you reach a certain level of comfort with HLA’s high-level control structures and decide you need more power than they have to offer, it’s time to move on and learn the real 80x86 instructions behind these statements.
Do not let the presence of high-level-like statements in HLA confuse you. Many people, after learning about the presence of these statements in the HLA language, erroneously come to the conclusion that HLA is just some special high-level language and not a true assembly language. This isn’t true. HLA is a full low-level assembly language. HLA supports all the same machine instructions as any other 80x86 assembler. The difference is that HLA has some extra statements that allow you to do more than is possible with those other 80x86 assemblers. Once you learn 80x86 assembly
Hello, Wo rld of Asse mbly Lang uag e 17

AAL2E_03.book Page 18 Thursday, February 18, 2010 12:49 PM

18 Chapter 1

language with HLA, you may elect to ignore all these extra (high-level) statements and write only low-level 80x86 assembly language code if this is your desire.
The following sections assume that you’re familiar with at least one high-level language. They present the HLA control statements from that perspective without bothering to explain how you actually use these statements to accomplish something in a program. One prerequisite this text assumes is that you already know how to use these generic control statements in a high-level language; you’ll use them in HLA programs in an identical manner.

1.9.1 Boolean Expressions in HLA Statements
Several HLA statements require a boolean (true or false) expression to control their execution. Examples include the if, while, and repeat..until statements. The syntax for these boolean expressions represents the greatest limitation of the HLA high-level control structures. This is one area where your familiarity with a high-level language will work against you—you’ll want to use the fancy expressions you use in a high-level language, yet HLA supports only some basic forms.
HLA boolean expressions take the following forms:9

flag_specification !flag_specification register !register Boolean_variable !Boolean_variable mem_reg relop mem_reg_const register in LowConst..HiConst register not in LowConst..HiConst

A flag_specification may be one of the symbols that are described in Table 1-2.

Table 1-2: Symbols for flag_specification

Symbol @c @nc @z @nz @o @no @s @ns

Meaning Carry No carry Zero Not zero Overflow No overflow Sign No sign

Explanation True if the carry is set (1); false if the carry is clear (0). True if the carry is clear (0); false if the carry is set (1). True if the zero flag is set; false if it is clear. True if the zero flag is clear; false if it is set. True if the overflow flag is set; false if it is clear. True if the overflow flag is clear; false if it is set. True if the sign flag is set; false if it is clear. True if the sign flag is clear; false if it is set.

9 There are a few additional forms that we’ll cover in Chapter 6.

AAL2E_03.book Page 19 Thursday, February 18, 2010 12:49 PM

The use of the flag values in a boolean expression is somewhat advanced. You will begin to see how to use these boolean expression operands in the next chapter.
A register operand can be any of the 8-bit, 16-bit, or 32-bit generalpurpose registers. The expression evaluates false if the register contains a zero; it evaluates true if the register contains a nonzero value.
If you specify a boolean variable as the expression, the program tests it for zero (false) or nonzero (true). Because HLA uses the values zero and one to represent false and true, respectively, the test works in an intuitive fashion. Note that HLA requires such variables be of type boolean. HLA rejects other data types. If you want to test some other type against zero/not zero, then use the general boolean expression discussed next.
The most general form of an HLA boolean expression has two operands and a relational operator. Table 1-3 lists the legal combinations.

Table 1-3: Legal Boolean Expressions

Left Operand
Memory variable or register

Relational Operator
= or == <> or != < <= > >=

Right Operand
Variable, register, or constant

Note that both operands cannot be memory operands. In fact, if you think of the right operand as the source operand and the left operand as the destination operand, then the two operands must be the same that add and sub allow.
Also like the add and sub instructions, the two operands must be the same size. That is, they must both be byte operands, they must both be word operands, or they must both be double-word operands. If the right operand is a constant, its value must be in the range that is compatible with the left operand.
There is one other issue: if the left operand is a register and the right operand is a positive constant or another register, HLA uses an unsigned comparison. The next chapter will discuss the ramifications of this; for the time being, do not compare negative values in a register against a constant or another register. You may not get an intuitive result.
The in and not in operators let you test a register to see if it is within a specified range. For example, the expression eax in 2000..2099 evaluates true if the value in the EAX register is between 2,000 and 2,099 (inclusive). The not in (two words) operator checks to see if the value in a register is outside the specified range. For example, al not in 'a'..'z' evaluates true if the character in the AL register is not a lowercase alphabetic character.

Hello, Wo rld of Asse mbly Lang uag e 19

AAL2E_03.book Page 20 Thursday, February 18, 2010 12:49 PM

Here are some examples of legal boolean expressions in HLA:
@c Bool_var al esi eax < ebx ebx > 5 i32 < -2 i8 > 128 al < i8 eax in 1..100 ch not in 'a'..'z'

1.9.2 The HLA if..then..elseif..else..endif Statement
The HLA if statement uses the syntax shown in Figure 1-10.

if( expression ) then

<< sequence of one or more statements >>
elseif( expression ) then
<< sequence of one or more statements >>
else

The elseif clause is optional. Zero or more elseif clauses may appear in an if statement. If more than one elseif clause appears, all the elseif clauses must appear before the else clause (or before the endif if there is no else clause).

<< sequence of one or more statements >>
endif;

The else clause is optional. At most one else clause may appear within an if statement and it must be the last clause before the endif.

Figure 1-10: HLA if statement syntax

The expressions appearing in an if statement must take one of the forms from the previous section. If the boolean expression is true, the code after the then executes; otherwise control transfers to the next elseif or else clause in the statement.
Because the elseif and else clauses are optional, an if statement could take the form of a single if..then clause, followed by a sequence of statements and a closing endif clause. The following is such a statement:

if( eax = 0 ) then stdout.put( "error: NULL value", nl );
endif;

20 Chapter 1

AAL2E_03.book Page 21 Thursday, February 18, 2010 12:49 PM
If, during program execution, the expression evaluates true, then the code between the then and the endif executes. If the expression evaluates false, then the program skips over the code between the then and the endif.
Another common form of the if statement has a single else clause. The following is an example of an if statement with an optional else clause:
if( eax = 0 ) then stdout.put( "error: NULL pointer encountered", nl );
else stdout.put( "Pointer is valid", nl );
endif;
If the expression evaluates true, the code between the then and the else executes; otherwise the code between the else and the endif clauses executes.
You can create sophisticated decision-making logic by incorporating the elseif clause into an if statement. For example, if the CH register contains a character value, you can select from a menu of items using code like the following:
if( ch = 'a' ) then stdout.put( "You selected the 'a' menu item", nl );
elseif( ch = 'b' ) then stdout.put( "You selected the 'b' menu item", nl );
elseif( ch = 'c' ) then stdout.put( "You selected the 'c' menu item", nl );
else stdout.put( "Error: illegal menu item selection", nl );
endif;
Although this simple example doesn’t demonstrate it, HLA does not require an else clause at the end of a sequence of elseif clauses. However, when making multiway decisions, it’s always a good idea to provide an else clause just in case an error arises. Even if you think it’s impossible for the else clause to execute, just keep in mind that future modifications to the code could void this assertion, so it’s a good idea to have error-reporting statements in your code.
Hello, Wo rld of Asse mbly Lang uag e 21

AAL2E_03.book Page 22 Thursday, February 18, 2010 12:49 PM
1.9.3 Conjunction, Disjunction, and Negation in Boolean Expressions
Some obvious omissions in the list of operators in the previous sections are the conjunction (logical and), disjunction (logical or), and negation (logical not) operators. This section describes their use in boolean expressions (the discussion had to wait until after describing the if statement in order to present realistic examples).
HLA uses the && operator to denote logical and in a runtime boolean expression. This is a dyadic (two-operand) operator, and the two operands must be legal runtime boolean expressions. This operator evaluates to true if both operands evaluate to true. For example:
if( eax > 0 && ch = 'a' ) then
mov( eax, ebx ); mov( ' ', ch );
endif;
The two mov statements above execute only if EAX is greater than zero and CH is equal to the character a. If either of these conditions is false, then program execution skips over these mov instructions.
Note that the expressions on either side of the && operator may be any legal boolean expressions; these expressions don’t have to be comparisons using the relational operators. For example, the following are all legal expressions:
@z && al in 5..10 al in 'a'..'z' && ebx boolVar && !eax
HLA uses short-circuit evaluation when compiling the && operator. If the leftmost operand evaluates false, then the code that HLA generates does not bother evaluating the second operand (because the whole expression must be false at that point). Therefore, in the last expression above, the code will not check EAX against zero if boolVar evaluates false.
Note that an expression like eax < 10 && ebx <> eax is itself a legal boolean expression and, therefore, may appear as the left or right operand of the && operator. Therefore, expressions like the following are perfectly legal:
eax < 0 && ebx <> eax && !ecx
The && operator is left associative, so the code that HLA generates evaluates the expression above in a left-to-right fashion. If EAX is less than zero, the CPU will not test either of the remaining expressions. Likewise, if EAX is not less than zero but EBX is equal to EAX, this code will not evaluate the third expression because the whole expression is false regardless of ECX’s value.
22 Chapter 1

AAL2E_03.book Page 23 Thursday, February 18, 2010 12:49 PM
HLA uses the || operator to denote disjunction (logical or) in a runtime boolean expression. Like the && operator, this operator expects two legal runtime boolean expressions as operands. This operator evaluates true if either (or both) operands evaluate true. Like the && operator, the disjunction operator uses short-circuit evaluation. If the left operand evaluates true, then the code that HLA generates doesn’t bother to test the value of the second operand. Instead, the code will transfer to the location that handles the situation when the boolean expression evaluates true. Here are some examples of legal expressions using the || operator:
@z || al = 10 al in 'a'..'z' || ebx !boolVar || eax
Like the && operator, the disjunction operator is left associative, so multiple instances of the || operator may appear within the same expression. Should this be the case, the code that HLA generates will evaluate the expressions from left to right. For example:
eax < 0 || ebx <> eax || !ecx
The code above evaluates to true if EAX is less than zero, EBX does not equal EAX, or ECX is zero. Note that if the first comparison is true, the code doesn’t bother testing the other conditions. Likewise, if the first comparison is false and the second is true, the code doesn’t bother checking to see if ECX is zero. The check for ECX equal to zero occurs only if the first two comparisons are false.
If both the conjunction and disjunction operators appear in the same expression, then the && operator takes precedence over the || operator. Consider the following expression:
eax < 0 || ebx <> eax && !ecx
The machine code HLA generates evaluates this as
eax < 0 || (ebx <> eax && !ecx)
If EAX is less than zero, then the code HLA generates does not bother to check the remainder of the expression, and the entire expression evaluates true. However, if EAX is not less than zero, then both of the following conditions must evaluate true in order for the overall expression to evaluate true.
HLA allows you to use parentheses to surround subexpressions involving && and || if you need to adjust the precedence of the operators. Consider the following expression:
(eax < 0 || ebx <> eax) && !ecx
Hello, Wo rld of Asse mbly Lang uag e 23

AAL2E_03.book Page 24 Thursday, February 18, 2010 12:49 PM

For this expression to evaluate true, ECX must contain zero and either EAX must be less than zero or EBX must not equal EAX. Contrast this to the result the expression produces without the parentheses.
HLA uses the ! operator to denote logical negation. However, the ! operator may only prefix a register or boolean variable; you may not use it as part of a larger expression (e.g., !eax < 0). To achieve logical negative of an existing boolean expression, you must surround that expression with parentheses and prefix the parentheses with the ! operator. For example:

!( eax < 0 )

This expression evaluates true if EAX is not less than zero. The logical not operator is primarily useful for surrounding complex expressions involving the conjunction and disjunction operators. While it is occasionally useful for short expressions like the one above, it’s usually easier (and more readable) to simply state the logic directly rather than convolute it with the logical not operator. Note that HLA also provides the | and & operators, but they are distinct from || and && and have completely different meanings. See the HLA reference manual for more details on these (compile-time) operators.

1.9.4 The while..endwhile Statement
The while statement uses the basic syntax shown in Figure 1-11.

while( expression ) do

<< sequence of one or more statements >>
endwhile;

The expression in the while statement has the same restrictions as the if statement.
Loop body

Figure 1-11: HLA while statement syntax

This statement evaluates the boolean expression. If it is false, control immediately transfers to the first statement following the endwhile clause. If the value of the expression is true, then the CPU executes the body of the loop. After the loop body executes, control transfers back to the top of the loop, where the while statement retests the loop control expression. This process repeats until the expression evaluates false.
Note that the while loop, like its high-level-language counterpart, tests for loop termination at the top of the loop. Therefore, it is quite possible that the statements in the body of the loop will not execute (if the expression is false when the code first executes the while statement). Also note that the body of the while loop must, at some point, modify the value of the boolean expression or an infinite loop will result.

24 Chapter 1

AAL2E_03.book Page 25 Thursday, February 18, 2010 12:49 PM
Here’s an example of an HLA while loop:
mov( 0, i ); while( i < 10 ) do
stdout.put( "i=", i, nl ); add( 1, i ); endwhile;
1.9.5 The for..endfor Statement
The HLA for loop takes the following general form:
for( Initial_Stmt; Termination_Expression; Post_Body_Statement ) do << Loop body >>
endfor;
This is equivalent to the following while statement:
Initial_Stmt; while( Termination_Expression ) do
<< Loop body >> Post_Body_Statement; endwhile;
Initial_Stmt can be any single HLA/80x86 instruction. Generally this statement initializes a register or memory location (the loop counter) with zero or some other initial value. Termination_Expression is an HLA boolean expression (same format that while allows). This expression determines whether the loop body executes. Post_Body_Statement executes at the bottom of the loop (as shown in the while example above). This is a single HLA statement. Usually an instruction like add modifies the value of the loop control variable.
The following gives a complete example:
for( mov( 0, i ); i < 10; add(1, i )) do stdout.put( "i=", i, nl );
endfor;
Hello, Wo rld of Asse mbly Lang uag e 25

AAL2E_03.book Page 26 Thursday, February 18, 2010 12:49 PM

The above, rewritten as a while loop, becomes:
mov( 0, i ); while( i < 10 ) do
stdout.put( "i=", i, nl ); add( 1, i ); endwhile;

1.9.6 The repeat..until Statement
The HLA repeat..until statement uses the syntax shown in Figure 1-12. C/C++/C# and Java users should note that the repeat..until statement is very similar to the do..while statement.

repeat
<< sequence of one or more statements >>
until( expression );

Loop body
The expression in the until statement has the same restrictions as the if statement.

Figure 1-12: HLA repeat..until statement syntax

The HLA repeat..until statement tests for loop termination at the bottom of the loop. Therefore, the statements in the loop body always execute at least once. Upon encountering the until clause, the program will evaluate the expression and repeat the loop if the expression is false (that is, it repeats while false). If the expression evaluates true, the control transfers to the first statement following the until clause.
The following simple example demonstrates the repeat..until statement:

mov( 10, ecx ); repeat
stdout.put( "ecx = ", ecx, nl ); sub( 1, ecx );
until( ecx = 0 );

If the loop body will always execute at least once, then it is usually more efficient to use a repeat..until loop rather than a while loop.

26 Chapter 1

AAL2E_03.book Page 27 Thursday, February 18, 2010 12:49 PM

1.9.7 The break and breakif Statements

The break and breakif statements provide the ability to prematurely exit from a loop. Figure 1-13 shows the syntax for these two statements.

break; breakif( expression );

The expression in the breakif statement has the same restrictions as the if statement.

Figure 1-13: HLA break and breakif syntax

The break statement exits the loop that immediately contains the break. The breakif statement evaluates the boolean expression and exits the containing loop if the expression evaluates true.
Note that the break and breakif statements do not allow you to break out of more than one nested loop. HLA does provide statements that do this, the begin..end block and the exit/exitif statements. Please consult the HLA reference manual for more details. HLA also provides the continue/continueif pair that lets you repeat a loop body. Again, see the HLA reference manual for more details.

1.9.8 The forever..endfor Statement
Figure 1-14 shows the syntax for the forever statement.

forever

<< sequence of one or more statements >>

endfor;

Loop body

Figure 1-14: HLA forever loop syntax

This statement creates an infinite loop. You may also use the break and breakif statements along with forever..endfor to create a loop that tests for loop termination in the middle of the loop. Indeed, this is probably the most common use of this loop, as the following example demonstrates:

forever
stdout.put( "Enter an integer less than 10: "); stdin.get( i ); breakif( i < 10 ); stdout.put( "The value needs to be less than 10!", nl );
endfor;

Hello, Wo rld of Asse mbly Lang uag e 27

AAL2E_03.book Page 28 Thursday, February 18, 2010 12:49 PM

1.9.9 The try..exception..endtry Statement
The HLA try..exception..endtry statement provides very powerful exception handling capabilities. The syntax for this statement appears in Figure 1-15.

try
<< sequence of one or more statements >>
exception( exceptionID )
<< sequence of one or more statements >>
exception( exceptionID )
<< sequence of one or more statements >>
endtry;

Statements to test At least one exception handling block
Zero or more (optional) exception handling blocks

Figure 1-15: HLA try..exception..endtry statement syntax
The try..endtry statement protects a block of statements during execution. If the statements between the try clause and the first exception clause (the protected block), execute without incident, control transfers to the first statement after the endtry immediately after executing the last statement in the protected block. If an error (exception) occurs, then the program interrupts control at the point of the exception (that is, the program raises an exception). Each exception has an unsigned integer constant associated with it, known as the exception ID. The excepts.hhf header file in the HLA Standard Library predefines several exception IDs, although you may create new ones for your own purposes. When an exception occurs, the system compares the exception ID against the values appearing in each of the exception clauses following the protected code. If the current exception ID matches one of the exception values, control continues with the block of statements immediately following that exception. After the exception-handling code completes execution, control transfers to the first statement following the endtry.
If an exception occurs and there is no active try..endtry statement, or the active try..endtry statements do not handle the specific exception, the program will abort with an error message.
The following code fragment demonstrates how to use the try..endtry statement to protect the program from bad user input:

repeat
mov( false, GoodInteger ); // Note: GoodInteger must be a boolean var. try
stdout.put( "Enter an integer: " );

28 Chapter 1

AAL2E_03.book Page 29 Thursday, February 18, 2010 12:49 PM

stdin.get( i ); mov( true, GoodInteger );
exception( ex.ConversionError );
stdout.put( "Illegal numeric value, please re-enter", nl );
exception( ex.ValueOutOfRange );
stdout.put( "Value is out of range, please re-enter", nl );
endtry;
until( GoodInteger );
The repeat..until loop repeats this code as long as there is an error during input. Should an exception occur because of bad input, control transfers to the exception clauses to see if a conversion error (e.g., illegal characters in the number) or a numeric overflow occurs. If either of these exceptions occur, then they print the appropriate message, control falls out of the try..endtry statement, and the repeat..until loop repeats because the code will not have set GoodInteger to true. If a different exception occurs (one that is not handled in this code), then the program aborts with the specified error message.10
Table 1-4 lists the exceptions provided in the excepts.hhf header file at the time this was being written. See the excepts.hhf header file provided with HLA for the most current list of exceptions.

Table 1-4: Exceptions Provided in excepts.hhf

Exception ex.StringOverflow
ex.StringIndexError
ex.StringOverlap ex.StringMetaData ex.StringAlignment ex.StringUnderflow ex.IllegalStringOperation ex.ValueOutOfRange ex.IllegalChar
ex.TooManyCmdLnParms ex.BadObjPtr

Description

Attempt to store a string that is too large into a string variable.

Attempt to access a character that is not present in a string.

Attempt to copy a string onto itself.

Corrupted string value.

Attempt to store a string an at unaligned address.

Attempt to extract “negative” characters from a string.

Operation not permitted on string data.

Value is too large for the current operation.

Operation encountered a character code whose ASCII code is not in the range 0..127.

Command line contains too many program parameters.

Pointer to class object is illegal.

(continued)

10 An experienced programmer may wonder why this code uses a boolean variable rather than a breakif statement to exit the repeat..until loop. There are some technical reasons for this that you will learn about in Section 1.11.
Hello, Wo rld of Asse mbly Lang uag e 29

AAL2E_03.book Page 30 Thursday, February 18, 2010 12:49 PM

Table 1-4: Exceptions Provided in excepts.hhf (continued)

Exception ex.InvalidAlignment ex.InvalidArgument
ex.BufferOverflow ex.BufferUnderflow ex.IllegalSize ex.ConversionError
ex.BadFileHandle
ex.FileNotFound ex.FileOpenFailure ex.FileCloseError ex.FileWriteError ex.FileReadError ex.FileSeekError ex.DiskFullError ex.AccessDenied
ex.EndOfFile ex.CannotCreateDir ex.CannotRemoveDir ex.CannotRemoveFile ex.CDFailed ex.CannotRenameFile ex.MemoryAllocationFailure ex.MemoryFreeFailure
ex.MemoryAllocationCorruption ex.AttemptToFreeNULL ex.AttemptToDerefNULL
ex.BlockAlreadyFree ex.CannotFreeMemory ex.PointerNotInHeap
ex.WidthTooBig
ex.FractionTooBig
ex.ArrayShapeViolation

Description
Argument was not aligned on a proper memory address. Function call (generally OS API call) contains an invalid argument value. Buffer or blob object exceeded declared size. Attempt to retrieve nonexistent data from a blob or buffer. Argument’s data size is incorrect. String-to-numeric conversion operation contains illegal (nonnumeric) characters. Program attempted a file access using an invalid file handle value. Program attempted to access a nonexistent file. Operating system could not open the file (file not found). Operating system could not close the file. Error writing data to a file. Error reading data from a file. Attempted to seek to a nonexistent position in a file. Attempted to write data to a full disk. User does not have sufficient priviledges to access file data. Program attempted to read beyond the end of file. Attempt to create a directory failed. Attempt to delete a directory failed. Attempt to delete a file failed. Attempt to change to a new directory failed. Attempt to rename a file failed. Insufficient system memory for allocation request. Could not free the specified memory block (corrupted memory management system). Corrupted memory management system. Caller attempted to free a NULL pointer. Program attempted to access data indirectly using a NULL pointer. Caller attempted to free a block that was already freed. Memory free operation failure. Caller attempted to free a block of memory that was not allocated on the heap. Format width for numeric to string conversion was too large. Format size for fractional portion in floating-point-to-string conversion was too large. Attempted operation on two arrays whose dimensions don’t match.

30 Chapter 1

AAL2E_03.book Page 31 Thursday, February 18, 2010 12:49 PM

Table 1-4: Exceptions Provided in excepts.hhf (continued)

Exception ex.ArrayBounds
ex.InvalidDate ex.InvalidDateFormat ex.TimeOverflow ex.InvalidTime ex.InvalidTimeFormat ex.SocketError ex.ThreadError ex.AssertionFailed ex.ExecutedAbstract ex.AccessViolation ex.InPageError ex.NoMemory ex.InvalidHandle ex.ControlC
ex.Breakpoint ex.SingleStep ex.PrivInstr ex.IllegalInstr
ex.BoundInstr ex.IntoInstr ex.DivideError ex.fDenormal ex.fDivByZero ex.fInexactResult ex.fInvalidOperation ex.fOverflow ex.fStackCheck ex.fUnderflow ex.InvalidHandle

Description
Attempted to access an element of an array, but the index was out of bounds. Attempted date operation with an illegal date. Conversion from string to date contains illegal characters. Overflow during time arithmetic. Attempted time operation with an illegal time. Conversion from string to time contains illegal characters. Network communication failure. Generic thread (multitasking) error. assert statement encountered a failed assertion. Attempt to execute an abstract class method. Attempt to access an illegal memory location. OS memory access error. OS memory failure. Bad handle passed to OS API call. CTRL-C was pressed on system console (functionality is OS specific). Program executed a breakpoint instruction (INT 3). Program is operating with the trace flag set. Program attempted to execute a kernel-only instruction. Program attempted to execute an illegal machine instruction. Bound instruction execution with “out of bounds” value. Into instruction execution with the overflow flag set. Program attempted division by zero or other divide error. Floating point exception (see Chapter 6). Floating point exception (see Chapter 6). Floating point exception (see Chapter 6). Floating point exception (see Chapter 6). Floating point exception (see Chapter 6). Floating point exception (see Chapter 6). Floating point exception (see Chapter 6). OS reported an invalid handle for some operation.

Most of these exceptions occur in situations that are well beyond the scope of this chapter. Their appearance here is strictly for completeness. See the HLA reference manual, the HLA Standard Library documentation, and the HLA Standard Library source code for more details concerning these exceptions. The ex.ConversionError, ex.ValueOutOfRange, and ex.StringOverflow exceptions are the ones you’ll most commonly use.
We’ll return to the discussion of the try..endtry statement in Section 1.11. First, however, we need to cover a little more material.
Hello, Wo rld of Asse mbly Lang uag e 31

AAL2E_03.book Page 32 Thursday, February 18, 2010 12:49 PM

1.10 Introduction to the HLA Standard Library
There are two reasons HLA is much easier to learn and use than standard assembly language. The first reason is HLA’s high-level syntax for declarations and control structures. This leverages your high-level language knowledge, allowing you to learn assembly language more efficiently. The other half of the equation is the HLA Standard Library. The HLA Standard Library provides many common, easy-to-use, assembly language routines that you can call without having to write this code yourself (and, more importantly, having to learn how to write yourself). This eliminates one of the larger stumbling blocks many people have when learning assembly language: the need for sophisticated I/O and support code in order to write basic statements. Prior to the advent of a standardized assembly language library, it often took considerable study before a new assembly language programmer could do as much as print a string to the display. With the HLA Standard Library, this roadblock is removed, and you can concentrate on learning assembly language concepts rather than learning low-level I/O details that are specific to a given operating system.
A wide variety of library routines is only part of HLA’s support. After all, assembly language libraries have been around for quite some time.11 HLA’s Standard Library complements HLA by providing a high-level language interface to these routines. Indeed, the HLA language itself was originally designed specifically to allow the creation of a high-level set of library routines. This high-level interface, combined with the high-level nature of many of the routines in the library, packs a surprising amount of power in an easy-to-use package.
The HLA Standard Library consists of several modules organized by category. Table 1-5 lists many of the modules that are available.12

Table 1-5: HLA Standard Library Modules

Name args arrays bits blobs bsd chars console conv coroutines cset DateTime

Description
Command-line parameter-parsing support routines. Array declarations and operations. Bit-manipulation functions. Binary large objects—operations on large blocks of binary data. OS API calls for FreeBSD (HLA FreeBSD version only). Operations on character data. Portable console (text screen) operations (cursor movement, screen clears, etc.). Various conversions between strings and other values. Support for coroutines (“cooperative multitasking”). Character set functions. Calendar, date, and time functions.

32 Chapter 1

11 For example, see the UCR Standard Library for 80x86 Assembly Language Programmers.
12 Because the HLA Standard Library is expanding, this list is probably out of date. See the HLA documentation for a current list of Standard Library modules.

AAL2E_03.book Page 33 Thursday, February 18, 2010 12:49 PM

Table 1-5: HLA Standard Library Modules (continued)

Name env excepts fileclass fileio filesys hla Linux lists mac math
memmap memory patterns random sockets stderr stdin stdio stdout strings tables threads timers win32 x86

Description
Access to OS environment variables. Exception-handling routines. Object-oriented file input and output. File input and output routines. Access to the OS file system. Special HLA constants and other values. Linux system calls (HLA Linux version only). An HLA class for manipulating linked lists. OS API calls for Mac OS X (HLA Mac OS X version only). Extended-precision arithmetic, transcendental functions, and other mathematical functions. Memory-mapped file operations. Memory allocation, deallocation, and support code. The HLA pattern-matching library. Pseudo-random number generators and support code. A set of network communication functions and classes. Provides user output and several other support functions. User input routines. A support module for stderr, stdin, and stdout. Provides user output and several other support routines. HLA’s powerful string library. Table (associative array) support routines. Support for multithreaded applications and process synchronization. Support for timing events in an application. Constants used in Windows calls (HLA Windows version only). Constants and other items specific to the 80x86 CPU.

Later sections of this text will explain many of these modules in greater detail. This section will concentrate on the most important routines (at least to beginning HLA programmers), the stdio library.

1.10.1 Predefined Constants in the stdio Module
Perhaps the first place to start is with a description of some common constants that the stdio module defines for you. Consider the following (typical) example:

stdout.put( "Hello World", nl );
The nl appearing at the end of this statement stands for newline. The nl identifier is not a special HLA reserved word, nor is it specific to the stdout.put statement. Instead, it’s simply a predefined constant that corresponds to the

Hello, Wo rld of Asse mbly Lang uag e 33

AAL2E_03.book Page 34 Thursday, February 18, 2010 12:49 PM

string containing the standard end-of-line sequence (a carriage return/line feed pair under Windows or just a line feed under Linux, FreeBSD, and Mac OS X).
In addition to the nl constant, the HLA standard I/O library module defines several other useful character constants, as listed in Table 1-6.

Table 1-6: Character Constants Defined by the HLA Standard I/O Library

Character stdio.bell stdio.bs stdio.tab stdio.lf stdio.cr

Definition
The ASCII bell character; beeps the speaker when printed The ASCII backspace character The ASCII tab character The ASCII linefeed character The ASCII carriage return character

Except for nl, these characters appear in the stdio namespace13 (and therefore require the stdio. prefix). The placement of these ASCII constants within the stdio namespace helps avoid naming conflicts with your own variables. The nl name does not appear within a namespace because you will use it very often, and typing stdio.nl would get tiresome very quickly.

1.10.2 Standard In and Standard Out
Many of the HLA I/O routines have a stdin or stdout prefix. Technically, this means that the standard library defines these names in a namespace. In practice, this prefix suggests where the input is coming from (the standard input device) or going to (the standard output device). By default, the standard input device is the system keyboard. Likewise, the default standard output device is the console display. So, in general, statements that have stdin or stdout prefixes will read and write data on the console device.
When you run a program from the command-line window (or shell), you have the option of redirecting the standard input and/or standard output devices. A command-line parameter of the form >outfile redirects the standard output device to the specified file (outfile). A command-line parameter of the form <infile redirects the standard input so that its data comes from the specified input file (infile). The following examples demonstrate how to use these parameters when running a program named testpgm in the command window:14

testpgm <input.data testpgm >output.txt testpgm <in.txt >output.txt

34 Chapter 1

13 Namespaces are the subject of Chapter 5.
14 For Linux, FreeBSD, and Mac OS X users, depending on how your system is set up, you may need to type ./ in front of the program’s name to actually execute the program (e.g., ./testpgm
<input.data).

AAL2E_03.book Page 35 Thursday, February 18, 2010 12:49 PM
1.10.3 The stdout.newln Routine
The stdout.newln procedure prints a newline sequence to the standard output device. This is functionally equivalent to saying stdout.put( nl );. The call to stdout.newln is sometimes a little more convenient. For example:
stdout.newln();
1.10.4 The stdout.putiX Routines
The stdout.puti8, stdout.puti16, and stdout.puti32 library routines print a single parameter (one byte, two bytes, or four bytes, respectively) as a signed integer value. The parameter may be a constant, a register, or a memory variable, as long as the size of the actual parameter is the same as the size of the formal parameter.
These routines print the value of their specified parameter to the standard output device. These routines will print the value using the minimum number of print positions possible. If the number is negative, these routines will print a leading minus sign. Here are some examples of calls to these routines:
stdout.puti8( 123 ); stdout.puti16( dx ); stdout.puti32( i32Var );
1.10.5 The stdout.putiXSize Routines
The stdout.puti8Size, stdout.puti16Size, and stdout.puti32Size routines output signed integer values to the standard output, just like the stdout.putiX routines. These routines, however, provide more control over the output; they let you specify the (minimum) number of print positions the value will require on output. These routines also let you specify a padding character should the print field be larger than the minimum needed to display the value. These routines require the following parameters:
stdout.puti8Size( Value8, width, padchar ); stdout.puti16Size( Value16, width, padchar ); stdout.puti32Size( Value32, width, padchar );
The Value* parameter can be a constant, a register, or a memory location of the specified size. The width parameter can be any signed integer constant that is between −256 and +256; this parameter may be a constant, register (32-bit), or memory location (32-bit). The padchar parameter should be a single-character value.
Like the stdout.putiX routines, these routines print the specified value as a signed integer constant to the standard output device. These routines, however, let you specify the field width for the value. The field width is the minimum number of print positions these routines will use when printing the value. The width parameter specifies the minimum field width. If the
Hello, Wo rld of Asse mbly Lang uag e 35

AAL2E_03.book Page 36 Thursday, February 18, 2010 12:49 PM
number would require more print positions (e.g., if you attempt to print 1234 with a field width of 2), then these routines will print however many characters are necessary to properly display the value. On the other hand, if the width parameter is greater than the number of character positions required to display the value, then these routines will print some extra padding characters to ensure that the output has at least width character positions. If the width value is negative, the number is left justified in the print field; if the width value is positive, the number is right justified in the print field.
If the absolute value of the width parameter is greater than the minimum number of print positions, then these stdout.putiXSize routines will print a padding character before or after the number. The padchar parameter specifies which character these routines will print. Most of the time you would specify a space as the pad character; for special cases, you might specify some other character. Remember, the padchar parameter is a character value; in HLA character constants are surrounded by apostrophes, not quotation marks. You may also specify an 8-bit register as this parameter.
Listing 1-4 provides a short HLA program that demonstrates the use of the stdout.puti32Size routine to display a list of values in tabular form.
program NumsInColumns;
#include( "stdlib.hhf" )
var i32: int32; ColCnt: int8;
begin NumsInColumns;
mov( 96, i32 ); mov( 0, ColCnt ); while( i32 > 0 ) do
if( ColCnt = 8 ) then
stdout.newln(); mov( 0, ColCnt );
endif; stdout.puti32Size( i32, 5, ' ' ); sub( 1, i32 ); add( 1, ColCnt );
endwhile; stdout.newln();
end NumsInColumns;
Listing 1-4: Tabular output demonstration using stdio.Puti32Size
36 Chapter 1

AAL2E_03.book Page 37 Thursday, February 18, 2010 12:49 PM
1.10.6 The stdout.put Routine
The stdout.put routine15 is the one of the most flexible output routines in the standard output library module. It combines most of the other output routines into a single, easy-to-use procedure.
The generic form for the stdout.put routine is the following:
stdout.put( list_of_values_to_output );
The stdout.put parameter list consists of one or more constants, registers, or memory variables, each separated by a comma. This routine displays the value associated with each parameter appearing in the list. Because we’ve already been using this routine throughout this chapter, you’ve already seen many examples of this routine’s basic form. It is worth pointing out that this routine has several additional features not apparent in the examples appearing in this chapter. In particular, each parameter can take one of the following two forms:
value value:width
The value may be any legal constant, register, or memory variable object. In this chapter, you’ve seen string constants and memory variables appearing in the stdout.put parameter list. These parameters correspond to the first form above. The second parameter form above lets you specify a minimum field width, similar to the stdout.putiXSize routines.16 The program in Listing 1-5 produces the same output as the program in Listing 1-4; however, Listing 1-5 uses stdout.put rather than stdout.puti32Size.
program NumsInColumns2;
#include( "stdlib.hhf" )
var i32: int32; ColCnt: int8;
begin NumsInColumns2;
mov( 96, i32 ); mov( 0, ColCnt ); while( i32 > 0 ) do
if( ColCnt = 8 ) then
15 stdout.put is actually a macro, not a procedure. The distinction between the two is beyond the scope of this chapter. Chapter 9 describes their differences. 16 Note that you cannot specify a padding character when using the stdout.put routine; the padding character defaults to the space character. If you need to use a different padding character, call the stdout.putiXSize routines.
Hello, Wo rld of Asse mbly Lang uag e 37

AAL2E_03.book Page 38 Thursday, February 18, 2010 12:49 PM

stdout.newln(); mov( 0, ColCnt );
endif; stdout.put( i32:5 ); sub( 1, i32 ); add( 1, ColCnt );
endwhile; stdout.put( nl );
end NumsInColumns2;
Listing 1-5: Demonstration of the stdout.put field width specification
The stdout.put routine is capable of much more than the few attributes this section describes. This text will introduce those additional capabilities as appropriate.
1.10.7 The stdin.getc Routine
The stdin.getc routine reads the next available character from the standard input device’s input buffer.17 It returns this character in the CPU’s AL register. The program in Listing 1-6 demonstrates a simple use of this routine.
program charInput;
#include( "stdlib.hhf" )
var counter: int32;
begin charInput;
// The following repeats as long as the user // confirms the repetition.
repeat
// Print out 14 values.
mov( 14, counter ); while( counter > 0 ) do
stdout.put( counter:3 ); sub( 1, counter );
endwhile;
// Wait until the user enters 'y' or 'n'.

38 Chapter 1

17 Buffer is just a fancy term for an array.

AAL2E_03.book Page 39 Thursday, February 18, 2010 12:49 PM

stdout.put( nl, nl, "Do you wish to see it again? (y/n):" ); forever
stdin.readLn(); stdin.getc(); breakif( al = 'n' ); breakif( al = 'y' ); stdout.put( "Error, please enter only 'y' or 'n': " );
endfor; stdout.newln();
until( al = 'n' );
end charInput;
Listing 1-6: Demonstration of the stdin.getc() routine
This program uses the stdin.ReadLn routine to force a new line of input from the user. A description of stdin.ReadLn appears in Section 1.10.9.
1.10.8 The stdin.getiX Routines
The stdin.geti8, stdin.geti16, and stdin.geti32 routines read 8-, 16-, and 32-bit signed integer values from the standard input device. These routines return their values in the AL, AX, or EAX register, respectively. They provide the standard mechanism for reading signed integer values from the user in HLA.
Like the stdin.getc routine, these routines read a sequence of characters from the standard input buffer. They begin by skipping over any whitespace characters (spaces, tabs, and so on) and then convert the following stream of decimal digits (with an optional leading minus sign) into the corresponding integer. These routines raise an exception (that you can trap with the try..endtry statement) if the input sequence is not a valid integer string or if the user input is too large to fit in the specified integer size. Note that values read by stdin.geti8 must be in the range −128..+127; values read by stdin.geti16 must be in the range −32,768..+32,767; and values read by stdin.geti32 must be in the range −2,147,483,648..+2,147,483,647.
The sample program in Listing 1-7 demonstrates the use of these routines.

program intInput;

#include( "stdlib.hhf" )

var i8: i16: i32:

int8; int16; int32;

begin intInput;

Hello, Wo rld of Asse mbly Lang uag e 39

AAL2E_03.book Page 40 Thursday, February 18, 2010 12:49 PM
// Read integers of varying sizes from the user:
stdout.put( "Enter a small integer between -128 and +127: " ); stdin.geti8(); mov( al, i8 );
stdout.put( "Enter a small integer between -32768 and +32767: " ); stdin.geti16(); mov( ax, i16 );
stdout.put( "Enter an integer between +/- 2 billion: " ); stdin.geti32(); mov( eax, i32 );
// Display the input values.
stdout.put (
nl, "Here are the numbers you entered:", nl, nl, "Eight-bit integer: ", i8:12, nl, "16-bit integer: ", i16:12, nl, "32-bit integer: ", i32:12, nl );
end intInput;
Listing 1-7: stdin.getiX example code
You should compile and run this program and then test what happens when you enter a value that is out of range or enter an illegal string of characters.
1.10.9 The stdin.readLn and stdin.flushInput Routines
Whenever you call an input routine like stdin.getc or stdin.geti32, the program does not necessarily read the value from the user at that moment. Instead, the HLA Standard Library buffers the input by reading a whole line of text from the user. Calls to input routines will fetch data from this input buffer until the buffer is empty. While this buffering scheme is efficient and convenient, sometimes it can be confusing. Consider the following code sequence:
stdout.put( "Enter a small integer between -128 and +127: " ); stdin.geti8(); mov( al, i8 );
stdout.put( "Enter a small integer between -32768 and +32767: " ); stdin.geti16(); mov( ax, i16 );
40 Chapter 1

AAL2E_03.book Page 41 Thursday, February 18, 2010 12:49 PM

Intuitively, you would expect the program to print the first prompt message, wait for user input, print the second prompt message, and wait for the second user input. However, this isn’t exactly what happens. For example, if you run this code (from the sample program in the previous section) and enter the text 123 456 in response to the first prompt, the program will not stop for additional user input at the second prompt. Instead, it will read the second integer (456) from the input buffer read during the execution of the stdin.geti16 call.
In general, the stdin routines read text from the user only when the input buffer is empty. As long as the input buffer contains additional characters, the input routines will attempt to read their data from the buffer. You can take advantage of this behavior by writing code sequences such as the following:

stdout.put( "Enter two integer values: " ); stdin.geti32(); mov( eax, intval ); stdin.geti32(); mov( eax, AnotherIntVal );

This sequence allows the user to enter both values on the same line (separated by one or more whitespace characters), thus preserving space on the screen. So the input buffer behavior is desirable every now and then. The buffered behavior of the input routines can be counterintuitive at other times.
Fortunately, the HLA Standard Library provides two routines, stdin.readLn and stdin.flushInput, that let you control the standard input buffer. The stdin.readLn routine discards everything that is in the input buffer and immediately requires the user to enter a new line of text. The stdin.flushInput routine simply discards everything that is in the buffer. The next time an input routine executes, the system will require a new line of input from the user. You would typically call stdin.readLn immediately before some standard input routine; you would normally call stdin.flushInput immediately after a call to a standard input routine.

NOTE

If you are calling stdin.readLn and you find that you are having to input your data twice, this is a good indication that you should be calling stdin.flushInput rather than stdin.readLn. In general, you should always be able to call stdin.flushInput to flush the input buffer and read a new line of data on the next input call. The stdin.readLn routine is rarely necessary, so you should use stdin.flushInput unless you really need to immediately force the input of a new line of text.

1.10.10 The stdin.get Routine
The stdin.get routine combines many of the standard input routines into a single call, just as the stdout.put combines all of the output routines into a single call. Actually, stdin.get is a bit easier to use than stdout.put because the only parameters to this routine are a list of variable names.

Hello, Wo rld of Asse mbly Lang uag e 41

AAL2E_03.book Page 42 Thursday, February 18, 2010 12:49 PM

Let’s rewrite the example given in the previous section:

stdout.put( "Enter two integer values: " ); stdin.geti32(); mov( eax, intval ); stdin.geti32(); mov( eax, AnotherIntVal );
Using the stdin.get routine, we could rewrite this code as:

stdout.put( "Enter two integer values: " ); stdin.get( intval, AnotherIntVal );
As you can see, the stdin.get routine is a little more convenient to use. Note that stdin.get stores the input values directly into the memory variables you specify in the parameter list; it does not return the values in a register unless you actually specify a register as a parameter. The stdin.get parameters must all be variables or registers.

1.11 Additional Details About try..endtry
As you may recall, the try..endtry statement surrounds a block of statements in order to capture any exceptions that occur during the execution of those statements. The system raises exceptions in one of three ways: through a hardware fault (such as a divide-by-zero error), through an operating system– generated exception, or through the execution of the HLA raise statement. You can write an exception handler to intercept specific exceptions using the exception clause. The program in Listing 1-8 provides a typical example of the use of this statement.

program testBadInput; #include( "stdlib.hhf" )

static u:

int32;

begin testBadInput;
try
stdout.put( "Enter a signed integer:" ); stdin.get( u ); stdout.put( "You entered: ", u, nl );
exception( ex.ConversionError )
stdout.put( "Your input contained illegal characters" nl );
exception( ex.ValueOutOfRange )

42 Chapter 1

AAL2E_03.book Page 43 Thursday, February 18, 2010 12:49 PM

stdout.put( "The value was too large" nl ); endtry;

end testBadInput;
Listing 1-8: try..endtry example
HLA refers to the statements between the try clause and the first exception clause as the protected statements. If an exception occurs within the protected statements, then the program will scan through each of the exceptions and compare the value of the current exception against the value in the parentheses after each of the exception clauses.18 This exception value is simply a 32-bit value. The value in the parentheses after each exception clause, therefore, must be a 32-bit value. The HLA excepts.hhf header file predefines several exception constants. Although it would be an incredibly bad style violation, you could substitute the numeric values for the two exception clauses above.

1.11.1 Nesting try..endtry Statements
If the program scans through all the exception clauses in a try..endtry statement and does not match the current exception value, then the program searches through the exception clauses of a dynamically nested try..endtry block in an attempt to find an appropriate exception handler. For example, consider the code in Listing 1-9.

program testBadInput2; #include( "stdlib.hhf" )

static u:

int32;

begin testBadInput2;

try

try

stdout.put( "Enter a signed integer: " ); stdin.get( u ); stdout.put( "You entered: ", u, nl );

exception( ex.ConversionError )

stdout.put( "Your input contained illegal characters" nl );

endtry;

18 Note that HLA loads this value into the EAX register. So upon entry into an exception clause, EAX contains the exception number.
Hello, Wo rld of Asse mbly Lang uag e 43

AAL2E_03.book Page 44 Thursday, February 18, 2010 12:49 PM

stdout.put( "Input did not fail due to a value out of range" nl );

44 Chapter 1

exception( ex.ValueOutOfRange )
stdout.put( "The value was too large" nl );
endtry;
end testBadInput2;
Listing 1-9: Nested try..endtry statements
In Listing 1-9 one try statement is nested inside another. During the execution of the stdin.get statement, if the user enters a value greater than four billion and some change, then stdin.get will raise the ex.ValueOutOfRange exception. When the HLA runtime system receives this exception, it first searches through all the exception clauses in the try..endtry statement immediately surrounding the statement that raised the exception (this would be the nested try..endtry in the example above). If the HLA runtime system fails to locate an exception handler for ex.ValueOutOfRange, then it checks to see if the current try..endtry is nested inside another try..endtry (as is the case in Listing 1-9). If so, the HLA runtime system searches for the appropriate exception clause in the outer try..endtry statement. Within the try..endtry block appearing in Listing 1-9 the program finds an appropriate exception handler, so control transfers to the statements after the exception( ex.ValueOutOfRange ) clause.
After leaving a try..endtry block, the HLA runtime system no longer considers that block active and will not search through its list of exceptions when the program raises an exception.19 This allows you to handle the same exception differently in other parts of the program.
If two try..endtry statements handle the same exception, and one of the try..endtry blocks is nested inside the protected section of the other try..endtry statement, and the program raises an exception while executing in the innermost try..endtry sequence, then HLA transfers control directly to the exception handler provided by the innermost try..endtry block. HLA does not automatically transfer control to the exception handler provided by the outer try..endtry sequence.
In the previous example (Listing 1-9) the second try..endtry statement was statically nested inside the enclosing try..endtry statement.20 As mentioned without comment earlier, if the most recently activated try..endtry statement does not handle a specific exception, the program will search through the exception clauses of any dynamically nesting try..endtry blocks. Dynamic nesting does not require the nested try..endtry block to physically appear within the enclosing try..endtry statement. Instead, control could transfer
19 Unless, of course, the program re-enters the try..endtry block via a loop or other control structure. 20 Statically nested means that one statement is physically nested within another in the source code. When we say one statement is nested within another, this typically means that the statement is statically nested within the other statement.

AAL2E_03.book Page 45 Thursday, February 18, 2010 12:49 PM
from inside the enclosing try..endtry protected block to some other point in the program. Execution of a try..endtry statement at that other point dynamically nests the two try statements. Although there are many ways to dynamically nest code, there is one method you are probably familiar with from your high-level language experience: the procedure call. In Chapter 5, when you learn how to write procedures (functions) in assembly language, you should keep in mind that any call to a procedure within the protected section of a try..endtry block can create a dynamically nested try..endtry if the program executes a try..endtry within that procedure.
1.11.2 The unprotected Clause in a try..endtry Statement
Whenever a program executes the try clause, it preserves the current exception environment and sets up the system to transfer control to the exception clauses within that try..endtry statement should an exception occur. If the program successfully completes the execution of a try..endtry protected block, the program restores the original exception environment and control transfers to the first statement beyond the endtry clause. This last step, restoring the execution environment, is very important. If the program skips this step, any future exceptions will transfer control to this try..endtry statement even though the program has already left the try..endtry block. Listing 1-10 demonstrates this problem.
program testBadInput3; #include( "stdlib.hhf" )
static input: int32;
begin testBadInput3;
// This forever loop repeats until the user enters // a good integer and the break statement below // exits the loop.
forever
try
stdout.put( "Enter an integer value: " ); stdin.get( input ); stdout.put( "The first input value was: ", input, nl ); break;
exception( ex.ValueOutOfRange )
stdout.put( "The value was too large, re-enter." nl );
exception( ex.ConversionError )
stdout.put( "The input contained illegal characters, re-enter." nl );
Hello, Wo rld of Asse mbly Lang uag e 45

AAL2E_03.book Page 46 Thursday, February 18, 2010 12:49 PM
endtry;
endfor;
// Note that the following code is outside the loop and there // is no try..endtry statement protecting this code.
stdout.put( "Enter another number: " ); stdin.get( input ); stdout.put( "The new number is: ", input, nl );
end testBadInput3;
Listing 1-10: Improperly exiting a try..endtry statement
This example attempts to create a robust input system by putting a loop around the try..endtry statement and forcing the user to reenter the data if the stdin.get routine raises an exception (because of bad input data). While this is a good idea, there is a big problem with this implementation: the break statement immediately exits the forever..endfor loop without first restoring the exception environment. Therefore, when the program executes the second stdin.get statement, at the bottom of the program, the HLA exception-handling code still thinks that it’s inside the try..endtry block. If an exception occurs, HLA transfers control back into the try..endtry statement looking for an appropriate exception handler. Assuming the exception was ex.ValueOutOfRange or ex.ConversionError, the program in Listing 1-10 will print an appropriate error message and then force the user to re-enter the first value. This isn’t desirable.
Transferring control to the wrong try..endtry exception handlers is only part of the problem. Another big problem with the code in Listing 1-10 has to do with the way HLA preserves and restores the exception environment: specifically, HLA saves the old execution environment information in a special region of memory known as the stack. If you exit a try..endtry without restoring the exception environment, this leaves the old execution environment information on the stack, and this extra data on could cause your program to malfunction.
Although this discussion makes it quite clear that a program should not exit from a try..endtry statement in the manner that Listing 1-10 uses, it would be nice if you could use a loop around a try..endtry block to force the reentry of bad data as this program attempts to do. To allow for this, HLA’s try..endtry statement provides an unprotected section. Consider the code in Listing 1-11.
program testBadInput4; #include( "stdlib.hhf" )
static input: int32;
begin testBadInput4;
46 Chapter 1

AAL2E_03.book Page 47 Thursday, February 18, 2010 12:49 PM
// This forever loop repeats until the user enters // a good integer and the break statement below // exits the loop. Note that the break statement // appears in an unprotected section of the try..endtry // statement.
forever
try
stdout.put( "Enter an integer value: " ); stdin.get( input ); stdout.put( "The first input value was: ", input, nl );
unprotected
break;
exception( ex.ValueOutOfRange )
stdout.put( "The value was too large, re-enter." nl );
exception( ex.ConversionError )
stdout.put( "The input contained illegal characters, re-enter." nl );
endtry;
endfor;
// Note that the following code is outside the loop and there // is no try..endtry statement protecting this code.
stdout.put( "Enter another number: " ); stdin.get( input ); stdout.put( "The new number is: ", input, nl );
end testBadInput4;
Listing 1-11: The try..endtry unprotected section
Whenever the try..endtry statement hits the unprotected clause, it immediately restores the exception environment. As the phrase suggests, the execution of statements in the unprotected section is no longer protected by that try..endtry block (note, however, that any dynamically nesting try..endtry statements will still be active; unprotected turns off only the exception handling of the try..endtry statement containing the unprotected clause). Because the break statement in Listing 1-11 appears inside the unprotected section, it can safely transfer control out of the try..endtry block without “executing” the endtry because the program has already restored the former exception environment.
Hello, Wo rld of Asse mbly Lang uag e 47

AAL2E_03.book Page 48 Thursday, February 18, 2010 12:49 PM
Note that the unprotected keyword must appear in the try..endtry statement immediately after the protected block. That is, it must precede all exception keywords.
If an exception occurs during the execution of a try..endtry sequence, HLA automatically restores the execution environment. Therefore, you may execute a break statement (or any other instruction that transfers control out of the try..endtry block) within an exception clause.
Because the program restores the exception environment upon encountering an unprotected block or an exception block, an exception that occurs within one of these areas immediately transfers control to the previous (dynamically nesting) active try..endtry sequence. If there is no nesting try..endtry sequence, the program aborts with an appropriate error message.
1.11.3 The anyexception Clause in a try..endtry Statement
In a typical situation, you will use a try..endtry statement with a set of exception clauses that will handle all possible exceptions that can occur in the protected section of the try..endtry sequence. Often, it is important to ensure that a try..endtry statement handles all possible exceptions to prevent the program from prematurely aborting due to an unhandled exception. If you have written all the code in the protected section, you will know the exceptions it can raise, so you can handle all possible exceptions. However, if you are calling a library routine (especially a third-party library routine), making a OS API call, or otherwise executing code that you have no control over, it may not be possible for you to anticipate all possible exceptions this code could raise (especially when considering past, present, and future versions of the code). If that code raises an exception for which you do not have an exception clause, this could cause your program to fail. Fortunately, HLA’s try..endtry statement provides the anyexception clause that will automatically trap any exception the existing exception clauses do not handle.
The anyexception clause is similar to the exception clause except it does not require an exception number parameter (because it handles any exception). If the anyexception clause appears in a try..endtry statement with other exception sections, the anyexception section must be the last exception handler in the try..endtry statement. An anyexception section may be the only exception handler in a try..endtry statement.
If an otherwise unhandled exception transfers control to an anyexception section, the EAX register will contain the exception number. Your code in the anyexception block can test this value to determine the cause of the exception.
1.11.4 Registers and the try..endtry Statement
The try..endtry statement preserves several bytes of data whenever you enter a try..endtry statement. Upon leaving the try..endtry block (or hitting the unprotected clause), the program restores the exception environment. As long as no exception occurs, the try..endtry statement does not affect the
48 Chapter 1

AAL2E_03.book Page 49 Thursday, February 18, 2010 12:49 PM
values of any registers upon entry to or upon exit from the try..endtry statement. However, this claim is not true if an exception occurs during the execution of the protected statements.
Upon entry into an exception clause, the EAX register contains the exception number, but the values of all other general-purpose registers are undefined. Because the operating system may have raised the exception in response to a hardware error (and, therefore, has played around with the registers), you can’t even assume that the general-purpose registers contain whatever values they happened to contain at the point of the exception. The underlying code that HLA generates for exceptions is subject to change in different versions of the compiler, and certainly it changes across operating systems, so it is never a good idea to experimentally determine what values registers contain in an exception handler and depend on those values in your code.
Because entry into an exception handler can scramble the register values, you must ensure that you reload important registers if the code following your endtry clause assumes that the registers contain certain values (i.e., values set in the protected section or values set prior to executing the try..endtry statement). Failure to do so will introduce some nasty defects into your program (and these defects may be very intermittent and difficult to detect because exceptions rarely occur and may not always destroy the value in a particular register). The following code fragment provides a typical example of this problem and its solution:
static sum: int32; . . . mov( 0, sum ); for( mov( 0, ebx ); ebx < 8; inc( ebx )) do
push( ebx ); // Must preserve ebx in case there is an exception. forever
try
stdin.geti32(); unprotected break;
exception( ex.ConversionError )
stdout.put( "Illegal input, please re-enter value: " );
endtry; endfor; pop( ebx ); // Restore ebx's value. add( ebx, eax ); add( eax, sum );
endfor;
Hello, Wo rld of Asse mbly Lang uag e 49

AAL2E_03.book Page 50 Thursday, February 18, 2010 12:49 PM
Because the HLA exception-handling mechanism messes with the registers, and because exception handling is a relatively inefficient process, you should never use the try..endtry statement as a generic control structure (e.g., using it to simulate a switch/case statement by raising an integer exception value and using the exception clauses as the cases to process). Doing so will have a very negative impact on the performance of your program and may introduce subtle defects because exceptions scramble the registers.
For proper operation, the try..endtry statement assumes that you use the EBP register only to point at activation records (Chapter 5 discusses activation records). By default, HLA programs automatically use EBP for this purpose; as long as you do not modify the value in EBP, your programs will automatically use EBP to maintain a pointer to the current activation record. If you attempt to use the EBP register as a general-purpose register to hold values and compute arithmetic results, HLA’s exception-handling capabilities will no longer function properly (along with other possible problems). Therefore, you should never use the EBP register as a generalpurpose register. Of course, this same discussion applies to the ESP register.
1.12 High-Level Assembly Language vs. Low-Level Assembly Language
Before concluding this chapter, it’s important to remind you that none of the control statements appearing in this chapter are “real” assembly language. The 80x86 CPU does not support machine instructions like if, while, repeat, for, break, breakif, and try. Whenever HLA encounters these statements, it compiles them into a sequence of one or more true machine instructions that do the operation as the high-level statements you’ve used. While these statements are convenient to use, and in many cases just as efficient as the sequence of low-level machine instructions into which HLA translates them, don’t lose sight of the fact that they are not true machine instructions.
The purpose of this text is to teach you low-level assembly language programming; these high-level control structures are simply a means to that end. Remember, learning the HLA high-level control structures allows you to leverage your high-level language knowledge early on in the educational process so you don’t have to learn everything about assembly language all at once. By using high-level control structures that you’re already comfortable with, this text can put off the discussion of the actual machine instructions you’d normally use for control flow until much later. By doing so, this text can regulate how much material it presents, so, hopefully, you’ll find learning assembly language to be much more pleasant. However, you must always remember that these high-level control statements are just a pedagogical tool to help you learn assembly language. Though you’re free to use them in your assembly programs once you master the real control-flow statements, you really must learn the low-level control statements if you want to learn assembly language programming. Since, presumably, that’s why you’re reading this
50 Chapter 1

AAL2E_03.book Page 51 Thursday, February 18, 2010 12:49 PM
book, don’t allow the high-level control structures to become a crutch. When you get to the point where you learn how to really write low-level control statements, embrace and use them (exclusively). As you gain experience with the low-level control statements and learn their advantages and disadvantages, you’ll be in a good position to decide whether a high-level or low-level code sequence is most appropriate for a given application. However, until you gain considerable experience with the low-level control structures, you’ll not be able to make an educated decision. Remember, you can’t really call yourself an assembly language programmer unless you’ve mastered the low-level statements.
Another thing to keep in mind is that the HLA Standard Library functions are not part of the assembly language. They’re just some convenient functions that have been prewritten for you. Although there is nothing wrong with calling these functions, always remember that they are not machine instructions and that there is nothing special about these routines; as you gain experience writing assembly language code, you can write your own versions of each of these routines (and even write them more efficiently).
If you’re learning assembly language because you want to write the most efficient programs possible (either the fastest or the smallest code), you need to understand that you won’t achieve this goal completely if you’re using high-level control statements and making a lot of calls to the HLA Standard Library. HLA’s code generator and the HLA Standard Library aren’t horribly inefficient, but the only true way to write efficient programs in assembly language is to think in assembly language. HLA’s high-level control statements and many of the routines in the HLA Standard Library are great because they let you avoid thinking in assembly language. While this is great while you’re first learning assembly, if your ultimate goal is to write efficient code, then you have to learn to think in assembly language. This text will get you to that point (and will do so much more rapidly because it uses HLA’s highlevel features), but don’t forget that your ultimate goal is to give up these high-level features in favor of low-level coding.
1.13 For More Information
This chapter has covered a lot of ground! While you still have a lot to learn about assembly language programming, this chapter, combined with your knowledge of high-level languages, provides just enough information to let you start writing real assembly language programs.
Although this chapter has covered many different topics, the three primary topics of interest are the 80x86 CPU architecture, the syntax for simple HLA programs, and the HLA Standard Library. For additional topics on this subject, please consult the (unabridged) electronic version of this text, the HLA reference manual, and the HLA Standard Library manual. All three are available at http://www.artofasm.com/ and http://webster.cs.ucr.edu/.
Hello, Wo rld of Asse mbly Lang uag e 51

AAL2E_03.book Page 52 Thursday, February 18, 2010 12:49 PM

AAL2E_03.book Page 53 Thursday, February 18, 2010 12:49 PM
2
DATA REPRESENTATION
A major stumbling block many beginners encounter when attempting to learn assembly language is the common use of the binary and hexadecimal numbering systems. Although hexadecimal numbers are a little strange, their advantages outweigh their disadvantages
by a large margin. Understanding the binary and hexadecimal numbering systems is important because their use simplifies the discussion of other topics, including bit operations, signed numeric representation, character codes, and packed data.
This chapter discusses several important concepts, including: z The binary and hexadecimal numbering systems z Binary data organization (bits, nibbles, bytes, words, and double words) z Signed and unsigned numbering systems

AAL2E_03.book Page 54 Thursday, February 18, 2010 12:49 PM
z Arithmetic, logical, shift, and rotate operations on binary values z Bit fields and packed data
This is basic material, and the remainder of this text depends on your understanding these concepts. If you are already familiar with these terms from other courses or study, you should at least skim this material before proceeding to the next chapter. If you are unfamiliar with this material, or only vaguely familiar with it, you should study it carefully before proceeding. All of the material in this chapter is important! Do not skip over any material.
2.1 Numbering Systems
Most modern computer systems do not represent numeric values using the decimal (base-10) system. Instead, they typically use a binary or two’s complement numbering system.
2.1.1 A Review of the Decimal System
You’ve been using the decimal numbering system for so long that you probably take it for granted. When you see a number like 123, you don’t think about the value 123; rather, you generate a mental image of how many items this value represents. In reality, however, the number 123 represents:
1*102 + 2*101 + 3*100
or
100 + 20 + 3
In a decimal positional numbering system, each digit appearing to the left of the decimal point represents a value between 0 and 9 times an increasing power of 10. Digits appearing to the right of the decimal point represent a value between 0 and 9 times an increasing negative power of 10. For example, the value 123.456 means:
1*102 + 2*101 + 3*100 + 4*10−1 + 5*10−2 + 6*10−3
or
100 + 20 + 3 + 0.4 + 0.05 + 0.006
2.1.2 The Binary Numbering System
Most modern computer systems operate using binary logic. The computer represents values using two voltage levels (usually 0v and +2.4..5v). Two such levels can represent exactly two unique values. These could be any two different values, but they typically represent the values 0 and 1. These values, coincidentally, correspond to the two digits in the binary numbering system.
54 Chapter 2

AAL2E_03.book Page 55 Thursday, February 18, 2010 12:49 PM
The binary numbering system works just like the decimal numbering system, with two exceptions: Binary allows only the digits 0 and 1 (rather than 0..9), and binary uses powers of 2 rather than powers of 10. Therefore, it is very easy to convert a binary number to decimal. For each 1 in the binary string, add in 2n where n is the zero-based position of the binary digit. For example, the binary value 110010102 represents:
1*27 + 1*26 + 0*25 + 0*24 + 1*23 + 0*22 + 1*21 + 0*20 = 128 + 64 + 8 + 2 = 20210
To convert decimal to binary is slightly more difficult. You must find those powers of 2 that, when added together, produce the decimal result.
A simple way to convert decimal to binary is the even/odd - divide by two algorithm. This algorithm uses the following steps:
1. If the number is even, emit a 0. If the number is odd, emit a 1. 2. Divide the number by 2 and throw away any fractional component or
remainder. 3. If the quotient is 0, the algorithm is complete. 4. If the quotient is not 0 and is odd, insert a 1 before the current string; if
the number is even, prefix your binary string with 0. 5. Go back to step 2 and repeat.
Binary numbers, although they have little importance in high-level languages, appear everywhere in assembly language programs. So you should be somewhat comfortable with them.
2.1.3 Binary Formats
In the purest sense, every binary number contains an infinite number of digits (or bits, which is short for binary digits). For example, we can represent the number 5 by any of the following:
101 00000101 0000000000101 ...000000000000101
Any number of leading zero digits may precede the binary number without changing its value.
We will adopt the convention of ignoring any leading zeros present in a value. For example, 1012 represents the number 5 but because the 80x86 typically works with groups of 8 bits, we’ll find it much easier to zero extend all binary numbers to some multiple of 4 or 8 bits. Therefore, following this convention, we’d represent the number 5 as 01012 or 000001012.
In the United States, most people separate every three digits with a comma to make larger numbers easier to read. For example, 1,023,435,208 is much easier to read and comprehend than 1023435208. We’ll adopt a
Data Re pre sen tat io n 55

AAL2E_03.book Page 56 Thursday, February 18, 2010 12:49 PM
similar convention in this text for binary numbers. We will separate each group of four binary bits with an underscore. For example, we will write the binary value 1010111110110010 as 1010_1111_1011_0010.
We’ll number each bit as follows:
1. The rightmost bit in a binary number is bit position 0. 2. Each bit to the left is given the next successive bit number.
An 8-bit binary value uses bits 0..7:
X7 X6 X5 X4 X3 X2 X1 X0
A 16-bit binary value uses bit positions 0..15:
X15 X14 X13 X12 X11 X10 X9 X8 X7 X6 X5 X4 X3 X2 X1 X0
A 32-bit binary value uses bit positions 0..31, and so on. Bit 0 is the low-order (L.O.) bit (some refer to this as the least significant bit). The leftmost bit is called the high-order (H.O.) bit (or the most significant bit). We’ll refer to the intermediate bits by their respective bit numbers.
2.2 The Hexadecimal Numbering System
Unfortunately, binary numbers are verbose. To represent the value 20210 requires eight binary digits. The decimal version requires only three decimal digits and thus represents numbers much more compactly than in binary. This fact is not lost on the engineers who design binary computer systems. When dealing with large values, binary numbers quickly become unwieldy. Unfortunately, the computer “thinks” in binary, so most of the time it is convenient to use the binary numbering system. Although we can convert between decimal and binary, the conversion is not a trivial task. The hexadecimal (base 16) numbering system solves many of the problems inherent in the binary system. Hexadecimal numbers offer the two features we’re looking for: They’re very compact, and it’s simple to convert them to binary and vice versa. For this reason, most engineers use the hexadecimal numbering system.
Because the radix (base) of a hexadecimal number is 16, each hexadecimal digit to the left of the hexadecimal point represents some value times a successive power of 16. For example, the number 123416 is equal to:
1*163 + 2*162 + 3*161 + 4*160
or
4096 + 512 + 48 + 4 = 466010
Each hexadecimal digit can represent one of 16 values between 0 and 1510. Because there are only 10 decimal digits, we need to invent 6 additional digits to represent the values in the range 1010..1510. Rather than create new
56 Chapter 2

AAL2E_03.book Page 57 Thursday, February 18, 2010 12:49 PM

symbols for these digits, we’ll use the letters A..F. The following are all examples of valid hexadecimal numbers:

123416 DEAD16 BEEF16 0AFB16 FEED16 DEAF16
Because we’ll often need to enter hexadecimal numbers into the computer system, we’ll need a different mechanism for representing hexadecimal numbers. After all, on most computer systems you cannot enter a subscript to denote the radix of the associated value. We’ll adopt the following conventions:
z All hexadecimal values begin with a $ character; for example, $123A4. z All binary values begin with a percent sign (%). z Decimal numbers do not have a prefix character. z If the radix is clear from the context, this book may drop the leading $ or
% character.
Here are some examples of valid hexadecimal numbers:

$1234 $DEAD $BEEF $AFB $FEED $DEAF

As you can see, hexadecimal numbers are compact and easy to read. In addition, you can easily convert between hexadecimal and binary. Consider Table 2-1. This table provides all the information you’ll ever need to convert any hexadecimal number into a binary number or vice versa.

.Table 2-1: Binary/Hexadecimal Conversion

Binary
%0000 %0001 %0010 %0011 %0100 %0101 %0110 %0111 %1000 %1001 %1010 %1011 %1100 %1101 %1110 %1111

Hexadecimal
$0 $1 $2 $3 $4 $5 $6 $7 $8 $9 $A $B $C $D $E $F

Data Re pre sen tat io n 57

AAL2E_03.book Page 58 Thursday, February 18, 2010 12:49 PM

To convert a hexadecimal number into a binary number, simply substitute the corresponding 4 bits for each hexadecimal digit in the number. For example, to convert $ABCD into a binary value, simply convert each hexadecimal digit according to Table 2-1, as shown here:

A

B

C

D

Hexadecimal

1010 1011 1100 1101 Binary

To convert a binary number into hexadecimal format is almost as easy. The first step is to pad the binary number with zeros to make sure that there is a multiple of 4 bits in the number. For example, given the binary number 1011001010, the first step would be to add 2 bits to the left of the number so that it contains 12 bits. The converted binary value is 001011001010. The next step is to separate the binary value into groups of 4 bits, for example, 0010_1100_1010. Finally, look up these binary values in Table 2-1 and substitute the appropriate hexadecimal digits, that is, $2CA. Contrast this with the difficulty of conversion between decimal and binary or decimal and hexadecimal!
Because converting between hexadecimal and binary is an operation you will need to perform over and over again, you should take a few minutes and memorize the conversion table. Even if you have a calculator that will do the conversion for you, you’ll find manual conversion to be a lot faster and more convenient when converting between binary and hex.

2.3 Data Organization
In pure mathematics a value’s representation may take require an arbitrary number of bits. Computers, on the other hand, generally work with some specific number of bits. Common collections are single bits, groups of 4 bits (called nibbles), groups of 8 bits (bytes), groups of 16 bits (words), groups of 32 bits (double words or dwords), groups of 64 bits (quad words or qwords), groups of 128 bits (long words or lwords), and more. The sizes are not arbitrary. There is a good reason for these particular values. This section will describe the bit groups commonly used on the Intel 80x86 chips.

58 Chapter 2

2.3.1 Bits
The smallest unit of data on a binary computer is a single bit. With a single bit, you can represent any two distinct items. Examples include 0 or 1, true or false, on or off, male or female, and right or wrong. However, you are not limited to representing binary data types (that is, those objects that have only two distinct values). You could use a single bit to represent the numbers 723 and 1,245 or, perhaps, the values 6,254 and 5. You could also use a single bit to represent the colors red and blue. You could even represent two unrelated objects with a single bit. For example, you could represent the color red and the number 3,256 with a single bit. You can represent any two different values with a single bit. However, you can represent only two different values with a single bit.

AAL2E_03.book Page 59 Thursday, February 18, 2010 12:49 PM
To confuse things even more, different bits can represent different things. For example, you could use one bit to represent the values 0 and 1, while a different bit could represent the values true and false. How can you tell by looking at the bits? The answer, of course, is that you can’t. But this illustrates the whole idea behind computer data structures: data is what you define it to be. If you use a bit to represent a boolean (true/false) value, then that bit (by your definition) represents true or false. For the bit to have any real meaning, you must be consistent. If you’re using a bit to represent true or false at one point in your program, you shouldn’t use that value to represent red or blue later.
Because most items you’ll be trying to model require more than two different values, single-bit values aren’t the most popular data type you’ll use. However, because everything else consists of groups of bits, bits will play an important role in your programs. Of course, there are several data types that require two distinct values, so it would seem that bits are important by themselves. However, you will soon see that individual bits are difficult to manipulate, so we’ll often use other data types to represent two-state values.
2.3.2 Nibbles
A nibble is a collection of 4 bits. It wouldn’t be a particularly interesting data structure except for two facts: binary-coded decimal (BCD) numbers1 and hexadecimal numbers. It takes 4 bits to represent a single BCD or hexadecimal digit. With a nibble, we can represent up to 16 distinct values because there are 16 unique combinations of a string of 4 bits:
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
In the case of hexadecimal numbers, the values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are represented with 4 bits. BCD uses 10 different digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) and requires also 4 bits (because we can only represent 8 different values with 3 bits, the additional 6 values we can represent
1 Binary-coded decimal is a numeric scheme used to represent decimal numbers using 4 bits for each decimal digit.
Data Re pre sen tat io n 59

AAL2E_03.book Page 60 Thursday, February 18, 2010 12:49 PM

with 4 bits are never used in BCD representation). In fact, any 16 distinct values can be represented with a nibble, though hexadecimal and BCD digits are the primary items we can represent with a single nibble.
2.3.3 Bytes
Without question, the most important data structure used by the 80x86 microprocessor is the byte, which consists of 8 bits. Main memory and I/O addresses on the 80x86 are all byte addresses. This means that the smallest item that can be individually accessed by an 80x86 program is an 8-bit value. To access anything smaller requires that we read the byte containing the data and eliminate the unwanted bits. The bits in a byte are normally numbered from 0 to 7, as shown in Figure 2-1.
76543210

Figure 2-1: Bit numbering
Bit 0 is the low-order bit or least significant bit, and bit 7 is the high-order bit or most significant bit of the byte. We’ll refer to all other bits by their number.
Note that a byte also contains exactly two nibbles (see Figure 2-2).
76543210

H.O. Nibble

L.O. Nibble

Figure 2-2: The two nibbles in a byte

Bits 0..3 compose the low-order nibble, and bits 4..7 form the high-order nibble. Because a byte contains exactly two nibbles, byte values require two hexadecimal digits.
Because a byte contains 8 bits, it can represent 28 (256) different values. Generally, we’ll use a byte to represent numeric values in the range 0..255, signed numbers in the range −128..+127 (see Section 2.8), ASCII/IBM character codes, and other special data types requiring no more than 256 different values. Many data types have fewer than 256 items, so 8 bits is usually sufficient.
Because the 80x86 is a byte-addressable machine, it turns out to be more efficient to manipulate a whole byte than an individual bit or nibble. For this reason, most programmers use a whole byte to represent data types that require no more than 256 items, even if fewer than 8 bits would suffice. For example, we’ll often represent the boolean values true and false by 000000012 and 000000002, respectively.
Probably the most important use for a byte is holding a character value. Characters typed at the keyboard, displayed on the screen, and printed on the printer all have numeric values. To communicate with the rest of the

60 Chapter 2

AAL2E_03.book Page 61 Thursday, February 18, 2010 12:49 PM

world, PCs typically use a variant of the ASCII character set. There are 128 defined codes in the ASCII character set.
Because bytes are the smallest unit of storage in the 80x86 memory space, bytes also happen to be the smallest variable you can create in an HLA program. As you saw in the last chapter, you can declare an 8-bit signed integer variable using the int8 data type. Because int8 objects are signed, you can represent values in the range −128..+127 using an int8 variable. You should only store signed values into int8 variables; if you want to create an arbitrary byte variable, you should use the byte data type, as follows:

static

byteVar: byte;

The byte data type is a partially untyped data type. The only type information associated with a byte object is its size (1 byte). You may store any 8-bit value (small signed integers, small unsigned integers, characters, and the like) into a byte variable. It is up to you to keep track of the type of object you’ve put into a byte variable.

2.3.4 Words
A word is a group of 16 bits. We’ll number the bits in a word from 0 to 15, as Figure 2-3 shows. Like the byte, bit 0 is the low-order bit. For words, bit 15 is the high-order bit. When referencing the other bits in a word, we’ll use their bit position number.
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

Figure 2-3: Bit numbers in a word
Notice that a word contains exactly 2 bytes. Bits 0..7 form the low-order byte, and bits 8..15 form the high-order byte (see Figure 2-4).
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

H.O. Byte
i
Figure 2-4: The two bytes in a word

L.O. Byte

Of course, a word may be further broken down into four nibbles, as shown in Figure 2-5. Nibble 0 is the low-order nibble in the word, and nibble 3 is the high-order nibble of the word. We’ll simply refer to the other two nibbles as nibble 1 or nibble 2.

Data Re pre sen tat io n 61

AAL2E_03.book Page 62 Thursday, February 18, 2010 12:49 PM

15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

Nibble 3 H.O. Nibble

Nibble 2

Figure 2-5: Nibbles in a word

Nibble 1

Nibble 0 L.O. Nibble
o

With 16 bits, you can represent 216 (65,536) different values. These could be the values in the range 0..65,535 or, as is usually the case, the signed values −32,768..+32,767, or any other data type with no more than 65,536 values. The three major uses for words are short signed integer values, short unsigned integer values, and Unicode characters.
Words can represent integer values in the range 0..65,535 or −32,768..32,767. Unsigned numeric values are represented by the binary value corresponding to the bits in the word. Signed numeric values use the two’s complement form for numeric values (see Section 2.8). As Unicode characters, words can represent up to 65,536 different characters, allowing the use of non-Roman character sets in a computer program. Unicode is an international standard, like ASCII, that allows computers to process nonRoman characters such as Asian, Greek, and Russian characters.
As with bytes, you can also create word variables in an HLA program. Of course, in the last chapter you saw how to create 16-bit signed integer variables using the int16 data type. To create an arbitrary word variable, just use the word data type, as follows:

static

w: word;

2.3.5 Double Words

A double word is exactly what its name implies, a pair of words. Therefore, a double-word quantity is 32 bits long, as shown in Figure 2-6.

31

23

15

7

0

Figure 2-6: Bit numbers in a double word
Naturally, this double word can be divided into a high-order word and a low-order word, four different bytes, or eight different nibbles (see Figure 2-7).
Double words (dwords) can represent all kinds of different things. A common item you will represent with a double word is a 32-bit integer value (that allows unsigned numbers in the range 0..4,294,967,295 or signed numbers in the range −2,147,483,648..2,147,483,647). 32-bit floating-point values also fit into a double word. Another common use for double-word objects is to store pointer values.

62 Chapter 2

AAL2E_03.book Page 63 Thursday, February 18, 2010 12:49 PM

31

23

H.O. Word

15

7

0

L.O. Word

31

23

H.O. Byte

Byte 2

15 Byte 1

7

0

L.O. Byte

31

23

15

7

0

Nibble 7

6

5

4

3

2

1

0

H.O.

L.O.

Figure 2-7: Nibbles, bytes, and words in a double word

In Chapter 1, you saw how to create 32-bit signed integer variables using the int32 data type. You can also create an arbitrary double-word variable using the dword data type, as the following example demonstrates:

static

d: dword;

2.3.6 Quad Words and Long Words
Obviously, we can keep on defining larger and larger word sizes. However, the 80x86 supports only certain native sizes, so there is little reason to keep on defining terms for larger and larger objects. Although bytes, words, and double words are the most common sizes you’ll find in 80x86 programs, quad word (64-bit) values are also important because certain floating-point data types require 64 bits. Likewise, the SSE/MMX instruction set of modern 80x86 processors can manipulate 64-bit values. In a similar vein, long-word (128-bit) values are also important because the SSE instruction set on later 80x86 processors can manipulate 128-bit values. HLA allows the declaration of 64- and 128-bit values using the qword and lword types, as follows:

static q l

:qword; :lword;

Note that you may also define 64-bit and 128-bit integer values using HLA declarations like the following:

static i64 i128

:int64; :int128;

Data Re pre sen tat io n 63

AAL2E_03.book Page 64 Thursday, February 18, 2010 12:49 PM

However, you may not directly manipulate 64-bit and 128-bit integer objects using standard instructions like mov, add, and sub because the standard 80x86 integer registers process only 32 bits at a time. In Chapter 8, you will see how to manipulate these extended-precision values.

2.4 Arithmetic Operations on Binary and Hexadecimal Numbers
There are several operations we can perform on binary and hexadecimal numbers. For example, we can add, subtract, multiply, divide, and perform other arithmetic operations. Although you needn’t become an expert at it, you should be able to, in a pinch, perform these operations manually using a piece of paper and a pencil. Having just said that you should be able to perform these operations manually, the correct way to perform such arithmetic operations is to have a calculator that does them for you. There are several such calculators on the market; the following list shows some of the manufacturers of hexadecimal calculators (in 2010):
z Casio
z Hewlett-Packard
z Sharp
z Texas Instruments
This list is by no means exhaustive. Other calculator manufacturers probably produce these devices as well. The Hewlett-Packard devices are arguably the best of the bunch. However, they are more expensive than the others. Sharp and Casio produce units that sell for well under fifty dollars. If you plan on doing any assembly language programming at all, owning one of these calculators is essential.
To understand why you should spend the money on a calculator, consider the following arithmetic problem:

64 Chapter 2

$9 + $1 ----
You’re probably tempted to write in the answer $10 as the solution to this problem. But that is not correct! The correct answer is 10, which is $A, not 16, which is $10. A similar problem exists with the following subtraction problem:
$10 - $1 ----
You’re probably tempted to answer $9 even though the correct answer is $F. Remember, this problem is asking, “What is the difference between 16 and 1?” The answer, of course, is 15, which is $F.
Even if these two problems don’t bother you, in a stressful situation your brain will switch back into decimal while you’re thinking about something

AAL2E_03.book Page 65 Thursday, February 18, 2010 12:49 PM

else and you’ll produce the incorrect result. Moral of the story—if you must do an arithmetic computation using hexadecimal numbers by hand, take your time and be careful about it. Either that, or convert the numbers to decimal, perform the operation in decimal, and convert them back to hexadecimal.

2.5 A Note About Numbers vs. Representation
Many people confuse numbers and their representation. A common question beginning assembly language students ask is, “I have a binary number in the EAX register; how do I convert that to a hexadecimal number in the EAX register?” The answer is, “You don’t.” Although a strong argument could be made that numbers in memory or in registers are represented in binary, it’s best to view values in memory or in a register as abstract numeric quantities. Strings of symbols like 128, $80, or %1000_0000 are not different numbers; they are simply different representations for the same abstract quantity that we refer to as “one hundred twenty-eight.” Inside the computer, a number is a number regardless of representation; the only time representation matters is when you input or output the value in a human-readable form.
Human-readable forms of numeric quantities are always strings of characters. To print the value 128 in human-readable form, you must convert the numeric value 128 to the three-character sequence 1 followed by 2 followed by 8. This would provide the decimal representation of the numeric quantity. If you prefer, you could convert the numeric value 128 to the threecharacter sequence $80. It’s the same number, but we’ve converted it to a different sequence of characters because (presumably) we wanted to view the number using hexadecimal representation rather than decimal. Likewise, if we want to see the number in binary, then we must convert this numeric value to a string containing a 1 followed by seven 0s.
By default, HLA displays all byte, word, dword, qword, and lword variables using the hexadecimal numbering system when using the stdout.put routine. Likewise, HLA’s stdout.put routine will display all register values in hexadecimal form. Consider the program in Listing 2-1, which converts values input as decimal numbers to their hexadecimal equivalents.

program ConvertToHex; #include( "stdlib.hhf" ) static
value: int32;

begin ConvertToHex;

stdout.put( "Input a decimal value:" ); stdin.get( value ); mov( value, eax ); stdout.put( "The value ", value, " converted to hex is $", eax, nl );

end ConvertToHex;

Listing 2-1: Decimal-to-hexadecimal conversion program

Data Re pre sen tat io n 65

AAL2E_03.book Page 66 Thursday, February 18, 2010 12:49 PM

66 Chapter 2

In a similar fashion, the default input base is also hexadecimal for registers and byte, word, dword, qword, or lword variables. The program in Listing 2-2 is the converse of the one in Listing 2-1; it inputs a hexadecimal value and outputs it as decimal.
program ConvertToDecimal; #include( "stdlib.hhf" ) static
value: int32;
begin ConvertToDecimal;
stdout.put( "Input a hexadecimal value: " ); stdin.get( ebx ); mov( ebx, value ); stdout.put( "The value $", ebx, " converted to decimal is ", value, nl );
end ConvertToDecimal;
Listing 2-2: Hexadecimal-to-decimal conversion program
Just because the HLA stdout.put routine chooses decimal as the default output base for int8, int16, and int32 variables doesn’t mean that these variables hold decimal numbers. Remember, memory and registers hold numeric values, not hexadecimal or decimal values. The stdout.put routine converts these numeric values to strings and prints the resulting strings. The choice of hexadecimal versus decimal output was a design choice in the HLA language, nothing more. You could very easily modify HLA so that it outputs registers and byte, word, dword, qword, or lword variables as decimal values rather than as hexadecimal. If you need to print the value of a register or byte, word, or dword variable as a decimal value, simply call one of the putiX routines to do this. The stdout.puti8 routine will output its parameter as an 8-bit signed integer. Any 8-bit parameter will work. So you could pass an 8-bit register, an int8 variable, or a byte variable as the parameter to stdout.puti8 and the result will always be decimal. The stdout.puti16 and stdout.puti32 routines provide the same capabilities for 16-bit and 32-bit objects. The program in Listing 2-3 demonstrates the decimal conversion program (Listing 2-2) using only the EBX register (that is, it does not use the variable iValue).
program ConvertToDecimal2; #include( "stdlib.hhf" ) begin ConvertToDecimal2;
stdout.put( "Input a hexadecimal value: " ); stdin.get( ebx ); stdout.put( "The value $", ebx, " converted to decimal is " ); stdout.puti32( ebx ); stdout.newln();
end ConvertToDecimal2;
Listing 2-3: Variable-less hexadecimal-to-decimal converter

AAL2E_03.book Page 67 Thursday, February 18, 2010 12:49 PM
Note that HLA’s stdin.get routine uses the same default base for input as stdout.put uses for output. That is, if you attempt to read an int8, int16, or int32 variable, the default input base is decimal. If you attempt to read a register or byte, word, dword, qword, or lword variable, the default input base is hexadecimal. If you want to change the default input base to decimal when reading a register or a byte, word, dword, qword, or lword variable, then you can use stdin.geti8, stdin.geti16, stdin.geti32, stdin.geti64, or stdin.geti128.
If you want to go in the opposite direction, that is you want to input or output an int8, int16, int32, int64, or int128 variable as a hexadecimal value, you can call the stdout.puth8, stdout.puth16, stdout.puth32, stdout.puth64, stdout.puth128, stdin.geth8, stdin.geth16, stdin.geth32, stdin.geth64, or stdin.geth128 routines. The stdout.puth8, stdout.puth16, stdout.puth32, stdout.puth64, and stdout.puth128 routines write 8-bit, 16-bit, 32-bit, 64-bit, or 128-bit objects as hexadecimal values. The stdin.geth8, stdin.geth16, stdin.geth32, stdin.geth64, and stdin.geth128 routines read 8-, 16-, 32-, 64-, and 128-bit values, respectively; they return their results in the AL, AX, or EAX registers (or in a parameter location for 64-bit and 128-bit values). The program in Listing 2-4 demonstrates the use of a few of these routines:
program HexIO;
#include( "stdlib.hhf" )
static i32: int32;
begin HexIO;
stdout.put( "Enter a hexadecimal value: " ); stdin.geth32(); mov( eax, i32 ); stdout.put( "The value you entered was $" ); stdout.puth32( i32 ); stdout.newln();
end HexIO;
Listing 2-4: Demonstration of stdin.geth32 and stdout.puth32
2.6 Logical Operations on Bits
There are four primary logical operations we’ll do with hexadecimal and binary numbers: and, or, xor (exclusive-or), and not. Unlike for the arithmetic operations, a hexadecimal calculator isn’t necessary to perform these operations. It is often easier to do them by hand than to use an electronic device to compute them. The logical and operation is a dyadic2 operation (meaning
2 Many texts call this a binary operation. The term dyadic means the same thing and avoids the confusion with the binary numbering system.
Data Re pre sen tat io n 67

AAL2E_03.book Page 68 Thursday, February 18, 2010 12:49 PM

it accepts exactly two operands). These operands are individual binary bits. The and operation is:

0 and 0 = 0 0 and 1 = 0 1 and 0 = 0 1 and 1 = 1

A compact way to represent the logical and operation is with a truth table. A truth table takes the form shown in Table 2-2.

Table 2-2: and Truth Table

and

0

1

0

0

0

1

0

1

This is just like the multiplication tables you’ve encountered in school. The values in the left column correspond to the leftmost operand of the and operation. The values in the top row correspond to the rightmost operand of the and operation. The value located at the intersection of the row and column (for a particular pair of input values) is the result of logically anding those two values together.
In English, the logical and operation is, “If the first operand is 1 and the second operand is 1, the result is 1; otherwise the result is 0.” We could also state this as, “If either or both operands are 0, the result is 0.”
One important fact to note about the logical and operation is that you can use it to force a 0 result. If one of the operands is 0, the result is always 0 regardless of the other operand. In the truth table above, for example, the row labeled with a 0 input contains only 0s, and the column labeled with a 0 contains only 0 results. Conversely, if one operand contains a 1, the result is exactly the value of the second operand. These results of the and operation are very important, particularly when we want to force bits to 0. We will investigate these uses of the logical and operation in the next section.
The logical or operation is also a dyadic operation. Its definition is:

0 or 0 = 0 0 or 1 = 1 1 or 0 = 1 1 or 1 = 1

The truth table for the or operation takes the form appearing in Table 2-3.

Table 2-3: or Truth Table

or

0

1

0

0

1

1

1

1

68 Chapter 2

AAL2E_03.book Page 69 Thursday, February 18, 2010 12:49 PM

Colloquially, the logical or operation is, “If the first operand or the second operand (or both) is 1, the result is 1; otherwise the result is 0.” This is also known as the inclusive-or operation.
If one of the operands to the logical or operation is a 1, the result is always 1 regardless of the second operand’s value. If one operand is 0, the result is always the value of the second operand. Like the logical and operation, this is an important side effect of the logical or operation that will prove quite useful.
Note that there is a difference between this form of the inclusive logical or operation and the standard English meaning. Consider the phrase “I am going to the store or I am going to the park.” Such a statement implies that the speaker is going to the store or to the park but not to both places. Therefore, the English version of logical or is slightly different from the inclusive-or operation; indeed, this is the definition of the exclusive-or operation.
The logical xor (exclusive-or) operation is also a dyadic operation. Its definition follows:

0 xor 0 = 0 0 xor 1 = 1 1 xor 0 = 1 1 xor 1 = 0

The truth table for the xor operation takes the form shown in Table 2-4.
Table 2-4: xor Truth Table

xor

0

1

0

0

1

1

1

0

In English, the logical xor operation is, “If the first operand or the second operand, but not both, is 1, the result is 1; otherwise the result is 0.” Note that the exclusive-or operation is closer to the English meaning of the word or than is the logical or operation.
If one of the operands to the logical exclusive-or operation is a 1, the result is always the inverse of the other operand; that is, if one operand is 1, the result is 0 if the other operand is 1, and the result is 1 if the other operand is 0. If the first operand contains a 0, then the result is exactly the value of the second operand. This feature lets you selectively invert bits in a bit string.
The logical not operation is a monadic operation (meaning it accepts only one operand):

not 0 = 1 not 1 = 0
The truth table for the not operation appears in Table 2-5.

Data Re pre sen tat io n 69

AAL2E_03.book Page 70 Thursday, February 18, 2010 12:49 PM

Table 2-5: not Truth Table

not

0

1

1

0

2.7 Logical Operations on Binary Numbers and Bit Strings
The previous section defines the logical functions for single-bit operands. Because the 80x86 uses groups of 8, 16, or 32 bits, we need to extend the definition of these functions to deal with more than 2 bits. Logical functions on the 80x86 operate on a bit-by-bit (or bitwise) basis. Given two values, these functions operate on bit 0, producing bit 0 of the result. They operate on bit 1 of the input values, producing bit 1 of the result, and so on. For example, if you want to compute the logical and of the following two 8-bit numbers, you would perform the logical and operation on each column independently of the others:
%1011_0101 %1110_1110 ---------%1010_0100
You may apply this bit-by-bit calculation to the other logical functions as well.
Because we’ve defined logical operations in terms of binary values, you’ll find it much easier to perform logical operations on binary values than on other representations. Therefore, if you want to perform a logical operation on two hexadecimal numbers, you should convert them to binary first. This applies to most of the basic logical operations on binary numbers (e.g., and, or, xor, etc.).
The ability to force bits to 0 or 1 using the logical and/or operations and the ability to invert bits using the logical xor operation are very important when working with strings of bits (e.g., binary numbers). These operations let you selectively manipulate certain bits within some bit string while leaving other bits unaffected. For example, if you have an 8-bit binary value X and you want to guarantee that bits 4..7 contain 0s, you could logically and the value X with the binary value %0000_1111. This bitwise logical and operation would force the H.O. 4 bits to 0 and pass the L.O. 4 bits of X unchanged. Likewise, you could force the L.O. bit of X to 1 and invert bit 2 of X by logically oring X with %0000_0001 and logically exclusive-oring X with %0000_0100, respectively. Using the logical and, or, and xor operations to manipulate bit strings in this fashion is known as masking bit strings. We use the term masking because we can use certain values (1 for and, 0 for or/xor) to mask out or mask in certain bits from the operation when forcing bits to 0, 1, or their inverse.
The 80x86 CPUs support four instructions that apply these bitwise logical operations to their operands. The instructions are and, or, xor, and not.

70 Chapter 2

AAL2E_03.book Page 71 Thursday, February 18, 2010 12:49 PM

The and, or, and xor instructions use the same syntax as the add and sub instructions:

and( source, dest ); or( source, dest );
xor( source, dest );

These operands have the same limitations as the add operands. Specifically, the source operand has to be a constant, memory, or register operand, and the dest operand must be a memory or register operand. Also, the operands must be the same size and they cannot both be memory operands. These instructions compute the obvious bitwise logical operation via the following equation:

dest = dest operator source

The 80x86 logical not instruction, because it has only a single operand, uses a slightly different syntax. This instruction takes the following form:

not( dest );

This instruction computes the following result:

dest = not( dest )

The dest operand must be a register or memory operand. This instruction inverts all the bits in the specified destination operand.
The program in Listing 2-5 inputs two hexadecimal values from the user and calculates their logical and, or, xor, and not:

program LogicalOp; #include( "stdlib.hhf" ) begin LogicalOp;

stdout.put( "Input left operand: " ); stdin.get( eax ); stdout.put( "Input right operand: " ); stdin.get( ebx );

mov( eax, ecx ); and( ebx, ecx ); stdout.put( "$", eax, " and $", ebx, " = $", ecx, nl );

mov( eax, ecx ); or( ebx, ecx ); stdout.put( "$", eax, " or $", ebx, " = $", ecx, nl );

mov( eax, ecx ); xor( ebx, ecx ); stdout.put( "$", eax, " xor $", ebx, " = $", ecx, nl );

mov( eax, ecx );

Data Re pre sen tat io n 71

AAL2E_03.book Page 72 Thursday, February 18, 2010 12:49 PM
not( ecx ); stdout.put( "not $", eax, " = $", ecx, nl );
mov( ebx, ecx ); not( ecx ); stdout.put( "not $", ebx, " = $", ecx, nl );
end LogicalOp;
Listing 2-5: and, or, xor, and not example
2.8 Signed and Unsigned Numbers
Thus far, we’ve treated binary numbers as unsigned values. The binary number ...00000 represents 0, ...00001 represents 1, ...00010 represents 2, and so on toward infinity. What about negative numbers? Signed values have been tossed around in previous sections, and we’ve mentioned the two’s complement numbering system, but we haven’t discussed how to represent negative numbers using the binary numbering system. Now it is time to describe the two’s complement numbering system.
To represent signed numbers using the binary numbering system, we have to place a restriction on our numbers: They must have a finite and fixed number of bits. For our purposes, we’re going to severely limit the number of bits to 8, 16, 32, 64, 128, or some other small number of bits.
With a fixed number of bits we can represent only a certain number of objects. For example, with 8 bits we can represent only 256 different values. Negative values are objects in their own right, just like positive numbers and 0; therefore, we’ll have to use some of the 256 different 8-bit values to represent negative numbers. In other words, we have to use up some of the bit combinations to represent negative numbers. To make things fair, we’ll assign half of the possible combinations to the negative values and half to the positive values and 0. So we can represent the negative values −128..−1 and the nonnegative values 0..127 with a single 8-bit byte. With a 16-bit word we can represent values in the range −32,768..+32,767. With a 32-bit double word we can represent values in the range −2,147,483,648..+2,147,483,647. In general, with n bits we can represent the signed values in the range −2n−1 to +2n−1−1.
Okay, so we can represent negative values. Exactly how do we do it? Well, there are many possible ways, but the 80x86 microprocessor uses the two’s complement notation, so it makes sense to study that method. In the two’s complement system, the H.O. bit of a number is a sign bit. If the H.O. bit is 0, the number is positive; if the H.O. bit is 1, the number is negative. Following are some examples.
For 16-bit numbers:
$8000 is negative because the H.O. bit is 1. $100 is positive because the H.O. bit is 0. $7FFF is positive. $FFFF is negative. $FFF ($0FFF) is positive.
72 Chapter 2

AAL2E_03.book Page 73 Thursday, February 18, 2010 12:49 PM

If the H.O. bit is 0, then the number is positive and uses the standard binary format. If the H.O. bit is 1, then the number is negative and uses the two’s complement form. To convert a positive number to its negative, two’s complement form, you use the following algorithm:

1. Invert all the bits in the number; that is, apply the logical not function. 2. Add 1 to the inverted result and ignore any overflow out of the H.O. bit.

For example, to compute the 8-bit equivalent of −5:

%0000_0101 %1111_1010 %1111_1011

5 (in binary). Invert all the bits. Add 1 to obtain result.

If we take −5 and perform the two’s complement operation on it, we get our original value, %0000_0101, back again, just as we expect:

%1111_1011 %0000_0100 %0000_0101

Two's complement for -5. Invert all the bits. Add 1 to obtain result (+5).

The following examples provide some positive and negative 16-bit signed values:

$7FFF: +32767, the largest 16-bit positive number. $8000: -32768, the smallest 16-bit negative number. $4000: +16384.

To convert the numbers above to their negative counterpart (that is, to negate them), do the following:

$7FFF: 4000h: $8000:

%0111_1111_1111_1111 %1000_0000_0000_0000 %1000_0000_0000_0001

+32,767 Invert all the bits (8000h) Add 1 (8001h or -32,767)

%0100_0000_0000_0000 %1011_1111_1111_1111 %1100_0000_0000_0000

16,384 Invert all the bits ($BFFF) Add 1 ($C000 or -16,384)

%1000_0000_0000_0000 %0111_1111_1111_1111 %1000_0000_0000_0000

-32,768 Invert all the bits ($7FFF) Add one (8000h or -32,768)

$8000 inverted becomes $7FFF. After adding 1 we obtain $8000! Wait, what’s going on here? −(−32,768) is −32,768? Of course not. But the value +32,768 cannot be represented with a 16-bit signed number, so we cannot negate the smallest negative value.
Why bother with such a miserable numbering system? Why not use the H.O. bit as a sign flag, storing the positive equivalent of the number in the remaining bits? (This, by the way, is known as the one’s complement numbering
Data Re pre sen tat io n 73

AAL2E_03.book Page 74 Thursday, February 18, 2010 12:49 PM

system.) The answer lies in the hardware. As it turns out, negating values is the only tedious job. With the two’s complement system, most other operations are as easy as the binary system. For example, suppose you were to perform the addition 5 + (−5). The result is 0. Consider what happens when we add these two values in the two’s complement system:

% 0000_0101 % 1111_1011 -----------%1_0000_0000

We end up with a carry into the ninth bit, and all other bits are 0. As it turns out, if we ignore the carry out of the H.O. bit, adding two signed values always produces the correct result when using the two’s complement numbering system. This means we can use the same hardware for signed and unsigned addition and subtraction. This wouldn’t be the case with other numbering systems.
Usually, you will not need to perform the two’s complement operation by hand. The 80x86 microprocessor provides an instruction, neg (negate), that performs this operation for you. Furthermore, hexadecimal calculators perform this operation by pressing the change sign key (+/− or CHS). Nevertheless, manually computing the two’s complement is easy, and you should know how to do it.
Remember that the data represented by a set of binary bits depends entirely on the context. The 8-bit binary value %1100_0000 could represent a character, it could represent the unsigned decimal value 192, or it could represent the signed decimal value −64. As the programmer, it is your responsibility to define the data’s format and then use the data consistently.
The 80x86 negate instruction, neg, uses the same syntax as the not instruction; that is, it takes a single destination operand:

neg( dest );

This instruction computes dest = -dest; and the operand has the same limitations as for not (it must be a memory location or a register). neg operates on byte-, word-, and dword-sized objects. Because this is a signed integer operation, it only makes sense to operate on signed integer values. The program in Listing 2-6 demonstrates the two’s complement operation by using the neg instruction:

program twosComplement; #include( "stdlib.hhf" )

static PosValue: NegValue:

int8; int8;

begin twosComplement;

74 Chapter 2

AAL2E_03.book Page 75 Thursday, February 18, 2010 12:49 PM

stdout.put( "Enter an integer between 0 and 127: " ); stdin.get( PosValue );
stdout.put( nl, "Value in hexadecimal: $" ); stdout.puth8( PosValue );
mov( PosValue, al ); not( al ); stdout.put( nl, "Invert all the bits: $", al, nl ); add( 1, al ); stdout.put( "Add one: $", al, nl ); mov( al, NegValue ); stdout.put( "Result in decimal: ", NegValue, nl );
stdout.put (
nl, "Now do the same thing with the NEG instruction: ", nl ); mov( PosValue, al ); neg( al ); mov( al, NegValue ); stdout.put( "Hex result = $", al, nl ); stdout.put( "Decimal result = ", NegValue, nl );
end twosComplement;
Listing 2-6: twosComplement example
As you’ve seen previously, you use the int8, int16, int32, int64, and int128 data types to reserve storage for signed integer variables. You’ve also seen routines like stdout.puti8 and stdin.geti32 that read and write signed integer values. Because this section has made it abundantly clear that you must differentiate signed and unsigned calculations in your programs, you should probably be asking yourself, “How do I declare and use unsigned integer variables?”
The first part of the question, “How do I declare unsigned integer variables,” is the easiest to answer. You simply use the uns8, uns16, uns32, uns64, and uns128 data types when declaring the variables. For example:

static u8: u16: u32: u64: u128:

uns8; uns16; uns32; uns64; uns128;

As for using these unsigned variables, the HLA Standard Library provides a complementary set of input/output routines for reading and displaying unsigned variables. As you can probably guess, these routines include stdout.putu8, stdout.putu16, stdout.putu32, stdout.putu64, stdout.putu128,

Data Re pre sen tat io n 75

AAL2E_03.book Page 76 Thursday, February 18, 2010 12:49 PM
stdout.putu8Size, stdout.putu16Size, stdout.putu32Size, stdout.putu64Size, stdout.putu128Size, stdin.getu8, stdin.getu16, stdin.getu32, stdin.getu64, and stdin.getu128. You use these routines just as you would use their signed integer counterparts except you get to use the full range of the unsigned values with these routines. The source code in Listing 2-7 demonstrates unsigned I/O as well as demonstrates what can happen if you mix signed and unsigned operations in the same calculation.
program UnsExample; #include( "stdlib.hhf" )
static UnsValue: uns16;
begin UnsExample;
stdout.put( "Enter an integer between 32,768 and 65,535: " ); stdin.getu16(); mov( ax, UnsValue );
stdout.put (
"You entered ", UnsValue, ". If you treat this as a signed integer, it is " ); stdout.puti16( UnsValue ); stdout.newln();
end UnsExample;
Listing 2-7: Unsigned I/O
2.9 Sign Extension, Zero Extension, Contraction, and Saturation
Because two’s complement format integers have a fixed length, a small problem develops. What happens if you need to convert an 8-bit two’s complement value to 16 bits? This problem and its converse (converting a 16-bit value to 8 bits) can be accomplished via sign extension and contraction operations.
Consider the value −64. The 8-bit two’s complement value for this number is $C0. The 16-bit equivalent of this number is $FFC0. Now consider the value +64. The 8- and 16-bit versions of this value are $40 and $0040, respectively. The difference between the 8- and 16-bit numbers can be described by the rule, “If the number is negative, the H.O. byte of the 16-bit number contains $FF; if the number is positive, the H.O. byte of the 16-bit quantity is 0.”
To extend a signed value from some number of bits to a greater number of bits is easy; just copy the sign bit into all the additional bits in the new
76 Chapter 2

AAL2E_03.book Page 77 Thursday, February 18, 2010 12:49 PM

format. For example, to sign extend an 8-bit number to a 16-bit number, simply copy bit 7 of the 8-bit number into bits 8..15 of the 16-bit number. To sign extend a 16-bit number to a double word, simply copy bit 15 into bits 16..31 of the double word.
You must use sign extension when manipulating signed values of varying lengths. Often you’ll need to add a byte quantity to a word quantity. You must sign extend the byte quantity to a word before the operation takes place. Other operations (multiplication and division, in particular) may require a sign extension to 32 bits:

Sign Extension:

8 Bits

16 Bits

$80

$FF80

$28

$0028

$9A

$FF9A

$7F

$007F

$1020

$8086

32 Bits
$FFFF_FF80 $0000_0028 $FFFF_FF9A $0000_007F $0000_1020 $FFFF_8086

To extend an unsigned value to a larger one, you must zero extend the value. Zero extension is very easy—just store a 0 into the H.O. byte(s) of the larger operand. For example, to zero extend the 8-bit value $82 to 16 bits, you simply add a 0 to the H.O. byte, yielding $0082.

Zero Extension:

8 Bits

16 Bits

$80

$0080

$28

$0028

$9A

$009A

$7F

$007F

$1020

$8086

32 Bits
$0000_0080 $0000_0028 $0000_009A $0000_007F $0000_1020 $0000_8086

The 80x86 provides several instructions that will let you sign or zero extend a smaller number to a larger number. Table 2-6 lists a group of instructions that will sign extend the AL, AX, or EAX register.

Table 2-6: Instructions for Extending AL, AX, and EAX

Instruction cbw(); cwd(); cdq();
cwde();

Explanation
Converts the byte in AL to a word in AX via sign extension. Converts the word in AX to a double word in DX:AX via sign extension. Converts the double word in EAX to the quad word in EDX:EAX via sign extension. Converts the word in AX to a double word in EAX via sign extension.

Note that the cwd (convert word to double word) instruction does not sign extend the word in AX to the double word in EAX. Instead, it stores the
Data Re pre sen tat io n 77

AAL2E_03.book Page 78 Thursday, February 18, 2010 12:49 PM

H.O. word of the sign extension into the DX register (the notation DX:AX tells you that you have a double-word value with DX containing the upper 16 bits and AX containing the lower 16 bits of the value). If you want the sign extension of AX to go into EAX, you should use the cwde (convert word to double word, extended) instruction.
The four instructions above are unusual in the sense that these are the first instructions you’ve seen that do not have any operands. These instructions’ operands are implied by the instructions themselves.
Within a few chapters you will discover just how important these instructions are and why the cwd and cdq instructions involve the DX and EDX registers. However, for simple sign extension operations, these instructions have a few major drawbacks—you do not get to specify the source and destination operands, and the operands must be registers.
For general sign extension operations, the 80x86 provides an extension of the mov instruction, movsx (move with sign extension), that copies data and sign extends the data while copying it. The movsx instruction’s syntax is very similar to the mov instruction:

movsx( source, dest );

The big difference in syntax between this instruction and the mov instruction is the fact that the destination operand must be larger than the source operand. That is, if the source operand is a byte, the destination operand must be a word or a double word. Likewise, if the source operand is a word, the destination operand must be a double word. Another difference is that the destination operand has to be a register; the source operand, however, can be a memory location.3 The movsx instruction does not allow constant operands.
To zero extend a value, you can use the movzx instruction. It has the same syntax and restrictions as the movsx instruction. Zero extending certain 8-bit registers (AL, BL, CL, and DL) into their corresponding 16-bit registers is easily accomplished without using movzx by loading the complementary H.O. register (AH, BH, CH, or DH) with 0. Obviously, to zero extend AX into DX:AX or EAX into EDX:EAX, all you need to do is load DX or EDX with 0.4
The sample program in Listing 2-8 demonstrates the use of the sign extension instructions.

program signExtension; #include( "stdlib.hhf" )

static i8: i16: i32:

int8; int16; int32;

78 Chapter 2

3 This doesn’t turn out to be much of a limitation because sign extension almost always precedes an arithmetic operation that must take place in a register.
4 Zero extending into DX:AX or EDX:EAX is just as necessary as the CWD and CDQ instructions, as you will eventually see.

