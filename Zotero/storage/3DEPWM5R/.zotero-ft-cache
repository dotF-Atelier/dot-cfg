The OpenGLÂ® Shading Language, Version 4.60.7
John Kessenich, Google (Editor and Author) ; Dave Baldwin and Randi Rost (Version 1.1 Authors)
Version 4.60.7, Wed, 10 Jul 2019 20:43:00 +0000

Table of Contents
1. Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.1. Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2. Overview. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.3. Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.4. Typographical Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.5. Deprecation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2. Overview of Shading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.1. Vertex Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.2. Tessellation Control Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.3. Tessellation Evaluation Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.4. Geometry Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.5. Fragment Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.6. Compute Processor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3. Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.1. Character Set and Phases of Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.2. Source Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 3.3. Preprocessor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 3.4. Comments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.5. Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 3.6. Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 3.7. Identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 3.8. Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
4. Variables and Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 4.1. Basic Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 4.2. Scoping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 4.3. Storage Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 4.4. Layout Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 4.5. Interpolation Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 4.6. Parameter Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 4.7. Precision and Precision Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 4.8. Variance and the Invariant Qualifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100 4.9. The Precise Qualifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 4.10. Memory Qualifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 4.11. Specialization-Constant Qualifier. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 4.12. Order and Repetition of Qualification. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 4.13. Empty Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
5. Operators and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 5.1. Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

5.2. Array Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 5.3. Function Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 5.4. Constructors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 5.5. Vector and Scalar Components and Length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 5.6. Matrix Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 5.7. Structure and Array Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 5.8. Assignments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 5.9. Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 5.10. Vector and Matrix Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 5.11. Out-of-Bounds Accesses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 5.12. Specialization-Constant Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 6. Statements and Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 6.1. Function Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129 6.2. Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135 6.3. Iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 6.4. Jumps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 7. Built-In Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 7.1. Built-In Language Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 7.2. Compatibility Profile Vertex Shader Built-In Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151 7.3. Built-In Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152 7.4. Built-In Uniform State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154 7.5. Redeclaring Built-In Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157 8. Built-In Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 8.1. Angle and Trigonometry Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160 8.2. Exponential Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 8.3. Common Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162 8.4. Floating-Point Pack and Unpack Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167 8.5. Geometric Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 8.6. Matrix Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170 8.7. Vector Relational Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 8.8. Integer Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 8.9. Texture Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173 8.10. Atomic Counter Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 8.11. Atomic Memory Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192 8.12. Image Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193 8.13. Geometry Shader Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196 8.14. Fragment Processing Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197 8.15. Noise Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200 8.16. Shader Invocation Control Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 8.17. Shader Memory Control Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 8.18. Subpass-Input Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203

8.19. Shader Invocation Group Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203 9. Shading Language Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205 10. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218 11. Normative References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219 12. Non-Normative SPIR-V Mappings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
12.1. Feature Comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220 12.2. Mapping from GLSL to SPIR-V . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221

Copyright Â© 2008-2018 The Khronos Group Inc. All Rights Reserved.
This specification is protected by copyright laws and contains material proprietary to the Khronos Group, Inc. It or any components may not be reproduced, republished, distributed, transmitted, displayed, broadcast, or otherwise exploited in any manner without the express prior written permission of Khronos Group. You may use this specification for implementing the functionality therein, without altering or removing any trademark, copyright or other notice from the specification, but the receipt or possession of this specification does not convey any rights to reproduce, disclose, or distribute its contents, or to manufacture, use, or sell anything that it may describe, in whole or in part.
Khronos Group grants express permission to any current Promoter, Contributor or Adopter member of Khronos to copy and redistribute UNMODIFIED versions of this specification in any fashion, provided that NO CHARGE is made for the specification and the latest available update of the specification for any version of the API is used whenever possible. Such distributed specification may be reformatted AS LONG AS the contents of the specification are not changed in any way. The specification may be incorporated into a product that is sold as long as such product includes significant independent work developed by the seller. A link to the current version of this specification on the Khronos Group website should be included whenever possible with specification distributions.
Khronos Group makes no, and expressly disclaims any, representations or warranties, express or implied, regarding this specification, including, without limitation, any implied warranties of merchantability or fitness for a particular purpose or noninfringement of any intellectual property. Khronos Group makes no, and expressly disclaims any, warranties, express or implied, regarding the correctness, accuracy, completeness, timeliness, and reliability of the specification. Under no circumstances will the Khronos Group, or any of its Promoters, Contributors or Members or their respective partners, officers, directors, employees, agents, or representatives be liable for any damages, whether direct, indirect, special or consequential damages for lost revenues, lost profits, or otherwise, arising from or in connection with these materials.
Khronos, Vulkan, SYCL, SPIR, WebGL, EGL, COLLADA, StreamInput, OpenVX, OpenKCam, glTF, OpenKODE, OpenVG, OpenWF, OpenSL ES, OpenMAX, OpenMAX AL, OpenMAX IL and OpenMAX DL are trademarks and WebCL is a certification mark of the Khronos Group Inc. OpenCL is a trademark of Apple Inc. and OpenGL and OpenML are registered trademarks and the OpenGL ES and OpenGL SC logos are trademarks of Silicon Graphics International used under license by Khronos. All other product names, trademarks, and/or company names are used solely for identification and belong to their respective owners.
1

Chapter 1. Introduction
This document specifies only version 4.60 of the OpenGL Shading Language (GLSL). It requires __VERSION__ to substitute 460, and requires #version to accept only 460. If #version is declared with a smaller number, the language accepted is a previous version of the shading language, which will be supported depending on the version and type of context in the API. See the normative references for details on what language versions are supported.
Previous versions of the OpenGL Shading Language, as well as the OpenGL ES Shading Language, are not strict subsets of the version specified here, particularly with respect to precision, namehiding rules, and treatment of interface variables. See the specification corresponding to a particular language version for details specific to that version of the language.
Throughout, when generating SPIR-V for consumption by the Vulkan API (see normative references), this will be said to be targeting Vulkan.
While this specification and the OpenGL Specification are normative for OpenGL Shading Language, for SPIR-V generation it is still the SPIR-V specification and the SPIR-V client API specification that are normative for the generated SPIR-V. See the normative references for further detail.
For SPIR-V generation, the SPIR-V client API specifies the commands used to manipulate SPIR-V shaders.
Independent offline tool chains will compile GLSL down to the SPIR-V intermediate language. SPIRV generation is not enabled with a #extension, #version, or a profile. Instead, use of GLSL for SPIRV is determined by offline tool-chain use. See the documentation of such tools to see how to request generation of SPIR-V for its client API.
GLSL â SPIR-V compilers must be directed as to what SPIR-V Capabilities are legal at run-time and give errors for GLSL feature use outside those capabilities. This is also true for implementationdependent limits that can be error checked by the front-end against built-in constants present in the GLSL source: the front-end can be informed of such limits, and report errors when they are exceeded.
SPIR-V features that are not controlled by a SPIR-V capability, but do have an equivalent GLSL counterpart (stages, built-in functions, types, limits, etc.) are only expected to work on OpenGL drivers that support the GLSL counterpart.
All references in this specification to the OpenGL Specification are to the Core profile of version 4.6, unless a different profile is specified.
1.1. Changes
1.1.1. Changes from Revision 6 of GLSL 4.6
â¢ Incorporated the GL_KHR_vulkan_glsl specification. â¢ Add note in the introduction about presence in drivers of SPIR-V features, as they relate to GLSL
2

features. â¢ Clarify it is same location that triggers default-uniform block matching rules. See Uniform
Variable Layout Qualifiers.
1.1.2. Changes from Revision 5 of GLSL 4.6
â¢ Private GLSL issue #34: Clarify/consolidate implicit conversion rules from int â uint to be the same as explicit construction.
â¢ Private GLSL issue #24: Clarify that barrier() by itself is enough to synchronize both control flow and memory accesses to shared variables and tessellation control output variables. For other memory accesses an additional memory barrier is still required.
â¢ Normatively reference IEEE-754 for definitions of floating-point formats. â¢ Private GLSL issue 36: refract function on double types requires eta argument to have type
double. â¢ Clarify restrictions on input variables in tessellation and geometry stages. â¢ Private GLSL issue 15: Clarify the ordering of bindings for arrays of arrays. â¢ Private GLSL issue 14: Uniform variables need only match at link time if they are statically used. â¢ For precise computations, the controlling expressions for control flow and ternary operators (
?:) are not included.
1.1.3. Changes from Revision 4 of GLSL 4.6
â¢ Private bug 13012: Clarified that builtin uniform variables might only be available in the fragment stage.
â¢ Private bug 13837: Ternary and sequence operators may operate on void types. â¢ Clarified that errors arising from preprocessing must be returned at compile time. â¢ Clarified that access to any part of a variable constitutes a static use. â¢ Private GLSL issue 19: A statement is required following any label at the end of a switch. â¢ Private GLSL issue 26: noise is not valid when compiling for SPIR-V. â¢ Private GLSL issue 20: length() expressions returning a constant value may not contain side
effects. â¢ Public OpenGL-API issue 7: Variables can be declared as both readonly and writeonly. â¢ Private GLSL issue 16: Use of constant expressions within #line directives is undefined. â¢ Corrected return type of imageAtomicExchange on float images. â¢ Private GLSL issue 32: Remove length() method contradiction: Non runtime-sized arrays only
support length() on explicitly sized arrays. â¢ Private GLSL issue 21: Clarified the l-value restriction on interpolateAt. â¢ Private OpenGL-API issue 53: Clarified bit-width requirements for location aliasing. â¢ Public GLSL issue 15: gl_in can be redeclared using unsized-array syntax. â¢ Clarification of the formats needed for DEPTH_COMPONENT and STENCIL_COMPONENT for
3

depth/stencil textures. â¢ Added image formats to the layout-qualifier table in the Layout Qualifiers section.
1.1.4. Changes from Revision 3 of GLSL 4.6
â¢ Private GLSL issue 13: Fix misspelling of allInvocationsEqual(). (The one in the table was incorrectly listed as anyInvocationsEqual(), other spellings were correct.)
1.1.5. Summary of Changes from Revision 7 of GLSL Version 4.50
â¢ Incorporated the GL_ARB_shader_atomic_counter_ops extension. â¢ Incorporated the GL_ARB_shader_draw_parameters extension. â¢ Incorporated the GL_ARB_shader_group_vote extension. â¢ Incorporated the GL_ARB_gl_spirv extension. â¢ Private Bug 16070: Allow extra semi-colons at global scope. â¢ Private GLSL Issue 5: Be explicit that âfail to linkâ is really âcompile-time or link-time errorâ, for
some forms of error. â¢ Private GLSL Issue 7: Change gl_MaxComputeUniformComponents to 1024. â¢ Private OpenGL API Issue 35: Require location on transparent individual uniform variables for
SPIR-V. â¢ Private GLSL Issue 8: Be more clear an interpolateAt() interpolant can be a structure member. â¢ Private GLSL Issue 9: Specify how xfb_buffer interacts with a block array: the capturing buffer
increments for each block array element.
1.2. Overview
This document describes The OpenGL Shading Language, version 4.60.
Independent compilation units written in this language are called shaders. A program is a set of shaders that are compiled and linked together, completely creating one or more of the programmable stages of the API pipeline. All the shaders for a single programmable stage must be within the same program. A complete set of programmable stages can be put into a single program or the stages can be partitioned across multiple programs. The aim of this document is to thoroughly specify the programming language. The normative references will specify the API entry points used to manipulate and communicate with programs and shaders.
1.3. Error Handling
Compilers, in general, accept programs that are ill-formed, due to the impossibility of detecting all ill-formed programs. Portability is only ensured for well-formed programs, which this specification describes. Compilers are encouraged to detect ill-formed programs and issue diagnostic messages, but are not required to do so for all cases. Compile-time errors must be returned for lexically or grammatically incorrect shaders. Other errors are reported at compile time or link time as indicated. Code that is âdeadâ must still be error checked. For example:
4

if (false) // changing false to true cannot uncover additional errors statement; // statement must be error checked regardless
1.4. Typographical Conventions
Italic, bold, and font choices have been used in this specification primarily to improve readability. Code fragments use a fixed width font. Identifiers embedded in text are italicized. Keywords embedded in text are bold. Operators are called by their name, followed by their symbol in bold in parentheses. The clarifying grammar fragments in the text use bold for literals and italics for nonterminals. The official grammar in âShading Language Grammarâ uses all capitals for terminals and lower case for non-terminals.
1.5. Deprecation
The OpenGL Shading Language has deprecated some features. These are clearly called out in this specification as âdeprecatedâ. They are still present in this version of the language, but are targeted for potential removal in a future version of the shading language. The OpenGL API has a forward compatibility mode that will disallow use of deprecated features. If compiling in a mode where use of deprecated features is disallowed, their use causes compile-time or link-time errors. See the OpenGL Specification for details on what causes deprecated language features to be accepted or to return an error.
5

Chapter 2. Overview of Shading
The OpenGL Shading Language is actually several closely related languages. These languages are used to create shaders for each of the programmable processors contained in the APIâs processing pipeline. Currently, these processors are the vertex, tessellation control, tessellation evaluation, geometry, fragment, and compute processors.
Unless otherwise noted in this paper, a language feature applies to all languages, and common usage will refer to these languages as a single language. The specific languages will be referred to by the name of the processor they target: vertex, tessellation control, tessellation evaluation, geometry, fragment, or compute.
Most API state is not tracked or made available to shaders. Typically, user-defined variables will be used for communicating between different stages of the API pipeline. However, a small amount of state is still tracked and automatically made available to shaders, and there are a few built-in variables for interfaces between different stages of the API pipeline.
2.1. Vertex Processor
The vertex processor is a programmable unit that operates on incoming vertices and their associated data. Compilation units written in the OpenGL Shading Language to run on this processor are called vertex shaders. When a set of vertex shaders are successfully compiled and linked, they result in a vertex shader executable that runs on the vertex processor.
The vertex processor operates on one vertex at a time. It does not replace graphics operations that require knowledge of several vertices at a time.
2.2. Tessellation Control Processor
The tessellation control processor is a programmable unit that operates on a patch of incoming vertices and their associated data, emitting a new output patch. Compilation units written in the OpenGL Shading Language to run on this processor are called tessellation control shaders. When a set of tessellation control shaders are successfully compiled and linked, they result in a tessellation control shader executable that runs on the tessellation control processor.
The tessellation control shader is invoked for each vertex of the output patch. Each invocation can read the attributes of any vertex in the input or output patches, but can only write per-vertex attributes for the corresponding output patch vertex. The shader invocations collectively produce a set of per-patch attributes for the output patch.
After all tessellation control shader invocations have completed, the output vertices and per-patch attributes are assembled to form a patch to be used by subsequent pipeline stages.
Tessellation control shader invocations run mostly independently, with undefined relative execution order. However, the built-in function barrier() can be used to control execution order by synchronizing invocations, effectively dividing tessellation control shader execution into a set of phases. Tessellation control shaders will get undefined results if one invocation reads from a pervertex or per-patch attribute written by another invocation at any point during the same phase, or
6

if two invocations attempt to write different values to the same per-patch output 32-bit component in a single phase.
2.3. Tessellation Evaluation Processor
The tessellation evaluation processor is a programmable unit that evaluates the position and other attributes of a vertex generated by the tessellation primitive generator, using a patch of incoming vertices and their associated data. Compilation units written in the OpenGL Shading Language to run on this processor are called tessellation evaluation shaders. When a set of tessellation evaluation shaders are successfully compiled and linked, they result in a tessellation evaluation shader executable that runs on the tessellation evaluation processor.
Each invocation of the tessellation evaluation executable computes the position and attributes of a single vertex generated by the tessellation primitive generator. The executable can read the attributes of any vertex in the input patch, plus the tessellation coordinate, which is the relative location of the vertex in the primitive being tessellated. The executable writes the position and other attributes of the vertex.
2.4. Geometry Processor
The geometry processor is a programmable unit that operates on data for incoming vertices for a primitive assembled after vertex processing and outputs a sequence of vertices forming output primitives. Compilation units written in the OpenGL Shading Language to run on this processor are called geometry shaders. When a set of geometry shaders are successfully compiled and linked, they result in a geometry shader executable that runs on the geometry processor.
A single invocation of the geometry shader executable on the geometry processor will operate on a declared input primitive with a fixed number of vertices. This single invocation can emit a variable number of vertices that are assembled into primitives of a declared output primitive type and passed to subsequent pipeline stages.
2.5. Fragment Processor
The fragment processor is a programmable unit that operates on fragment values and their associated data. Compilation units written in the OpenGL Shading Language to run on this processor are called fragment shaders. When a set of fragment shaders are successfully compiled and linked, they result in a fragment shader executable that runs on the fragment processor.
A fragment shader cannot change a fragmentâs (x, y) position. Access to neighboring fragments is not allowed. The values computed by the fragment shader are ultimately used to update framebuffer memory or texture memory, depending on the current API state and the API command that caused the fragments to be generated.
2.6. Compute Processor
The compute processor is a programmable unit that operates independently from the other shader processors. Compilation units written in the OpenGL Shading Language to run on this processor are
7

called compute shaders. When a set of compute shaders are successfully compiled and linked, they result in a compute shader executable that runs on the compute processor. A compute shader has access to many of the same resources as fragment and other shader processors, such as textures, buffers, image variables, and atomic counters. It does not have fixedfunction outputs. It is not part of the graphics pipeline and its visible side effects are through changes to images, storage buffers, and atomic counters. A compute shader operates on a group of work items called a workgroup. A workgroup is a collection of shader invocations that execute the same code, potentially in parallel. An invocation within a workgroup may share data with other members of the same workgroup through shared variables and issue memory and control flow barriers to synchronize with other members of the same workgroup.
8

Chapter 3. Basics
3.1. Character Set and Phases of Compilation
The source character set used for the OpenGL Shading Language is Unicode in the UTF-8 encoding scheme.
After preprocessing, only the following characters are allowed in the resulting stream of GLSL tokens:
â¢ The letters a-z, A-Z, and the underscore (_). â¢ The numbers 0-9. â¢ The symbols period (.), plus (+), dash (-), slash (/), asterisk (*), percent (%), angled brackets (< and
>), square brackets ([ and ]), parentheses (( and )), braces ({ and }), caret (^), vertical bar (|), ampersand (&), tilde (~), equals (=), exclamation point (!), colon (:), semicolon (;), comma (,), and question mark (?).
A compile-time error will be given if any other character is used in a GLSL token.
There are no digraphs or trigraphs. There are no escape sequences or other uses of the backslash beyond use as the line-continuation character.
Lines are relevant for compiler diagnostic messages and the preprocessor. They are terminated by carriage-return or line-feed. If both are used together, it will count as only a single line termination. For the remainder of this document, any of these combinations is simply referred to as a new-line. Lines may be of arbitrary length.
In general, the languageâs use of this character set is case sensitive.
There are no character or string data types, so no quoting characters are included.
There is no end-of-file character.
More formally, compilation happens as if the following logical phases were executed in order:
1. Source strings are concatenated to form a single input. All provided new-lines are retained. 2. Line numbering is noted, based on all present new-lines, and does not change when new-lines
are later eliminated. 3. Wherever a backslash ('\') occurs immediately before a new-line, both are eliminated. (Note no
white space is substituted, allowing a single token to span a new-line.) Any newly formed backslash followed by a new-line is not eliminated; only those pairs originally occurring after phase 1 are eliminated. 4. All comments are replaced with a single space. (Note that '//' style comments end before their terminating new-lines and white space is generally relevant to preprocessing.) 5. Preprocessing is done, resulting in a sequence of GLSL tokens, formed from the character set stated above.
9

6. GLSL processing is done on the sequence of GLSL tokens.
Details that fully define source strings, comments, line numbering, new-line elimination, and preprocessing are all discussed in upcoming sections. Sections beyond those describe GLSL processing.
3.2. Source Strings
The source for a single shader is an array of strings of characters from the character set. A single shader is made from the concatenation of these strings. Each string can contain multiple lines, separated by new-lines. No new-lines need be present in a string; a single line can be formed from multiple strings. No new-lines or other characters are inserted by the implementation when it concatenates the strings to form a single shader. Multiple shaders can be linked together to form a single program.
Diagnostic messages returned from compiling a shader must identify both the line number within a string and which source string the message applies to. Source strings are counted sequentially with the first string being string 0. Line numbers are one more than the number of new-lines that have been processed, including counting the new-lines that will be removed by the line-continuation character (\).
Lines separated by the line-continuation character preceding a new-line are concatenated together before either comment processing or preprocessing. This means that no white space is substituted for the line-continuation character. That is, a single token could be formed by the concatenation by taking the characters at the end of one line concatenating them with the characters at the beginning of the next line.
float f\ oo; // forms a single line equivalent to "float foo;" // (assuming '\' is the last character before the new-line and "oo" are // the first two characters of the next line)
3.3. Preprocessor
There is a preprocessor that processes the source strings as part of the compilation process. Except as noted below, it behaves as the C++ standard preprocessor (see âNormative Referencesâ).
The complete list of preprocessor directives is as follows.
# #define #undef
#if #ifdef #ifndef
10

#else #elif #endif
#error #pragma
#extension #version
#line
The following operators are also available:
defined ##
Each number sign (#) can be preceded in its line only by spaces or horizontal tabs. It may also be followed by spaces and horizontal tabs, preceding the directive. Each directive is terminated by a new-line. Preprocessing does not change the number or relative location of new-lines in a source string. Preprocessing takes places after new-lines have been removed by the line-continuation character.
The number sign (#) on a line by itself is ignored. Any directive not listed above will cause a compile-time error.
#define and #undef functionality are defined as is standard for C++ preprocessors for macro definitions both with and without macro parameters.
The following predefined macros are available:
__LINE__ __FILE__ __VERSION__
__LINE__ will substitute a decimal integer constant that is one more than the number of preceding new-lines in the current source string.
__FILE__ will substitute a decimal integer constant that says which source string number is currently being processed.
__VERSION__ will substitute a decimal integer reflecting the version number of the OpenGL Shading Language. The version of the shading language described in this document will have __VERSION__ substitute the decimal integer 460.
By convention, all macro names containing two consecutive underscores (__) are reserved for use by underlying software layers. Defining or undefining such a name in a shader does not itself result in an error, but may result in unintended behaviors that stem from having multiple definitions of the same name. All macro names prefixed with âGL_â (âGLâ followed by a single underscore) are also reserved, and defining or undefining such a name results in a compile-time error.
11

Implementations must support macro-name lengths of up to 1024 characters. Implementations are allowed to generate an error for a macro name of length greater than 1024 characters, but are also allowed to support lengths greater than 1024.
#if, #ifdef, #ifndef, #else, #elif, and #endif are defined to operate as is standard for C++ preprocessors except for the following:

â¢ Expressions following #if and #elif are further restricted to expressions operating on literal integer constants, plus identifiers consumed by the defined operator.
â¢ Character constants are not supported.
The operators available are as follows.

Precedence 1 (highest) 2
3 4 5 6 7 8 9 10 11 12 (lowest)

Operator class

Operators

parenthetical grouping ( )

unary

defined + - ~ !

multiplicative

* / %

additive

+ -

bit-wise shift

<< >>

relational

< > <= >=

equality

== !=

bit-wise and

&

bit-wise exclusive or ^

bit-wise inclusive or |

logical and

&&

logical inclusive or

||

Associativity NA Right to Left
Left to Right Left to Right Left to Right Left to Right Left to Right Left to Right Left to Right Left to Right Left to Right Left to Right

The defined operator can be used in either of the following ways:

defined identifier defined ( identifier )

Two tokens in a macro can be concatenated into one token using the token pasting (##) operator, as is standard for C++ preprocessors. The result must be a valid single token, which will then be subject to macro expansion. That is, macro expansion happens only after token pasting. There are no other number sign based operators (e.g. no # or #@), nor is there a sizeof operator.
The semantics of applying operators to integer literals in the preprocessor match those standard in the C++ preprocessor, not those in the OpenGL Shading Language.
Preprocessor expressions will be evaluated according to the behavior of the host processor, not the processor targeted by the shader.
#error will cause the implementation to put a compile-time diagnostic message into the shader

12

objectâs information log (see section 7.12 âShader, Program and Program Pipeline Queriesâ of the OpenGL Specification for how to access a shader objectâs information log). The message will be the tokens following the #error directive, up to the first new-line. The implementation must treat the presence of a #error directive as a compile-time error.
#pragma allows implementation-dependent compiler control. Tokens following #pragma are not subject to preprocessor macro expansion. If an implementation does not recognize the tokens following #pragma, then it will ignore that pragma. The following pragmas are defined as part of the language.
#pragma STDGL
The STDGL pragma is used to reserve pragmas for use by future revisions of this language. No implementation may use a pragma whose first token is STDGL.
#pragma optimize(on) #pragma optimize(off)
can be used to turn off optimizations as an aid in developing and debugging shaders. It can only be used outside function definitions. By default, optimization is turned on for all shaders. The debug pragma
#pragma debug(on) #pragma debug(off)
can be used to enable compiling and annotating a shader with debug information, so that it can be used with a debugger. It can only be used outside function definitions. By default, debug is turned off.
Shaders should declare the version of the language they are written to. The language version a shader is written to is specified by
#version number profile_opt
where number must be a version of the language, following the same convention as __VERSION__ above. The directive â#version 460â is required in any shader that uses version 4.60 of the language. Any number representing a version of the language a compiler does not support will cause a compile-time error to be generated. Version 1.10 of the language does not require shaders to include this directive, and shaders that do not include a #version directive will be treated as targeting version 1.10. Shaders that specify #version 100 will be treated as targeting version 1.00 of the OpenGL ES Shading Language. Shaders that specify #version 300 will be treated as targeting version 3.00 of the OpenGL ES Shading Language. Shaders that specify #version 310 will be treated as targeting version 3.10 of the OpenGL ES Shading Language.
If the optional profile argument is provided, it must be the name of an OpenGL profile. Currently,
13

there are three choices:
core compatibility es
A profile argument can only be used with version 150 or greater. If no profile argument is provided and the version is 150 or greater, the default is core. If version 300 or 310 is specified, the profile argument is not optional and must be es, or a compile-time error results. The Language Specification for the es profile is specified in The OpenGL ES Shading Language specification.
Shaders for the core or compatibility profiles that declare different versions can be linked together. However, es profile shaders cannot be linked with non-es profile shaders or with es profile shaders of a different version, or a link-time error will result. When linking shaders of versions allowed by these rules, remaining link-time errors will be given as per the linking rules in the GLSL version corresponding to the version of the context the shaders are linked under. Shader compile-time errors must still be given strictly based on the version declared (or defaulted to) within each shader.
Unless otherwise specified, this specification is documenting the core profile, and everything specified for the core profile is also available in the compatibility profile. Features specified as belonging specifically to the compatibility profile are not available in the core profile. Compatibility-profile features are not available when generating SPIR-V.
There is a built-in macro definition for each profile the implementation supports. All implementations provide the following macro:
#define GL_core_profile 1
Implementations providing the compatibility profile provide the following macro:
#define GL_compatibility_profile 1
Implementations providing the es profile provide the following macro:
#define GL_es_profile 1
The #version directive must occur in a shader before anything else, except for comments and white space.
By default, compilers of this language must issue compile-time lexical and grammatical errors for shaders that do not conform to this specification. Any extended behavior must first be enabled. Directives to control the behavior of the compiler with respect to extensions are declared with the #extension directive
14

#extension extension_name : behavior #extension all : behavior

where extension_name is the name of an extension. Extension names are not documented in this specification. The token all means the behavior applies to all extensions supported by the compiler. The behavior can be one of the following:

Behavior require enable warn
disable

Effect
Behave as specified by the extension extension_name. Give a compile-time error on the #extension if the extension extension_name is not supported, or if all is specified.
Behave as specified by the extension extension_name. Warn on the #extension if the extension extension_name is not supported. Give a compile-time error on the #extension if all is specified.
Behave as specified by the extension extension_name, except issue warnings on any detectable use of that extension, unless such use is supported by other enabled or required extensions. If all is specified, then warn on all detectable uses of any extension used. Warn on the #extension if the extension extension_name is not supported.
Behave (including issuing errors and warnings) as if the extension extension_name is not part of the language definition. If all is specified, then behavior must revert back to that of the non-extended core version of the language being compiled to. Warn on the #extension if the extension extension_name is not supported.

The extension directive is a simple, low-level mechanism to set the behavior for each extension. It does not define policies such as which combinations are appropriate, those must be defined elsewhere. Order of directives matters in setting the behavior for each extension: Directives that occur later override those seen earlier. The all variant sets the behavior for all extensions, overriding all previously issued extension directives, but only for the behaviors warn and disable.

The initial state of the compiler is as if the directive

#extension all : disable

15

was issued, telling the compiler that all error and warning reporting must be done according to this specification, ignoring any extensions.
Each extension can define its allowed granularity of scope. If nothing is said, the granularity is a shader (that is, a single compilation unit), and the extension directives must occur before any nonpreprocessor tokens. If necessary, the linker can enforce granularities larger than a single compilation unit, in which case each involved shader will have to contain the necessary extension directive.
Macro expansion is not done on lines containing #extension and #version directives.
#line must have, after macro substitution, one of the following forms:
#line line #line line source-string-number

where line and source-string-number are constant integer expressions. If these constant expressions are not integer literals then behavior is undefined. After processing this directive (including its new-line), the implementation will behave as if it is compiling at line number line and source string number source-string-number. Subsequent source strings will be numbered sequentially, until another #line directive overrides that numbering.

Note

ï

Some implementations have allowed constant expressions in #line directives and some have not. Even where expressions are supported the grammar is ambiguous

and so results are implementation dependent. For example, + #line +2 +2 // Line

number set to 4, or file to 2 and line to 2

When shaders are compiled for OpenGL SPIR-V, the following predefined macro is available:

#define GL_SPIRV 100

When targeting Vulkan, the following predefined macro is available: #define VULKAN 100

3.4. Comments
Comments are delimited by /* and */, or by // and a new-line. The begin comment delimiters (/* or //) are not recognized as comment delimiters inside of a comment, hence comments cannot be nested. A /* comment includes its terminating delimiter (*/). However, a // comment does not include (or eliminate) its terminating new line.
Inside comments, any byte values may be used, except a byte whose value is 0. No errors will be given for the content of comments and no validation on the content of comments need be done.

16

Removal of new-lines by the line-continuation character (\) logically occurs before comments are processed. That is, a single-line comment ending in the line-continuation character (\) includes the next line in the comment.
// a single-line comment containing the next line \ a = b; // this is still in the first comment
3.5. Tokens
The language, after preprocessing, is a sequence of tokens. A token can be token :
keyword identifier integer-constant floating-constant operator ; { }
3.6. Keywords
The following are the keywords in the language and (after preprocessing) can only be used as described in this specification, or a compile-time error results:
const uniform buffer shared attribute varying
coherent volatile restrict readonly writeonly
atomic_uint
layout
centroid flat smooth noperspective
patch sample
invariant precise
break continue do for while switch case default
if else
subroutine
in out inout
17

int void bool true false float double discard return vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 uint uvec2 uvec3 uvec4 dvec2 dvec3 dvec4 mat2 mat3 mat4 mat2x2 mat2x3 mat2x4 mat3x2 mat3x3 mat3x4 mat4x2 mat4x3 mat4x4 dmat2 dmat3 dmat4 dmat2x2 dmat2x3 dmat2x4 dmat3x2 dmat3x3 dmat3x4 dmat4x2 dmat4x3 dmat4x4 lowp mediump highp precision sampler1D sampler1DShadow sampler1DArray sampler1DArrayShadow isampler1D isampler1DArray usampler1D usampler1DArray sampler2D sampler2DShadow sampler2DArray sampler2DArrayShadow isampler2D isampler2DArray usampler2D usampler2DArray sampler2DRect sampler2DRectShadow isampler2DRect usampler2DRect sampler2DMS isampler2DMS usampler2DMS sampler2DMSArray isampler2DMSArray usampler2DMSArray sampler3D isampler3D usampler3D samplerCube samplerCubeShadow isamplerCube usamplerCube
18

samplerCubeArray samplerCubeArrayShadow isamplerCubeArray usamplerCubeArray samplerBuffer isamplerBuffer usamplerBuffer image1D iimage1D uimage1D image1DArray iimage1DArray uimage1DArray image2D iimage2D uimage2D image2DArray iimage2DArray uimage2DArray image2DRect iimage2DRect uimage2DRect image2DMS iimage2DMS uimage2DMS image2DMSArray iimage2DMSArray uimage2DMSArray image3D iimage3D uimage3D imageCube iimageCube uimageCube imageCubeArray iimageCubeArray uimageCubeArray imageBuffer iimageBuffer uimageBuffer struct In addition, when targeting Vulkan, the following keywords also exist: texture1D texture1DArray itexture1D itexture1DArray utexture1D utexture1DArray texture2D texture2DArray itexture2D itexture2DArray utexture2D utexture2DArray texture2DRect itexture2DRect utexture2DRect texture2DMS itexture2DMS utexture2DMS texture2DMSArray itexture2DMSArray utexture2DMSArray
19

texture3D itexture3D utexture3D textureCube itextureCube utextureCube textureCubeArray itextureCubeArray utextureCubeArray textureBuffer itextureBuffer utextureBuffer sampler samplerShadow subpassInput isubpassInput usubpassInput subpassInputMS isubpassInputMS usubpassInputMS The following are the keywords reserved for future use. Using them will result in a compile-time error: common partition active asm class union enum typedef template this resource goto inline noinline public static extern external interface long short half fixed unsigned superp input output hvec2 hvec3 hvec4 fvec2 fvec3 fvec4 filter sizeof cast namespace using sampler3DRect In addition, all identifiers containing two consecutive underscores (__) are reserved for use by underlying software layers. Defining such a name in a shader does not itself result in an error, but may result in unintended behaviors that stem from having multiple definitions of the same name.
20

3.7. Identifiers
Identifiers are used for variable names, function names, structure names, and field selectors (field selectors select components of vectors and matrices, similarly to structure members). Identifiers have the form:
identifier : nondigit identifier nondigit identifier digit
nondigit : one of _ a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
digit : one of 0 1 2 3 4 5 6 7 8 9
Identifiers starting with âgl_â are reserved, and in general, may not be declared in a shader; this results in a compile-time error. However, as noted in the specification, there are some cases where previously declared variables can be redeclared, and predeclared âgl_â names are allowed to be redeclared in a shader only for these specific purposes.
Implementations must support identifier lengths of up to 1024 characters. Implementations are allowed to generate an error for an identifier of length greater than 1024 characters, but are also allowed to support lengths greater than 1024.
3.8. Definitions
Some language rules described below depend on the following definitions.
3.8.1. Static Use
A shader contains a static use of a variable x if, after preprocessing, the shader contains a statement that would access any part of x, whether or not flow of control will cause that statement to be executed. Such a variable is referred to as being statically used. If the access is a write then x is further said to be statically assigned.
3.8.2. Dynamically Uniform Expressions and Uniform Control Flow
Some operations require an expression to be dynamically uniform, or that it be located in uniform control flow. These requirements are defined by the following set of definitions.
An invocation is a single execution of main() for a particular stage, operating only on the amount of data explicitly exposed within that stageâs shaders. (Any implicit operation on additional instances of data would comprise additional invocations.) For example, in compute execution models, a single invocation operates only on a single work item, or, in a vertex execution model, a single invocation operates only on a single vertex.
21

An invocation group is the complete set of invocations collectively processing a particular compute workgroup or graphical operation, where the scope of a "graphical operation" is implementationdependent, but at least as large as a single triangle or patch, and at most as large as a single rendering command, as defined by the client API.
Within a single invocation, a single shader statement can be executed multiple times, giving multiple dynamic instances of that instruction. This can happen when the instruction is executed in a loop, or in a function called from multiple call sites, or combinations of multiple of these. Different loop iterations and different dynamic function-call-site chains yield different dynamic instances of such an instruction. Dynamic instances are distinguished by their control-flow path within an invocation, not by which invocation executed it. That is, different invocations of main() execute the same dynamic instances of an instruction when they follow the same control-flow path.
An expression is dynamically uniform for a dynamic instance consuming it when its value is the same for all invocations (in the invocation group) that execute that dynamic instance.
Uniform control flow (or converged control flow) occurs when all invocations in the invocation group execute the same control-flow path (and hence the same sequence of dynamic instances of instructions). Uniform control flow is the initial state at the entry into main(), and lasts until a conditional branch takes different control paths for different invocations (non-uniform or divergent control flow). Such divergence can reconverge, with all the invocations once again executing the same control-flow path, and this re-establishes the existence of uniform control flow. If control flow is uniform upon entry into a selection or loop, and all invocations in the invocation group subsequently leave that selection or loop, then control flow reconverges to be uniform.
For example:

main()

{

float a = ...; // this is uniform control flow

if (a < b) { // this expression is true for some fragments, not all

...;

// non-uniform control flow

} else {

...;

// non-uniform control flow

}

...;

// uniform control flow again

}

Note that constant expressions are trivially dynamically uniform. It follows that typical loop counters based on these are also dynamically uniform.

22

Chapter 4. Variables and Types
All variables and functions must be declared before being used. Variable and function names are identifiers.
There are no default types. All variable and function declarations must have a declared type, and optionally qualifiers. A variable is declared by specifying its type followed by one or more names separated by commas. In many cases, a variable can be initialized as part of its declaration by using the assignment operator (=).
User-defined types may be defined using struct to aggregate a list of existing types into a single name.
The OpenGL Shading Language is type safe. There are some implicit conversions between types. Exactly how and when this can occur is described in section âImplicit Conversionsâ and as referenced by other sections in this specification.

4.1. Basic Types

Definition A basic type is a type defined by a keyword in the language.

The OpenGL Shading Language supports the following basic data types, grouped as follows. Transparent Types

Type void bool
int uint float double vec2
vec3
vec4
dvec2
dvec3

Meaning
for functions that do not return a value
a conditional type, taking on values of true or false
a signed integer
an unsigned integer
a single-precision floating-point scalar
a double-precision floating-point scalar
a two-component single-precision floating-point vector
a three-component single-precision floatingpoint vector
a four-component single-precision floating-point vector
a two-component double-precision floatingpoint vector
a three-component double-precision floatingpoint vector

23

Type dvec4
bvec2 bvec3 bvec4 ivec2 ivec3 ivec4 uvec2 uvec3 uvec4 mat2 mat3 mat4 mat2x2 mat2x3
mat2x4
mat3x2
mat3x3 mat3x4
mat4x2
mat4x3
mat4x4 dmat2 dmat3 dmat4 dmat2x2 dmat2x3
dmat2x4
dmat3x2
24

Meaning a four-component double-precision floatingpoint vector a two-component Boolean vector a three-component Boolean vector a four-component Boolean vector a two-component signed integer vector a three-component signed integer vector a four-component signed integer vector a two-component unsigned integer vector a three-component unsigned integer vector a four-component unsigned integer vector a 2 Ã 2 single-precision floating-point matrix a 3 Ã 3 single-precision floating-point matrix a 4 Ã 4 single-precision floating-point matrix same as a mat2 a single-precision floating-point matrix with 2 columns and 3 rows a single-precision floating-point matrix with 2 columns and 4 rows a single-precision floating-point matrix with 3 columns and 2 rows same as a mat3 a single-precision floating-point matrix with 3 columns and 4 rows a single-precision floating-point matrix with 4 columns and 2 rows a single-precision floating-point matrix with 4 columns and 3 rows same as a mat4 a 2 Ã 2 double-precision floating-point matrix a 3 Ã 3 double-precision floating-point matrix a 4 Ã 4 double-precision floating-point matrix same as a dmat2 a double-precision floating-point matrix with 2 columns and 3 rows a double-precision floating-point matrix with 2 columns and 4 rows a double-precision floating-point matrix with 3 columns and 2 rows

Type dmat3x3 dmat3x4
dmat4x2
dmat4x3
dmat4x4

Meaning
same as a dmat3
a double-precision floating-point matrix with 3 columns and 4 rows
a double-precision floating-point matrix with 4 columns and 2 rows
a double-precision floating-point matrix with 4 columns and 3 rows
same as a dmat4

Note that where the following tables say âaccessing a textureâ, the sampler* opaque types access textures, and the image* opaque types access images, of a specified type.
Floating-Point Opaque Types

Type sampler1D texture1D image1D sampler1DShadow
sampler1DArray texture1DArray image1DArray sampler1DArrayShadow
sampler2D texture2D image2D sampler2DShadow
sampler2DArray texture2DArray image2DArray sampler2DArrayShadow
sampler2DMS texture2DMS image2DMS sampler2DMSArray texture2DMSArray image2DMSArray sampler2DRect texture2DRect image2DRect

Meaning a handle for accessing a 1D texture
a handle for accessing a 1D depth texture with comparison a handle for accessing a 1D array texture
a handle for accessing a 1D array depth texture with comparison a handle for accessing a 2D texture
a handle for accessing a 2D depth texture with comparison a handle for accessing a 2D array texture
a handle for accessing a 2D array depth texture with comparison a handle for accessing a 2D multisample texture
a handle for accessing a 2D multisample array texture
a handle for accessing a rectangle texture

25

Type sampler2DRectShadow
sampler3D texture3D image3D samplerCube textureCube imageCube samplerCubeShadow
samplerCubeArray textureCubeArray imageCubeArray samplerCubeArrayShadow
samplerBuffer textureBuffer imageBuffer subpassInput
subpassInputMS
Signed Integer Opaque Types
Type isampler1D itexture1D iimage1D isampler1DArray itexture1DArray iimage1DArray isampler2D itexture2D iimage2D isampler2DArray itexture2DArray iimage2DArray isampler2DMS itexture2DMS iimage2DMS isampler2DMSArray itexture2DMSArray iimage2DMSArray
26

Meaning a handle for accessing a rectangle texture with comparison a handle for accessing a 3D texture
a handle for accessing a cube mapped texture
a handle for accessing a cube map depth texture with comparison a handle for accessing a cube map array texture
a handle for accessing a cube map array depth texture with comparison a handle for accessing a buffer texture
a handle for accessing a floating-point subpass input a handle for accessing a multi-sampled floatingpoint subpass input
Meaning a handle for accessing an integer 1D texture
a handle for accessing an integer 1D array texture
a handle for accessing an integer 2D texture
a handle for accessing an integer 2D array texture
a handle for accessing an integer 2D multisample texture
a handle for accessing an integer 2D multisample array texture

Type
isampler2DRect itexture2DRect iimage2DRect
isampler3D itexture3D iimage3D
isamplerCube itextureCube iimageCube
isamplerCubeArray itextureCubeArray iimageCubeArray
isamplerBuffer itextureBuffer iimageBuffer
isubpassInput
isubpassInputMS
Unsigned Integer Opaque Types
Type
usampler1D utexture1D uimage1D
usampler1DArray utexture1DArray uimage1DArray
usampler2D utexture2D uimage2D
usampler2DArray utexture1DArray uimage2DArray
usampler2DMS utexture2DMS uimage2DMS
usampler2DMSArray utexture2DMSArray uimage2DMSArray
usampler2DRect utexture2DRect uimage2DRect

Meaning a handle for accessing an integer 2D rectangle texture
a handle for accessing an integer 3D texture
a handle for accessing an integer cube mapped texture
a handle for accessing an integer cube map array texture
a handle for accessing an integer buffer texture
a handle for accessing an integer subpass input a handle for accessing a multi-sampled integer subpass input
Meaning a handle for accessing an unsigned integer 1D texture
a handle for accessing an unsigned integer 1D array texture
a handle for accessing an unsigned integer 2D texture
a handle for accessing an unsigned integer 2D array texture
a handle for accessing an unsigned integer 2D multisample texture
a handle for accessing an unsigned integer 2D multisample array texture
a handle for accessing an unsigned integer rectangle texture
27

Type usampler3D utexture3D uimage3D usamplerCube utextureCube uimageCube usamplerCubeArray utextureCubeArray uimageCubeArray usamplerBuffer utextureBuffer uimageBuffer atomic_uint
usubpassInput
usubpassInputMS

Meaning a handle for accessing an unsigned integer 3D texture
a handle for accessing an unsigned integer cube mapped texture
a handle for accessing an unsigned integer cube map array texture
a handle for accessing an unsigned integer buffer texture
a handle for accessing an unsigned integer atomic counter a handle for accessing an unsigned-integer subpass input a handle for accessing a multi-sampled unsigned-integer subpass input

Sampler Opaque Types

Type sampler
samplerShadow

Meaning
a handle for accessing state describing how to sample a texture
a handle for accessing state describing how to sample a depth texture with comparison

In addition, a shader can aggregate these basic types using arrays and structures to build more complex types.
There are no pointer types.
In this specification, an aggregate will mean a structure or array. (Matrices and vectors are not by themselves aggregates.) Aggregates, matrices, and vectors will collectively be referred to as composites.

4.1.1. Void
Functions that do not return a value must be declared as void. There is no default function return type. The keyword void cannot be used in any other declarations (except for empty formal or actual parameter lists), or a compile-time error results.

4.1.2. Booleans
Definition A boolean type is any boolean scalar or vector type (bool, bvec2, bvec3, bvec4)

28

To make conditional execution of code easier to express, the type bool is supported. There is no expectation that hardware directly supports variables of this type. It is a genuine Boolean type, holding only one of two values meaning either true or false. Two keywords true and false can be used as literal Boolean constants. Booleans are declared and optionally initialized as in the follow example:

bool success;

// declare "success" to be a Boolean

bool done = false; // declare and initialize "done"

Expressions used for conditional jumps (if, for, ?:, while, do-while) must evaluate to the type bool.
4.1.3. Integers
Definitions An integral type is any signed or unsigned, scalar or vector integer type. It excludes arrays and structures.
A scalar integral type is a scalar signed or unsigned integer type:
A vector integral type is a vector of signed or unsigned integers:
Signed and unsigned integer variables are fully supported. In this document, the term integer is meant to generally include both signed and unsigned integers.
For OpenGL, unsigned integers have exactly 32 bits of precision. When targeting Vulkan, highp unsigned integers have exactly 32 bits of precision.
For OpenGL, signed integers use 32 bits, including a sign bit, in twoâs complement form. When targeting Vulkan, highp signed integers use 32 bits, including a sign bit, in twoâs complement form.
When targeting Vulkan, mediump and lowp integers are as defined by the SPIR-V RelaxedPrecision decoration.
Addition, subtraction and multiplication resulting in overflow or underflow will result in the loworder 32 bits of the correct result R, where R is computed with enough precision to avoid overflow or underflow. Division resulting in overflow will result in an undefined value.
Integers are declared and optionally initialized with integer expressions, as in the following example:
int i, j = 42; // default integer literal type is int uint k = 3u; // "u" establishes the type as uint

Literal integer constants can be expressed in decimal (base 10), octal (base 8), or hexadecimal (base 16) as follows.
integer-constant :

29

decimal-constant integer-suffixopt octal-constant integer-suffixopt hexadecimal-constant integer-suffixopt
integer-suffix : one of u U
decimal-constant : nonzero-digit decimal-constant digit
octal-constant : 0 octal-constant octal-digit
hexadecimal-constant : 0x hexadecimal-digit 0X hexadecimal-digit hexadecimal-constant hexadecimal-digit
digit : 0 nonzero-digit
nonzero-digit : one of 1 2 3 4 5 6 7 8 9
octal-digit : one of 0 1 2 3 4 5 6 7
hexadecimal-digit : one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
No white space is allowed between the digits of an integer constant, including after the leading 0 or after the leading 0x or 0X of a constant, or before the suffix u or U. When tokenizing, the maximal token matching the above will be recognized before a new token is started. When the suffix u or U is present, the literal has type uint, otherwise the type is int. A leading unary minus sign (-) is interpreted as an arithmetic unary negation, not as part of the constant. Hence, literals themselves are always expressed with non-negative syntax, though they could result in a negative value.
It is a compile-time error to provide a literal integer whose bit pattern cannot fit in 32 bits. The bit pattern of the literal is always used unmodified. So a signed literal whose bit pattern includes a set sign bit creates a negative value.
For example,
30

1 1u -1
-1u
0xA0000000 0xABcdEF00u 0xffffffff 0x80000000 0xffffffffu 0xfffffffff 3000000000
2147483648 5000000000

// OK. Signed integer, value 1 // OK. Unsigned integer, value 1 // OK. Unary minus applied to signed integer. // result is a signed integer, value -1 // OK. Unary minus applies to unsigned integer. // Result is an unsigned integer, value 0xffffffff // OK. 32-bit signed hexadecimal // OK. 32-bit unsigned hexadecimal // OK. Signed integer, value -1 // OK. Evaluates to -2147483648 // OK. Unsigned integer, value 0xffffffff // Error: needs more than 32 bits // OK. A signed decimal literal taking 32 bits. // It evaluates to -1294967296 // OK. Evaluates to -2147483648 (the literal set the sign bit) // Error: needs more than 32 bits

4.1.4. Floats
Single-precision and double-precision floating-point variables are available for use in a variety of scalar calculations. Generally, the term floating-point will refer to both single- and double-precision floating-point. Floating-point variables are defined as in the following examples:
float a, b = 1.5; // single-precision floating-point double c, d = 2.0LF; // double-precision floating-point
As an input value to one of the processing units, a single-precision or double-precision floatingpoint variable is expected to match the corresponding IEEE 754 floating-point definition for precision and dynamic range. Floating-point variables within a shader are also encoded according to the IEEE 754 specification for single-precision floating-point values
(logically, not necessarily physically). While encodings are logically IEEE 754, operations (addition, multiplication, etc.) are not necessarily performed as required by IEEE 754. See âRange and Precisionâ for more details on precision and usage of NaNs (Not a Number) and Infs (positive or negative infinities).
Floating-point constants are defined as follows.
floating-constant : fractional-constant exponent-partopt floating-suffixopt digit-sequence exponent-part floating-suffixopt
fractional-constant : digit-sequence . digit-sequence digit-sequence . . digit-sequence

31

exponent-part : e signopt digit-sequence E signopt digit-sequence
sign : one of + -
digit-sequence : digit digit-sequence digit
floating-suffix : one of f F lf LF
A decimal point (.) is not needed if the exponent part is present. No white space may appear anywhere within a floating-point constant, including before a suffix. When tokenizing, the maximal token matching the above will be recognized before a new token is started. When the suffix "lf" or "LF" is present, the literal has type double. Otherwise, the literal has type float. A leading unary minus sign (-) is interpreted as a unary operator and is not part of the floating-point constant.
4.1.5. Vectors
The OpenGL Shading Language includes data types for generic 2-, 3-, and 4-component vectors of floating-point values, integers, and Booleans. Floating-point vector variables can be used to store colors, normals, positions, texture coordinates, texture lookup results and the like. Boolean vectors can be used for component-wise comparisons of numeric vectors. Some examples of vector declarations are:
vec2 texcoord1, texcoord2; vec3 position; vec4 myRGBA; ivec2 textureLookup; bvec3 less;
Initialization of vectors can be done with constructors. See âVector and Matrix Constructorsâ.
4.1.6. Matrices
The OpenGL Shading Language has built-in types for 2 Ã 2, 2 Ã 3, 2 Ã 4, 3 Ã 2, 3 Ã 3, 3 Ã 4, 4 Ã 2, 4 Ã 3, and 4 Ã 4 matrices of floating-point numbers. Matrix types beginning with "mat" have singleprecision components while matrix types beginning with "dmat" have double-precision components. The first number in the type is the number of columns, the second is the number of rows. If there is only one number, the matrix is square. Example matrix declarations:
32

mat2 mat2D; mat3 optMatrix; mat4 view, projection; mat4x4 view; // an alternate way of declaring a mat4 mat3x2 m; // a matrix with 3 columns and 2 rows dmat4 highPrecisionMVP; dmat2x4 dm;
Initialization of matrix values is done with constructors (described in âVector and Matrix Constructorsâ) in column-major order.
4.1.7. Opaque Types
Definition An opaque type is a type where the internal structure of the type is hidden from the language.
The opaque types, as listed in the following sections, declare variables that are effectively opaque handles to other objects. These objects are accessed through built-in functions, not through direct reading or writing of the declared variable. They can only be declared as function parameters or in uniform-qualified variables (see âUniform Variablesâ). The only opaque types that take memory qualifiers are the image types. Except for array indexing, structure member selection, and parentheses, opaque variables are not allowed to be operands in expressions; such use results in a compile-time error.
Opaque variables cannot be treated as l-values; hence cannot be used as out or inout function parameters, nor can they be assigned into. Any such use results in a compile-time error. However, they can be passed as in parameters with matching types and memory qualifiers. They cannot be declared with an initializer.
Because a single opaque type declaration effectively declares two objects, the opaque handle itself and the object it is a handle to, there is room for both a storage qualifier and a memory qualifier. The storage qualifier will qualify the opaque handle, while the memory qualifier will qualify the object it is a handle to.
Texture-Combined Samplers
Texture-combined sampler types (e.g. sampler2D) are the sampler types described in the Basic Types tables as handles for accessing textures. (They do not include sampler and samplerShadow.) There are distinct texture-combined sampler types for each texture target, and for each of float, integer, and unsigned integer data types. Texture accesses are done through built-in texture functions (described in âTexture Functionsâ) and texture-combined samplers are used to specify which texture to access and how it is to be filtered.
Texture-combined sampler types are opaque types, declared and behaving as described above for opaque types. When aggregated into arrays within a shader, they can only be indexed with a dynamically uniform integral expression, otherwise results are undefined.
33

Images
Image types are opaque types, declared and behaving as described above for opaque types. They can be further qualified with memory qualifiers. When aggregated into arrays within a shader, images can only be indexed with a dynamically uniform integral expression, otherwise results are undefined.
Image variables are handles to one-, two-, or three-dimensional images corresponding to all or a portion of a single level of a texture image bound to an image unit. There are distinct image variable types for each texture target, and for each of float, integer, and unsigned integer data types. Image accesses should use an image type that matches the target of the texture whose level is bound to the image unit, or for non-layered bindings of 3D or array images should use the image type that matches the dimensionality of the layer of the image (i.e., a layer of 3D, 2DArray, Cube, or CubeArray should use image2D, a layer of 1DArray should use image1D, and a layer of 2DMSArray should use image2DMS). If the image target type does not match the bound image in this manner, if the data type does not match the bound image, or if the format layout qualifier does not match the image unit format as described in section 8.25 âTexture Image Loads and Storesâ of the OpenGL Specification, the results of image accesses are undefined but cannot include program termination.
Image variables are used in the image load, store, and atomic functions described in âImage Functionsâ to specify an image to access.
Atomic Counters
Atomic counter types (e.g. atomic_uint) are opaque handles to counters, declared and behaving as described above for opaque types. The variables they declare specify which counter to access when using the built-in atomic counter functions as described in âAtomic Counter Functionsâ. They are bound to buffers as described in âAtomic Counter Layout Qualifiersâ.
Atomic counters aggregated into arrays within a shader can only be indexed with dynamically uniform integral expressions, otherwise results are undefined.
Members of structures cannot be declared as atomic counter types.
Atomic counter types are not available when targeting Vulkan.
Texture, sampler, and samplerShadow Types
Texture (e.g., texture2D), sampler, and samplerShadow types are opaque types, declared and behaving as described above for opaque types. These types are only available when targeting Vulkan. When aggregated into arrays within a shader, these types can only be indexed with a dynamically uniform expression, or texture lookup will result in undefined values. Texture variables are handles to one-, two-, and three-dimensional textures, cube maps, etc., as enumerated in the basic types tables. There are distinct texture types for each texture target, and for each of float, integer, and unsigned integer data types. Textures can be combined with a variable of type sampler or samplerShadow to create a texture-combined sampler type (e.g., sampler2D, or sampler2DShadow). This is done with a constructor, e.g., sampler2D(texture2D, sampler), sampler2DShadow(texture2D, sampler), sampler2DShadow(texture2D, samplerShadow), or sampler2D(texture2D, samplerShadow) and is described in more detail in section 5.4 "Constructors".
34

Subpass Inputs Subpass-input types are only available when targeting Vulkan.
Subpass-input types (e.g., subpassInput) are opaque types, declared and behaving as described above for opaque types. When aggregated into arrays within a shader, they can only be indexed with a dynamically uniform integral expression, otherwise results are undefined.
Subpass-input types are handles to two-dimensional single sampled or multi-sampled images, with distinct types for each of float, integer, and unsigned integer data types.
Subpass-input types are only available in fragment shaders. It is a compile-time error to use them in any other stage.
4.1.8. Structures
User-defined types can be created by aggregating other already defined types into a structure using the struct keyword. For example,
struct light { float intensity; vec3 position;
} lightVar;
In this example, light becomes the name of the new type, and lightVar becomes a variable of type light. To declare variables of the new type, use its name (without the keyword struct).
light lightVar2;
More formally, structures are declared as follows. However, the definitive grammar is as given in âShading Language Grammarâ.
struct-definition : qualifieropt struct nameopt_ { member-list } declaratorsopt ;
member-list : member-declaration ; member-declaration member-list ;
member-declaration : basic-type declarators ;
where name becomes the user-defined type, and can be used to declare variables to be of this new type. The name shares the same name space as other variables, types, and functions. All previously visible variables, types, constructors, or functions with that name are hidden. The optional qualifier only applies to any declarators, and is not part of the type being defined for name.
Structures must have at least one member declaration. Member declarators may contain precision
35

qualifiers, but use of any other qualifier results in a compile-time error. Bit fields are not supported. Member types must be already defined (there are no forward references). A compiletime error results if a member declaration contains an initializer. Member declarators can contain arrays. Such arrays must have a size specified, and the size must be a constant integral expression thatâs greater than zero (see âConstant Expressionsâ). Each level of structure has its own name space for names given in member declarators; such names need only be unique within that name space.
Anonymous structures are not supported. Embedded structure definitions are not supported. These result in compile-time errors.

struct S { float f; }; // Allowed: S is defined as a structure.

struct T {

S;

// Error: anonymous structures disallowed

struct { ... }; // Error: embedded structures disallowed

S s;

// Allowed: nested structure with a name.

};

Structures can be initialized at declaration time using constructors, as discussed in âStructure Constructorsâ.
Any restrictions on the usage of a type or qualifier also apply to any structure that contains a member of that type or qualifier. This also applies to structure members that are structures, recursively.
4.1.9. Arrays
Variables of the same type can be aggregated into arrays by declaring a name followed by brackets ([ ]) enclosing an optional size. When an array size is specified in a declaration, it must be an integral constant expression (see âConstant Expressionsâ) greater than zero. Except for the last declared member of a shader storage block (see section âInterface Blocksâ), the size of an array must be declared (explicitly sized) before it is indexed with anything other than a constant integral expression. The size of any array must be declared before passing it as an argument to a function. Violation of any of these rules result in compile-time errors. It is legal to declare an array without a size (unsized) and then later redeclare the same name as an array of the same type and specify a size, or index it only with constant integral expressions (implicitly sized). However, unless noted otherwise, blocks cannot be redeclared; an unsized array member in a user-declared block cannot be sized by a block redeclaration. It is a compile-time error to declare an array with a size, and then later (in the same shader) index the same array with a constant integral expression greater than or equal to the declared size. It is a compile-time error to redeclare an unsized array with a size equal to or smaller than any index used earlier in the shader to index the array. It is also a compile-time error to index an array with a negative constant expression. Arrays declared as formal parameters in a function declaration must specify a size. Undefined behavior results from indexing an array with a non-constant expression thatâs greater than or equal to the arrayâs size or less than 0. Arrays only have a single dimension (a single entry within "[ ]"), however, arrays of arrays can be declared. All types (basic types, structures, arrays) can be formed into an array.

36

All arrays are inherently homogeneous; made of elements all having the same type and size, with one exception. The exception is a shader storage block having an unsized array as its last member (run-time sized); an array can be formed from such a shader storage block, even if the storage blocks have differing lengths for their last member. Some examples are:
float frequencies[3]; uniform vec4 lightPosition[4]; light lights[]; const int numLights = 2; light lights[numLights]; // a shader storage block, introduced in section 4.3.7 "Buffer Variables" buffer b {
float u[]; // an error, unless u gets statically sized by link time vec4 v[]; // okay, v will be sized dynamically, if not statically } name[3]; // when the block is arrayed, all u will be the same size,
// but not necessarily all v, if sized dynamically
An array type can be formed by specifying non-array type followed by an array specifier. All dimensions of such an array specifier must include a size.
float[5] // an array of size [5] of float float[2][3] // an array of size [2][3] of float, not size [3] of float[2]
This type can be used anywhere any other type can be used, including as the return value from a function
float[5] foo() { }
as a constructor of an array:
float[5](3.4, 4.2, 5.0, 5.2, 1.1)
as an unnamed parameter:
void foo(float[5])
and as an alternate way of declaring a variable or function parameter:
float[5] a;
Arrays can have initializers formed from array constructors:
37

float a[5] = float[5](3.4, 4.2, 5.0, 5.2, 1.1); float a[5] = float[](3.4, 4.2, 5.0, 5.2, 1.1); // same thing

An array of arrays can be declared as: vec4 a[3][2]; // size-3 array of size-2 array of vec4

which declares a one-dimensional array of size 3 of one-dimensional arrays of size 2 of vec4. The following declarations do the same thing:
vec4[2] a[3]; // size-3 array of size-2 array of vec4 vec4[3][2] a; // size-3 array of size-2 array of vec4

When in transparent memory (like in a uniform block), the layout is that the inner-most (right-most in declaration) dimensions iterate faster than the outer dimensions. That is, for the above, the order in memory would be:
Low address : a[0][0] : a[0][1] : a[1][0] : a[1][1] : a[2][0] : a[2][1] : High address
The type of a needed for both constructors and nameless parameters is âvec4[3][2]â:

vec4 b[2] = vec4[2](vec4(0.0), vec4(0.1));

vec4[3][2] a = vec4[3][2](b, b, b);

// constructor

void foo(vec4[3][2]); // prototype with unnamed parameter

Alternatively, the initializer-list syntax can be used to initialize an array of arrays:
vec4 a[3][2] = { vec4[2](vec4(0.0), vec4(1.0)), vec4[2](vec4(0.0), vec4(1.0)), vec4[2](vec4(0.0), vec4(1.0)) };

Unsized arrays can be explicitly sized by an initializer at declaration time:
float a[5]; ... float b[] = a; // b is explicitly size 5 float b[5] = a; // means the same thing float b[] = float[](1,2,3,4,5); // also explicitly sizes to 5

However, it is a compile-time error to assign to an unsized array. Note, this is a rare case that initializers and assignments appear to have different semantics. For arrays of arrays, any unsized dimension is explicitly sized by the initializer:

38

vec4 a[][] = { vec4[2](vec4(0.0), vec4(1.0)), // okay, size to a[3][2] vec4[2](vec4(0.0), vec4(1.0)), vec4[2](vec4(0.0), vec4(1.0)) };
Arrays know the number of elements they contain. This can be obtained by using the length() method:
float a[5]; a.length(); // returns 5
This returns a type int. If an array has been explicitly sized, the value returned by the length() method is a constant expression. If an array has not been explicitly sized and is the last declared member of a shader storage block, the value returned will not be a constant expression and will be determined at runtime based on the size of the buffer object providing storage for the block. Such arrays are runtime sized. For runtime-sized arrays, the value returned by the length() method will be undefined if the array is contained in an array of shader storage blocks that is indexed with a non-constant expression less than zero or greater than or equal to the number of blocks in the array.
The length() method cannot be called on an array that is not runtime sized and also has not yet been explicitly sized; this results in a compile-time error.
When the length() method returns a compile-time constant, the expression the length() method is applied to cannot contain any side effects, such as writes to l-values within the expression, or function calls that themselves have side effects: only the compile-time constant length itself need be computed. Behavior and results, including any compile-time error reporting, are undefined if the expression contains other effects.
float a, b; const int s = float[2](a=3.0, ++b).length(); // illegal side effects
The length() method works equally well for arrays of arrays:
vec4 a[3][2]; a.length() // this is 3 a[x].length() // this is 2
When the length() method returns a compile-time constant, the expression in brackets (x above) will be parsed and subjected to the rules required for array indices, but the array will not be dereferenced. Thus, behavior is well defined even if the run-time value of the expression is out of bounds, as long as the expression contains no side effects.
When the length() method returns a run-time value (not a compile-time constant), the array will be dereferenced. E.g., if x is not a compile-time constant and is out of range, an undefined value results. More generally, all involved expressions are fully evaluated and executed.
39

// for a compile time-sized array b containing a member array a: b[x+3].a.length(); // b is never dereferenced, x+3 is evaluated and checked b[++x].a.length(); // not allowed; results are undefined
// for an array s of a shader storage object (run-time sized) containing a member array a: s[++x].a.length(); // s is dereferenced; ++x needs to be a valid index

For implicitly-sized or run-time-sized arrays, only the outer-most dimension can be lacking a size. A type that includes an unknown array size cannot be formed into an array until it gets an explicit size, except for shader storage blocks where the only unsized array member is the last member of the block.
In a shader storage block, the last member may be declared without an explicit size. In this case, the effective array size is inferred at run-time from the size of the data store backing the interface block. Such run-time-sized arrays may be indexed with general integer expressions. However, it is a compile-time error to pass them as an argument to a function or index them with a negative constant expression.

4.1.10. Implicit Conversions
In some situations, an expression and its type will be implicitly converted to a different type. The following table shows all allowed implicit conversions:

Type of expression
int
int uint
int uint float
ivec2
ivec3
ivec4
ivec2 uvec2
ivec3 uvec3
ivec4 uvec4
ivec2 uvec2 vec2

Can be implicitly converted to uint float
double
uvec2 uvec3 uvec4 vec2
vec3
vec4
dvec2

40

Type of expression ivec3 uvec3 vec3 ivec4 uvec4 vec4 mat2 mat3 mat4 mat2x3 mat2x4 mat3x2 mat3x4 mat4x2 mat4x3

Can be implicitly converted to dvec3
dvec4
dmat2 dmat3 dmat4 dmat2x3 dmat2x4 dmat3x2 dmat3x4 dmat4x2 dmat4x3

There are no implicit array or structure conversions. For example, an array of int cannot be implicitly converted to an array of float.
When an implicit conversion is done, it is the same conversion that would be done under explicit conversion, using a constructor. The explicit conversions via constructors are described in Conversion and Scalar Constructors.
When performing implicit conversion for binary operators, there may be multiple data types to which the two operands can be converted. For example, when adding an int value to a uint value, both values can be implicitly converted to uint, float, and double. In such cases, a floating-point type is chosen if either operand has a floating-point type. Otherwise, an unsigned integer type is chosen if either operand has an unsigned integer type. Otherwise, a signed integer type is chosen. If operands can be implicitly converted to multiple data types deriving from the same base data type, the type with the smallest component size is used.
The conversions in the table above are done only as indicated by other sections of this specification.

4.1.11. Initializers
At declaration, an initial value for a variable may be provided, specified as an equals (=) followed by an initializer. The initializer is either an assignment-expression or a list of initializers enclosed in curly braces. The grammar for the initializer is:
initializer : assignment-expression { initializer-list } { initializer-list , }

41

initializer-list : initializer initializer-list , initializer
The assignment-expression is a normal expression except that a comma (,) outside parentheses is interpreted as the end of the initializer, not as the sequence operator. As explained in more detail below, this allows creation of nested initializers: The variable type and its initializer must exactly match in terms of nesting, number of components/elements/members present at each level, and types of components/elements/members. An assignment-expression at global scope can include calls to user-defined functions.
An assignment-expression in an initializer must be either the same type as the object it initializes or be a type that can be converted to the objectâs type according to âImplicit Conversionsâ. Since these include constructors, a composite variable can be initialized by either a constructor or an initializer list; and an element in an initializer list can be a constructor.
If an initializer is a list of initializers enclosed in curly braces, the variable being declared must be a vector, a matrix, an array, or a structure.

int i = { 1 }; // illegal, i is not a composite

A list of initializers enclosed in a matching set of curly braces is applied to one composite. This may be the variable being declared or a composite contained in the variable being declared. Individual initializers from the initializer list are applied to the elements/members of the composite, in order.
If the composite has a vector type, initializers from the list are applied to the components of the vector, in order, starting with component 0. The number of initializers must match the number of components.
If the composite has a matrix type, initializers from the list must be vector initializers and are applied to the columns of the matrix, in order, starting with column 0. The number of initializers must match the number of columns.
If the composite has a structure type, initializers from the list are applied to the members of the structure, in the order declared in the structure, starting with the first member. The number of initializers must match the number of members.
Applying these rules, the following matrix declarations are equivalent:

mat2x2 a = mat2( vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) );

mat2x2 b =

{ vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) };

mat2x2 c =

{ { 1.0, 0.0 }, { 0.0, 1.0 } };

All of the following declarations result in a compile-time error.

42

float a[2] = { 3.4, 4.2, 5.0 };

// illegal

vec2 b = { 1.0, 2.0, 3.0 };

// illegal

mat3x3 c = { vec3(0.0), vec3(1.0), vec3(2.0), vec3(3.0) }; // illegal

mat2x2 d = { 1.0, 0.0, 0.0, 1.0 };

// illegal, can't flatten nesting

struct {

float a;

int b;

} e = { 1.2, 2, 3 };

// illegal

In all cases, the inner-most initializer (i.e., not a list of initializers enclosed in curly braces) applied to an object must have the same type as the object being initialized or be a type that can be converted to the objectâs type according to âImplicit Conversionsâ. In the latter case, an implicit conversion will be done on the initializer before the assignment is done.
struct { float a; int b;
} e = { 1.2, 2 }; // legal, all types match struct {
float a; int b; } e = { 1, 3 }; // legal, first initializer is converted

All of the following declarations result in a compile-time error.

int a = true;

// illegal

vec4 b[2] = { vec4(0.0), 1.0 };

// illegal

mat4x2 c = { vec3(0.0), vec3(1.0) }; // illegal

struct S1 { vec4 a; vec4 b;
};

struct { float s; float t;
} d[] = { S1(vec4(0.0), vec4(1.1)) }; // illegal

If an initializer (of either form) is provided for an unsized array, the size of the array is determined by the number of top-level (non-nested) initializers within the initializer. All of the following declarations create arrays explicitly sized with five elements:

43

float a[] = float[](3.4, 4.2, 5.0, 5.2, 1.1);

float b[] = { 3.4, 4.2, 5.0, 5.2, 1.1 };

float c[] = a;

// c is explicitly size 5

float d[5] = b;

// means the same thing

It is a compile-time error to have too few or too many initializers in an initializer list for the composite being initialized. That is, all elements of an array, all members of a structure, all columns of a matrix, and all components of a vector must have exactly one initializer expression present, with no unconsumed initializers.
4.2. Scoping
The scope of a variable is determined by where it is declared. If it is declared outside all function definitions, it has global scope, which starts from where it is declared and persists to the end of the shader it is declared in. If it is declared in a while test or a for statement, then it is scoped to the end of the following sub-statement. If it is declared in an if or else statement, it is scoped to the end of that statement. (See âSelectionâ and âIterationâ for the location of statements and substatements.) Otherwise, if it is declared as a statement within a compound statement, it is scoped to the end of that compound statement. If it is declared as a parameter in a function definition, it is scoped until the end of that function definition. A functionâs parameter declarations and body together form a single scope nested in the global scope. The if statementâs expression does not allow new variables to be declared, hence does not form a new scope.
Within a declaration, the scope of a name starts immediately after the initializer if present or immediately after the name being declared if not. Several examples:

44

int x = 1; {
int x = 2, y = x; // y is initialized to 2 }

struct S {
int x; };

{

S S = S(0); // 'S' is only visible as a struct and constructor

S;

// 'S' is now visible as a variable

}

int x = x; // Error if x has not been previously defined. // If the previous definition of x was in this // same scope, this causes a redeclaration error.

int f( /* nested scope begins here */ int k) {
int k = k + 3; // redeclaration error of the name k ... }

int f(int k) {
{ int k = k + 3; // 2nd k is parameter, initializing nested first k int m = k; // use of new k, which is hiding the parameter
} }

For both for and while loops, the sub-statement itself does not introduce a new scope for variable names, so the following has a redeclaration compile-time error:
for ( /* nested scope begins here */ int i = 0; i < 10; i++) { int i; // redeclaration error
}

The body of a do-while loop introduces a new scope lasting only between the do and while (not including the while test expression), whether or not the body is simple or compound:
int i = 17; do
int i = 4; // okay, in nested scope_ while (i == 0); // i is 17, scoped outside the do-while body

45

The statement following a switch (â¦) forms a nested scope.
All variable names, structure type names, and function names in a given scope share the same name space. Function names can be redeclared in the same scope, with the same or different parameters, without error. An implicitly-sized array can be redeclared in the same scope as an array of the same base type. Otherwise, within one compilation unit, a declared name cannot be redeclared in the same scope; doing so results in a redeclaration compile-time error. If a nested scope redeclares a name used in an outer scope, it hides all existing uses of that name. There is no way to access the hidden name or make it unhidden, without exiting the scope that hid it.
The built-in functions are scoped in a scope outside the global scope that users declare global variables in. That is, a shaderâs global scope, available for user-defined functions and global variables, is nested inside the scope containing the built-in functions. When a function name is redeclared in a nested scope, it hides all functions declared with that name in the outer scope. Function declarations (prototypes) cannot occur inside of functions; they must be at global scope, or for the built-in functions, outside the global scope, otherwise a compile-time error results.
Shared globals are global variables declared with the same name in independently compiled units (shaders) within the same language (i.e., same stage, e.g. vertex) that are linked together when making a single program. (Globals forming the interface between two different shader languages are discussed in other sections.) Shared globals share the same name space, and must be declared with the same type. They will share the same storage.
Shared global arrays must have the same base type and the same explicit size. An array implicitly sized in one shader can be explicitly sized by another shader in the same stage. If no shader in a stage has an explicit size for the array, the largest implicit size (one more than the largest index used) in that stage is used. There is no cross-stage array sizing. If there is no static access to an implicitly sized array within the stage declaring it, then the array is given a size of 1, which is relevant when the array is declared within an interface block that is shared with other stages or the application (other unused arrays might be eliminated by the optimizer).
Shared global scalars must have exactly the same type name and type definition. Structures must have the same name, sequence of type names, and type definitions, and member names to be considered the same type. This rule applies recursively for nested or embedded types. If a shared global has multiple initializers, the initializers must all be constant expressions, and they must all have the same value. Otherwise, a link-time error will result. (A shared global having only one initializer does not require that initializer to be a constant expression.)

4.3. Storage Qualifiers

Variable declarations may have at most one storage qualifier specified in front of the type. These are summarized as

Storage Qualifier <none: default>
const

Meaning
local read/write memory, or an input parameter to a function
a variable whose value cannot be changed

46

Storage Qualifier in out attribute uniform
varying
buffer
shared

Meaning
linkage into a shader from a previous stage, variable is copied in
linkage out of a shader to a subsequent stage, variable is copied out
compatibility profile only and vertex language only; same as in when in a vertex shader
value does not change across the primitive being processed, uniforms form the linkage between a shader, API, and the application
compatibility profile only and vertex and fragment languages only; same as out when in a vertex shader and same as in when in a fragment shader
value is stored in a buffer object, and can be read or written both by shader invocations and the API
compute shader only; variable storage is shared across all work items in a workgroup

Some input and output qualified variables can be qualified with at most one additional auxiliary storage qualifier:

Auxiliary Storage Qualifier centroid sample patch

Meaning centroid-based interpolation per-sample interpolation per-tessellation-patch attributes

Not all combinations of qualification are allowed. Auxiliary storage qualifiers can only be used with the in or out storage qualifiers. Additional qualifier rules are defined in upcoming sections.
Local variables can only use the const storage qualifier (or use no storage qualifier).
Note that function parameters can use const, in, and out qualifiers, but as parameter qualifiers. Parameter qualifiers are discussed in âFunction Calling Conventionsâ.
Function return types and structure members do not use storage qualifiers.
Initializers in global declarations may only be used in declarations of global variables with no storage qualifier, with a const qualifier, or with a uniform qualifier.
Global variables without storage qualifiers that are not initialized in their declaration or by the application will not be initialized, but rather will enter main() with undefined values.
When comparing an output from one shader stage to an input of a subsequent shader stage, the input and output donât match if their auxiliary qualifiers (or lack thereof) are not the same.

47

4.3.1. Default Storage Qualifier
If no qualifier is present on a global variable, then the variable has no linkage to the application or shaders running on other pipeline stages. For either global or local unqualified variables, the declaration will appear to allocate memory associated with the processor it targets. This variable will provide read/write access to this allocated memory.
4.3.2. Constant Qualifier
Named compile-time constants or read-only variables can be declared using the const qualifier. The const qualifier can be used with any of the non-void transparent basic data types, as well as with structures and arrays of these. It is a compile-time error to write to a const variable outside of its declaration, so they must be initialized when declared. For example,
const vec3 zAxis = vec3 (0.0, 0.0, 1.0); const float ceiling = a + b; // a and b not necessarily constants
Structure members may not be qualified with const. Structure variables can be declared as const, and initialized with a structure constructor or initializer.
Initializers for const declarations at global scope must be constant expressions, as defined in âConstant Expressionsâ.
4.3.3. Constant Expressions
SPIR-V specialization constants are expressed in GLSL as const with the layout qualifier constant_id, as described in âSpecialization-Constant Qualifier.â
A constant expression is one of
â¢ A literal value (e.g. 5 or true). â¢ A variable declared with the const qualifier and an initializer, where the initializer is a constant
expression. This includes both const declared with a specialization-constant layout qualifier, e.g. layout(constant_id = â¦), and those declared without a specialization-constant layout qualifier. â¢ Built-in variables qualified as const. â¢ An expression formed by an operator on operands that are all constant expressions, including getting an element of a constant array, or a member of a constant structure, or components of a constant vector. However, the lowest precedence operators of the sequence operator (,) and the assignment operators (=, +=, â¦) are not included in the operators that can create a constant expression. Also, an array access with a specialization constant as an index does not result in a constant expression. â¢ Valid use of the length() method on an explicitly sized object, whether or not the object itself is constant (implicitly sized or run-time sized arrays do not return a constant expression). â¢ A constructor whose arguments are all constant expressions. â¢ For non-specialization constants only: The value returned by certain built-in function calls
48

whose arguments are all constant expressions, including at least the list below. Any other builtin function that does not access memory (not the texture lookup functions, image access, atomic counter, etc.), that has a non-void return type, that has no out parameter, and is not a noise function might also be considered a constant. When a function is called with an argument that is a specialization constant, the result is not a constant expression.
â¦ Angle and Trigonometric Functions âª radians âª degrees âª sin âª cos âª asin âª acos
â¦ Exponential Functions âª pow âª exp âª log âª exp2 âª log2 âª sqrt âª inversesqrt
â¦ Common Functions âª abs âª sign âª floor âª trunc âª round âª ceil âª mod âª min âª max âª clamp
â¦ Geometric Functions âª length âª dot âª normalize
â¢ Function calls to user-defined functions (non-built-in functions) cannot be used to form
49

constant expressions.
A constant integral expression is a constant expression that evaluates to a scalar signed or unsigned integer.
Constant expressions will be evaluated in an invariant way so as to create the same value in multiple shaders when the same constant expressions appear in those shaders. See âThe Invariant Qualifierâ for more details on how to create invariant expressions and âPrecision Qualifiersâ for detail on how expressions are evaluated.
Constant expressions respect the precise and invariant qualifiers but will be always be evaluated in an invariant way, independent of the use of such qualification, so as to create the same value in multiple shaders when the same constant expressions appear in those shaders. See âThe Invariant Qualifierâ and âThe Precise Qualifierâ for more details on how to create invariant expressions.
Constant-expressions may be evaluated by a host platform, and are therefore not required to compute the same value that the same expression would evaluate to on the shader execution target. However, the host must use the same or greater precision than the target would use. When the precision qualification cannot be determined, the expression is evaluated at highp. See âDefault Precision Qualifiersâ.
Specialization-constant expressions are never evaluated by the compiler front end, but instead retain the expressionâs operations needed to evaluate them later on the host.

4.3.4. Input Variables
Shader input variables are declared with the in storage qualifier. They form the input interface between previous stages of the API pipeline and the declaring shader. Input variables must be declared at global scope. Values from the previous pipeline stage are copied into input variables at the beginning of shader execution. It is a compile-time error to write to a variable declared as an input.
Only the input variables that are statically read need to be written by the previous stage; it is allowed to have superfluous declarations of input variables. This is shown in the following table.

Treatment of Mismatched Input Variables

Consuming Shader (input variables)

No

Declared but no Declared and Static Use

Declarati Static Use

on

Generating Shader (output variables)

No Declaration Allowed
Declared but no Allowed Static Use

Allowed Allowed

Link-Time Error
Allowed (values are undefined)

Declared and Static Use

Allowed Allowed

Allowed (values are potentially undefined)

Consumption errors are based on static use only. Compilation may generate a warning, but not an error, for any dynamic use the compiler can deduce that might cause consumption of undefined values.

50

See âBuilt-In Variablesâ for a list of the built-in input names.
Vertex shader input variables (or attributes) receive per-vertex data. It is a compile-time error to use auxiliary storage or interpolation qualifiers on a vertex shader input. The values copied in are established by the API or through the use of the layout identifier location.
It is a compile-time error to declare a vertex shader input with, or that contains, any of the following types:
â¢ A boolean type â¢ An opaque type â¢ A structure
Example declarations in a vertex shader:
in vec4 position; in vec3 normal; in vec2 texCoord[4];
It is expected that graphics hardware will have a small number of fixed vector locations for passing vertex inputs. Therefore, the OpenGL Shading Language defines each non-matrix input variable as taking up one such vector location. There is an implementation-dependent limit on the number of locations that can be used, and if this is exceeded it will cause a link-time error. (Declared input variables that are not statically used do not count against this limit.) A scalar input counts the same amount against this limit as a vec4, so applications may want to consider packing groups of four unrelated float inputs together into a vector to better utilize the capabilities of the underlying hardware. A matrix input will use up multiple locations. The number of locations used will equal the number of columns in the matrix.
Tessellation control, evaluation, and geometry shader input variables get the per-vertex values written out by output variables of the same names in the previous active shader stage. For these inputs, centroid and interpolation qualifiers are allowed, but have no effect. Since tessellation control, tessellation evaluation, and geometry shaders operate on a set of vertices, each input variable (or input block, see interface blocks below) needs to be declared as an array. For example,
in float foo[]; // geometry shader input for vertex "out float foo"
Each element of such an array corresponds to one vertex of the primitive being processed. Each array can optionally have a size declared. For geometry shaders, the array size will be set by, (or if provided must be consistent with) the input layout declaration(s) establishing the type of input primitive, as described later in âInput Layout Qualifiersâ.
Some inputs and outputs are arrayed, meaning that for an interface between two shader stages either the input or output declaration requires an extra level of array indexing for the declarations to match. For example, with the interface between a vertex shader and a geometry shader, vertex shader output variables and geometry shader input variables of the same name must have matching types, except that the geometry shader will have one more array dimension than the
51

vertex shader, to allow for vertex indexing. If such an arrayed interface variable is not declared with the necessary additional input or output array dimension, a link-time error will result. Geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. These inputs and outputs are known as per-vertex-arrayed inputs and outputs. Component limits for arrayed interfaces (e.g. gl_MaxTessControlInputComponents) are limits per vertex, not limits for the entire interface.
For non-arrayed interfaces (meaning array dimensionally stays the same between stages), it is a link-time error if the input variable is not declared with the same type, including array dimensionality, as the matching output variable.
The link-time type-matching rules apply to all declared input and output variables, whether or not they are used.
Additionally, tessellation evaluation shaders support per-patch input variables declared with the patch and in qualifiers. Per-patch input variables are filled with the values of per-patch output variables written by the tessellation control shader. Per-patch inputs may be declared as onedimensional arrays, but are not indexed by vertex number. Applying the patch qualifier to inputs can only be done in tessellation evaluation shaders. As with other input variables, per-patch inputs must be declared using the same type and qualification as per-patch outputs from the previous (tessellation control) shader stage. It is a compile-time error to use patch with inputs in any other stage.
It is a compile-time error to declare a tessellation control, tessellation evaluation or geometry shader input with, or that contains, any of the following types:
â¢ A boolean type â¢ An opaque type
Fragment shader inputs get per-fragment values, typically interpolated from a previous stageâs outputs. The auxiliary storage qualifiers centroid and sample can also be applied, as well as the interpolation qualifiers flat, noperspective, and smooth.
It is a compile-time error to declare a fragment shader input with, or that contains, any of the following types:
â¢ A boolean type â¢ An opaque type
Fragment shader inputs that are, or contain, integral or double-precision floating-point types must be qualified with the interpolation qualifier flat.
Fragment inputs are declared as in the following examples:
52

in vec3 normal; centroid in vec2 TexCoord; invariant centroid in vec4 Color; noperspective in float temperature; flat in vec3 myColor; noperspective centroid in vec2 myTexCoord;
The fragment shader inputs form an interface with the last active shader in the vertex processing pipeline. For this interface, the last active shader stage output variables and fragment shader input variables of the same name must match in type and qualification, with a few exceptions: The storage qualifiers must, of course, differ (one is in and one is out). Also, interpolation qualification (e.g. flat) and auxiliary qualification (e.g. centroid) may differ. These mismatches are allowed between any pair of stages. When interpolation or auxiliary qualifiers do not match, those provided in the fragment shader supersede those provided in previous stages. If any such qualifiers are completely missing in the fragment shaders, then the default is used, rather than any qualifiers that may have been declared in previous stages. That is, what matters is what is declared in the fragment shaders, not what is declared in shaders in previous stages.
When an interface between shader stages is formed using shaders from two separate program objects, it is not possible to detect mismatches between inputs and outputs when the programs are linked. When there are mismatches between inputs and outputs on such interfaces, the values passed across the interface will be partially or completely undefined.
Shaders can ensure matches across such interfaces either by using input and output layout qualifiers (sections âInput Layout Qualifiersâ and âOutput Layout Qualifiersâ) or by using identical input and output declarations of blocks or variables. Complete rules for interface matching are found in section 7.4.1 âShader Interface Matchingâ of the OpenGL Specification.
Compute shaders do not permit user-defined input variables and do not form a formal interface with any other shader stage. See âCompute Shader Special Variablesâ for a description of built-in compute shader input variables. All other input to a compute shader is retrieved explicitly through image loads, texture fetches, loads from uniforms or uniform buffers, or other user supplied code. Redeclaration of built-in input variables in compute shaders is not permitted.
4.3.5. Uniform Variables
The uniform qualifier is used to declare global variables whose values are the same across the entire primitive being processed. All uniform variables are read-only and are initialized externally either at link time or through the API. The link-time initial value is either the value of the variableâs initializer, if present, or 0 if no initializer is present. Opaque types cannot have initializers, or a compile-time error results. When targeting Vulkan, it is a compile-time error to declare uniform variables outside a block.
Example declarations are:
uniform vec4 lightPosition; uniform vec3 color = vec3(0.7, 0.7, 0.2); // value assigned at link time
53

The uniform qualifier can be used with any of the basic data types, or when declaring a variable whose type is a structure, or an array of any of these.
There is an implementation-dependent limit on the amount of storage for uniforms that can be used for each type of shader and if this is exceeded it will cause a compile-time or link-time error. Uniform variables that are declared but not used do not count against this limit. The number of user-defined uniform variables and the number of built-in uniform variables that are used within a shader are added together to determine whether available uniform storage has been exceeded.
Uniforms in shaders all share a single global name space when linked into a program or separable program. Hence, the types, initializers, and any location specifiers of all statically used uniform variables with the same name must match across all shaders that are linked into a single program. However it is not required to repeat the initializer or location specifier in all the linked shaders. While this single uniform name space is cross stage, a uniform variable nameâs scope is per stage: If a uniform variable name is declared in one stage (e.g. a vertex shader) but not in another (e.g. a fragment shader), then that name is still available in the other stage for a different use.
4.3.6. Output Variables
Shader output variables are declared with the out storage qualifier. They form the output interface between the declaring shader and the subsequent stages of the API pipeline. Output variables must be declared at global scope. During shader execution they will behave as normal unqualified global variables. Their values are copied out to the subsequent pipeline stage on shader exit. Only output variables that are read by the subsequent pipeline stage need to be written; it is allowed to have superfluous declarations of output variables.
There is not an inout storage qualifier for declaring a single variable name as both input and output to a shader. Also, a variable cannot be declared with both the in and the out qualifiers, this will result in a compile-time or link-time error. Output variables must be declared with different names than input variables. However, nesting an input or output inside an interface block with an instance name allows the same names with one referenced through a block instance name.
Vertex, tessellation evaluation, and geometry output variables output per-vertex data and are declared using the out storage qualifier. Applying patch to an output can only be done in a tessellation control shader. It is a compile-time error to use patch on outputs in any other stage.
It is a compile-time error to declare a vertex, tessellation evaluation, tessellation control, or geometry shader output with, or that contains, any of the following types:
â¢ A boolean type â¢ An opaque type
Individual outputs are declared as in the following examples:
54

out vec3 normal; centroid out vec2 TexCoord; invariant centroid out vec4 Color; flat out vec3 myColor; sample out vec4 perSampleColor;
These can also appear in interface blocks, as described in âInterface Blocksâ. Interface blocks allow simpler addition of arrays to the interface from vertex to geometry shader. They also allow a fragment shader to have the same input interface as a geometry shader for a given vertex shader.
Tessellation control shader output variables are used to output per-vertex and per-patch data. Pervertex output variables are arrayed (see arrayed under âInput Variablesâ) and declared using the out qualifier without the patch qualifier. Per-patch output variables are declared using the patch and out qualifiers.
Since tessellation control shaders produce an arrayed primitive comprising multiple vertices, each per-vertex output variable (or output block, see interface blocks below) needs to be declared as an array. For example,
out float foo[]; // feeds next stage input "in float foo[]"
Each element of such an array corresponds to one vertex of the primitive being produced. Each array can optionally have a size declared. The array size will be set by (or if provided must be consistent with) the output layout declaration(s) establishing the number of vertices in the output patch, as described later in âTessellation Control Outputsâ.
Each tessellation control shader invocation has a corresponding output patch vertex, and may assign values to per-vertex outputs only if they belong to that corresponding vertex. If a per-vertex output variable is used as an l-value, it is a compile-time or link-time error if the expression indicating the vertex index is not the identifier gl_InvocationID.
The order of execution of a tessellation control shader invocation relative to the other invocations for the same input patch is undefined unless the built-in function barrier() is used. This provides some control over relative execution order. When a shader invocation calls barrier(), its execution pauses until all other invocations have reached the same point of execution. Output variable assignments performed by any invocation executed prior to calling barrier() will be visible to any other invocation after the call to barrier() returns.
Because tessellation control shader invocations execute in undefined order between barriers, the values of per-vertex or per-patch output variables will sometimes be undefined. Consider the beginning and end of shader execution and each call to barrier() as synchronization points. The value of an output variable will be undefined in any of the three following cases:
1. At the beginning of execution. 2. At each synchronization point, unless
â¦ the value was well-defined after the previous synchronization point and was not written by
55

any invocation since, or â¦ the value was written by exactly one shader invocation since the previous synchronization
point, or â¦ the value was written by multiple shader invocations since the previous synchronization
point, and the last write performed by all such invocations wrote the same value.
3. When read by a shader invocation, if
â¦ the value was undefined at the previous synchronization point and has not been written by the same shader invocation since, or
â¦ the output variable is written to by any other shader invocation between the previous and next synchronization points, even if that assignment occurs in code following the read.
Fragment outputs output per-fragment data and are declared using the out storage qualifier. It is a compile-time error to use auxiliary storage qualifiers or interpolation qualifiers in a fragment shader output declaration. It is a compile-time error to declare a fragment shader output with, or that contains, any of the following types:
â¢ A boolean type â¢ A double-precision scalar or vector (double, dvec2, dvec3, dvec4) â¢ An opaque type â¢ A matrix type â¢ A structure
Fragment outputs are declared as in the following examples:
out vec4 FragmentColor; out uint Luminosity;
Compute shaders have no built-in output variables, do not support user-defined output variables and do not form a formal interface with any other shader stage. All outputs from a compute shader take the form of the side effects such as image stores and operations on atomic counters.
4.3.7. Buffer Variables
The buffer qualifier is used to declare global variables whose values are stored in the data store of a buffer object bound through the API. Buffer variables can be read and written, with the underlying storage shared among all active shader invocations. Buffer variable memory reads and writes within a single shader invocation are processed in order. However, the order of reads and writes performed in one invocation relative to those performed by another invocation is largely undefined. Buffer variables may be qualified with memory qualifiers affecting how the underlying memory is accessed, as described in âMemory Qualifiersâ.
The buffer qualifier can be used to declare interface blocks (see âInterface Blocksâ), which are then referred to as shader storage blocks. It is a compile-time error to declare buffer variables outside a
56

block.

// use buffer to create a buffer block (shader storage block)

buffer BufferName { // externally visible name of buffer

int count;

// typed, shared memory...

...

// ...

vec4 v[];

// last member may be an array that is not sized

// until after link time (dynamically sized)

} Name;

// name of block within the shader

There are implementation-dependent limits on the number of shader storage blocks used for each type of shader, the combined number of shader storage blocks used for a program, and the amount of storage required by each individual shader storage block. If any of these limits are exceeded, it will cause a compile-time or link-time error.
If multiple shaders are linked together, then they will share a single global buffer variable name space. Hence, the types of all declared buffer variables with the same name must match across all shaders that are linked into a single program.
4.3.8. Shared Variables
The shared qualifier is used to declare global variables that have storage shared between all work items in a compute shader workgroup. Variables declared as shared may only be used in compute shaders (see âCompute Processorâ). Any other declaration of a shared variable is a compile-time error. Shared variables are implicitly coherent (see âMemory Qualifiersâ).
Variables declared as shared may not have initializers and their contents are undefined at the beginning of shader execution. Any data written to shared variables will be visible to other work items (executing the same shader) within the same workgroup.
In the absence of synchronization, the order of reads and writes to the same shared variable by different invocations of a shader is not defined.
In order to achieve ordering with respect to reads and writes to shared variables, control flow barriers must be employed using the barrier() function (see âShader Invocation Control Functionsâ).
There is a limit to the total size of all variables declared as shared in a single program. This limit, expressed in units of basic machine units may be determined by using the OpenGL API to query the value of MAX_COMPUTE_SHARED_MEMORY_SIZE.
4.3.9. Interface Blocks
Input, output, uniform, and buffer variable declarations can be grouped into named interface blocks to provide coarser granularity backing than is achievable with individual declarations. They can have an optional instance name, used in the shader to reference their members. An output block of one programmable stage is backed by a corresponding input block in the subsequent programmable stage. A uniform block is backed by the application with a buffer object. A block of buffer variables, called a shader storage block, is also backed by the application with a buffer object.

57

It is a compile-time error to have an input block in a vertex shader or an output block in a fragment shader. These uses are reserved for future use.
An interface block is started by an in, out, uniform, or buffer keyword, followed by a block name, followed by an open curly brace ({) as follows:
interface-block : layout-qualifieropt interface-qualifier block-name { member-list } instance-nameopt ;
interface-qualifier : in out patch in // Note: Qualifiers can be in any order. patch out uniform buffer
member-list : member-declaration member-declaration member-list
member-declaration : layout-qualifieropt qualifiersopt type declarators ;
instance-name : identifier identifier [ ] identifier [ constant-integral-expression ]
Each of the above elements is discussed below, with the exception of layout qualifiers (layoutqualifier), which are defined in the next section.
First, an example,

uniform Transform {

mat4 ModelViewMatrix;

mat4 ModelViewProjectionMatrix;

uniform mat3 NormalMatrix;

// allowed restatement of qualifier

float Deformation;

};

The above establishes a uniform block named âTransformâ with four uniforms grouped inside it.
Types and declarators are the same as for other input, output, uniform, and buffer variable declarations outside blocks, with these exceptions:
â¢ Initializers are not allowed â¢ Opaque types are not allowed

58

â¢ Structure definitions cannot be nested inside a block
Any of these would result in a compile-time error.
If no optional qualifier is used in a member-declaration, the qualification of the member includes all in, out, patch, uniform, or buffer as determined by interface-qualifier. If optional qualifiers are used, they can include interpolation qualifiers, auxiliary storage qualifiers, and storage qualifiers and they must declare an input, output, or uniform member consistent with the interface qualifier of the block: Input variables, output variables, uniform variables, and buffer members can only be in in blocks, out blocks, uniform blocks, and shader storage blocks, respectively.
Repeating the in, out, patch, uniform, or buffer interface qualifier for a memberâs storage qualifier is optional. For example,

in Material {

smooth in vec4 Color1; // legal, input inside in block

smooth vec4 Color2; // legal, 'in' inherited from 'in Material'

vec2 TexCoord;

// legal, TexCoord is an input

uniform float Atten; // illegal, mismatched storage qualifier

};

A shader interface is defined to be one of these:
â¢ All the uniform variables and uniform blocks declared in a program. This spans all compilation units linked together within one program.
â¢ All the buffer blocks declared in a program.
â¢ The boundary between adjacent programmable pipeline stages: This spans all the outputs declared in all compilation units of the first stage and all the inputs declared in all compilation units of the second stage. Note that for the purposes of this definition, the fragment shader and the preceding shader are considered to have a shared boundary even though in practice, all values passed to the fragment shader first pass through the rasterizer and interpolator.
The block name (block-name) is used to match within shader interfaces: an output block of one pipeline stage will be matched to an input block with the same name in the subsequent pipeline stage. For uniform or shader storage blocks, the application uses the block name to identify the block. Block names have no other use within a shader beyond interface matching; it is a compiletime error to use a block name at global scope for anything other than as a block name (e.g. use of a block name for a global variable name or function name is currently reserved). It is a compile-time error to use the same block name for more than one block declaration in the same shader interface (as defined above) within one shader, even if the block contents are identical.
Matched block names within a shader interface (as defined above) must match in terms of having the same number of declarations with the same sequence of types and the same sequence of member names, as well as having matching member-wise layout qualification (see next section). Matched uniform or shader storage block names (but not input or output block names) must also either all be lacking an instance name or all having an instance name, putting their members at the same scoping level. When instance names are present on matched block names, it is allowed for the instance names to differ; they need not match for the blocks to match. Furthermore, if a matching

59

block is declared as an array, then the array sizes must also match (or follow array matching rules for the shader interface between consecutive shader stages). Any mismatch will generate a linktime error. A block name is allowed to have different definitions in different shader interfaces within the same shader, allowing, for example, an input block and output block to have the same name.
If an instance name (instance-name) is not used, the names declared inside the block are scoped at the global level and accessed as if they were declared outside the block. If an instance name (instance-name) is used, then it puts all the members inside a scope within its own name space, accessed with the field selector (.) operator (analogously to structures). For example,

in Light {

vec4 LightPos;

vec3 LightColor;

};

in ColoredTexture {

vec4 Color;

vec2 TexCoord;

} Material;

// instance name

vec3 Color;

// different Color than Material.Color

vec4 LightPos;

// illegal, already defined

...

... = LightPos;

// accessing LightPos

... = Material.Color; // accessing Color in ColoredTexture block

Outside the shading language (i.e., in the API), members are similarly identified except the block name is always used in place of the instance name (API accesses are to shader interfaces, not to shaders). If there is no instance name, then the API does not use the block name to access a member, just the member name.
Within a shader interface, all declarations of the same global name must be for the same object and must match in type and in whether they declare a variable or member of a block with no instance name. The API also needs this name to uniquely identify an object in the shader interface. It is a link-time error if any particular shader interface contains
â¢ two different blocks, each having no instance name, and each having a member of the same name, or
â¢ a variable outside a block, and a block with no instance name, where the variable has the same name as a member in the block.

60

out Vertex { vec4 Position; vec2 Texture;
} Coords; out Vertex2 {
vec4 Color; float Color2; };

// API transform/feedback will use "Vertex.Position" // shader will use "Coords.Position" // API will use "Color"

// in same program as Vertex2 above:

out Vertex3 {

float Intensity;

vec4 Color; // ERROR, name collision with Color in Vertex2

};

float Color2;

// ERROR, collides with Color2 in Vertex2

For blocks declared as arrays, the array index must also be included when accessing members, as in this example

uniform Transform { // API uses "Transform[2]" to refer to instance 2

mat4 ModelViewMatrix;

mat4 ModelViewProjectionMatrix;

vec4 a[]; // array will get implicitly sized

float Deformation;

} transforms[4];

...

... = transforms[2].ModelViewMatrix; // shader access of instance 2

// API uses "Transform.ModelViewMatrix" to query an offset or other query

transforms[x].a.length(); // same length for 'a' for all x

Transform[x];

// illegal, must use 'transforms'

Transform.a.length(); // illegal, must use 'transforms'

...transforms[2].a[3]... // if these are the only two dereferences of 'a',

...transforms[3].a[7]... // then 'a' must be size 8, for all

transforms[x]

For uniform or shader storage blocks declared as an array, each individual array element corresponds to a separate buffer object bind range, backing one instance of the block. As the array size indicates the number of buffer objects needed, uniform and shader storage block array declarations must specify an array size. A uniform or shader storage block array can only be indexed with a dynamically uniform integral expression, otherwise results are undefined.
When using OpenGL API entry points to identify the name of an individual block in an array of blocks, the name string may include an array index (e.g. Transform[2]). When using OpenGL API entry points to refer to offsets or other characteristics of a block member, an array index must not be specified (e.g. Transform.ModelViewMatrix).
Tessellation control, tessellation evaluation and geometry shader input blocks must be declared as arrays and follow the array declaration and linking rules for all shader inputs for the respective

61

stages. All other input and output block arrays must specify an array size.
There are implementation-dependent limits on the number of uniform blocks and the number of shader storage blocks that can be used per stage. If either limit is exceeded, it will cause a link-time error.
4.4. Layout Qualifiers
Layout qualifiers can appear in several forms of declaration. They can appear as part of an interface block definition or block member, as shown in the grammar in the previous section. They can also appear with just an interface-qualifier to establish layouts of other declarations made with that qualifier:
layout-qualifier interface-qualifier ;
Or, they can appear with an individual variable declared with an interface qualifier:
layout-qualifier interface-qualifier declaration ;
Declarations of layouts can only be made at global scope or block members, and only where indicated in the following subsections; their details are specific to what the interface qualifier is, and are discussed individually.
The layout-qualifier expands to:
layout-qualifier : layout ( layout-qualifier-id-list )
layout-qualifier-id-list : layout-qualifier-id layout-qualifier-id , layout-qualifier-id-list
layout-qualifier-id : layout-qualifier-name layout-qualifier-name = layout-qualifier-value shared
layout-qualifier-value : integer-constant-expression
The tokens used for layout-qualifier-name are identifiers, not keywords, however, the shared keyword is allowed as a layout-qualifier-id. Generally, they can be listed in any order. Orderdependent meanings exist only if explicitly called out below. Similarly, these identifiers are not case sensitive, unless explicitly noted otherwise.
More than one layout qualifier may appear in a single declaration. Additionally, the same layoutqualifier-name can occur multiple times within a layout qualifier or across multiple layout qualifiers in the same declaration. When the same layout-qualifier-name occurs multiple times, in a single declaration, the last occurrence overrides the former occurrence(s). Further, if such a layout-
62

qualifier-name will affect subsequent declarations or other observable behavior, it is only the last occurrence that will have any effect, behaving as if the earlier occurrence(s) within the declaration are not present. This is also true for overriding layout-qualifier-name, where one overrides the other (e.g. row_major vs. column_major); only the last occurrence has any effect.
integer-constant-expression is defined in âConstant Expressionsâ as constant integral expression, with it being a compile-time error for integer-constant-expression to be a specialization constant.
The following table summarizes the use of layout qualifiers. It shows for each one what kinds of declarations it may be applied to. These are all discussed in detail in the following sections.

Layout Qualifier

Qualifier Only

Individual Variable

shared

packed std140

X

std430

row_major column_major

X

binding =

opaque types only

offset =

atomic counters only

align =

set =

opaque types only

push_constant
input_attachm ent_index =

subpass types only

location =

X

location =

X

component =

X

index =

X

triangles

quads

X

isolines

Block

Block Member

Allowed Interfaces

X

X

X

uniform /

buffer

X

X

X

X

uniform /

X

buffer (Vulkan

only)

X

uniform (Vulkan only)

uniform (Vulkan only)

uniform / buffer and subroutine variables

X

X

all in / out,

except for

X

compute

fragment out and subroutine functions

tessellation evaluation in

63

Layout Qualifier

Qualifier Only

equal_spacing

fractional_eve

n_spacing

X

fractional_odd

_spacing

cw ccw

X

Individual Variable

point_mode

X

points

X

[ points ]

lines

lines_adjacenc

y

X

triangles

triangles_adja

cency

invocations =

X

origin_upper_l eft pixel_center_i nteger

early_fragmen t_tests

X

local_size_x =

local_size_y =

X

local_size_z =

local_size_x_id

=

local_size_y_id =

X

local_size_z_id

=

xfb_buffer = xfb_stride =

X

xfb_offset =

gl_FragCoord only
X X

vertices =

X

Block

Block Member

Allowed Interfaces

tessellation evaluation in

tessellation evaluation in
tessellation evaluation in
geometry in /out

geometry in

geometry in fragment in

compute in

compute in (SPIR-V only)

X

X

vertex,

tessellation,

and geometry

X

X

out

tessellation control out

64

Layout Qualifier

Qualifier Only

Individual Variable

[ points ]

line_strip

X

triangle_strip

max_vertices =

X

stream =

X

X

depth_any depth_greater depth_less depth_unchan ged

gl_FragDepth only

constant_id =

scalar only

Block

Block Member

Allowed Interfaces

geometry out

X

X

fragment out

const (SPIR-V only)

65

Layout Qualifier

Qualifier Only

rgba32f rgba16f rg32f rg16f r11f_g11f_b10f r32f r16f rgba16 rgb10_a2 rgba8 rg16 rg8 r16 r8 rgba16_snorm rgba8_snorm rg16_snorm rg8_snorm r16_snorm r8_snorm rgba32i rgba16i rgba8i rg32i rg16i rg8i r32i r16i r8i rgba32ui rgba16ui rgb10_a2ui rgba8ui rg32ui rg16ui rg8ui r32ui r16ui r8ui

Individual Variable
image types only

Block

Block Member

Allowed Interfaces

uniform

4.4.1. Input Layout Qualifiers
Layout qualifiers specific to a particular shader language are discussed in separate sections below.
All shaders except compute shaders allow location layout qualifiers on input variable declarations, input block declarations, and input block member declarations. Of these, variables and block members (but not blocks) additionally allow the component layout qualifier.
layout-qualifier-id :

66

location = layout-qualifier-value component = layout-qualifier-value
For example,
layout(location = 3) in vec4 normal; const int start = 6; layout(location = start + 2) int vec4 v;
will establish that the shader input normal is assigned to vector location number 3 and v is assigned location number 8. For vertex shader inputs, the location specifies the number of the vertex attribute from which input values are taken. For inputs of all other shader types, the location specifies a vector number that can be used to match against outputs from a previous shader stage, even if that shader is in a different program object.
The following language describes how many locations are consumed by a given type. However, geometry shader inputs, tessellation control shader inputs and outputs, and tessellation evaluation inputs all have an additional level of arrayness relative to other shader inputs and outputs. This outer array level is removed from the type before considering how many locations the type consumes.
Except when targeting Vulkan, if a vertex shader input is any scalar or vector type, it will consume a single location. If a non-vertex shader input, or any stage input when targeting Vulkan, is a scalar or vector type other than dvec3 or dvec4, it will consume a single location, while types dvec3 or dvec4 will consume two consecutive locations. Inputs of type double and dvec2 will consume only a single location, in all stages.
If the declared input (after potentially removing an outer array level as just described above) is an array of size n and each of the elements takes m locations, it will be assigned m * n consecutive locations starting with the location specified. For example,
layout(location = 6) in vec4 colors[3];
will establish that the shader input colors is assigned to vector location numbers 6, 7, and 8.
If the declared input is an n Ã m matrix, it will be assigned multiple locations starting with the location specified. The number of locations assigned for each matrix will be the same as for an n -element array of m-component vectors. For example,
layout(location = 9) in mat4 transforms[2];
will establish that shader input transforms is assigned to vector locations 9-16, with transforms[0] being assigned to locations 9-12, and transforms[1] being assigned to locations 13-16.
If the declared input is a structure or block, its members will be assigned consecutive locations in their order of declaration, with the first member assigned the location provided in the layout qualifier. For a structure, this process applies to the entire structure. It is a compile-time error to
67

use a location qualifier on a member of a structure. For a block, this process applies to the entire block, or until the first member is reached that has a location layout qualifier.
When a block member is declared with a location qualifier, its location comes from that qualifier; the memberâs location qualifier overrides the block-level declaration. Subsequent members are again assigned consecutive locations, based on the newest location, until the next member declared with a location qualifier. The values used for locations do not have to be declared in increasing order.
If a block has no block-level location layout qualifier, it is required that either all or none of its members have a location layout qualifier, or a compile-time error results. For some blocks declared as arrays, the location can only be applied at the block level: When a block is declared as an array where additional locations are needed for each member for each block array element, it is a compile-time error to specify locations on the block members. That is, when locations would be under specified by applying them on block members, they are not allowed on block members. For arrayed interfaces (those generally having an extra level of arrayness due to interface expansion), the outer array is stripped before applying this rule.
When generating SPIR-V, all in and out qualified user-declared (non built-in) variables and blocks (or all their members) must have a shader-specified location. Otherwise, a compile-time error is generated.
The locations consumed by block and structure members are determined by applying the rules above recursively as though the structure member were declared as an input variable of the same type. For example:

layout(location = 3) in struct S

{

vec3 a;

// gets location 3

mat2 b;

// gets locations 4 and 5

vec4 c[2];

// gets locations 6 and 7

layout(location = 8) vec2 A; // ERROR, can't use on struct member

} s;

layout(location = 4) in block

{

vec4 d;

// gets location 4

vec4 e;

// gets location 5

layout(location = 7) vec4 f; // gets location 7

vec4 g;

// gets location 8

layout(location = 1) vec4 h; // gets location 1

vec4 i;

// gets location 2

vec4 j;

// gets location 3

vec4 k;

// ERROR, location 4 already used

};

The number of input locations available to a shader is limited. For vertex shaders, the limit is the advertised number of vertex attributes. For all other shaders, the limit is implementationdependent and must be no less than one fourth of the advertised maximum input component count.

68

A program will fail to link if any attached shader uses a location greater than or equal to the number of supported locations, unless device-dependent optimizations are able to make the program fit within available hardware resources. A program will fail to link if explicit location assignments leave the linker unable to find space for other variables without explicit assignments. For the purposes of determining if a non-vertex input matches an output from a previous shader stage, the location layout qualifier (if any) must match. If a vertex shader input variable with no location assigned in the shader text has a location specified through the OpenGL API, the API-assigned location will be used. Otherwise, such variables will be assigned a location by the linker. See section 11.1.1 âVertex Attributesâ of the OpenGL Specification for more details. A link-time error will occur if an input variable is declared in multiple shaders of the same language with conflicting locations. The component qualifier allows the location to be more finely specified for scalars and vectors, down to the individual components within a location that are consumed. It is a compile-time error to use component without also specifying the location qualifier (order does not matter). The components within a location are 0, 1, 2, and 3. A variable or block member starting at component N will consume components N, N+1, N+2, â¦ up through its size. It is a compile-time error if this sequence of components gets larger than 3. A scalar double will consume two of these components, and a dvec2 will consume all four components available within a location. A dvec3 or dvec4 can only be declared without specifying a component. A dvec3 will consume all four components of the first location and components 0 and 1 of the second location. This leaves components 2 and 3 available for other component-qualified declarations. For example:
69

// a consumes components 2 and 3 of location 4 layout(location = 4, component = 2) in vec2 a;
// b consumes component 1 of location 4 layout(location = 4, component = 1) in float b;
// ERROR: c overflows component 3 layout(location = 3, component = 2) in vec3 c;
// d consumes components 2 and 3 of location 5 layout(location = 5, component = 2) in double d;
// ERROR: e overflows component 3 of location 6 layout(location = 6, component = 2) in dvec2 e;
// ERROR: f overlaps with g layout(location = 7, component = 0) double f; layout(location = 7, component = 1) float g;
layout(location = 8) in dvec3 h; // components 0,1,2 and 3 of location 8 // and components 0 and 1 of location 9
layout(location = 9, component = 2) in float i; // okay, compts 2 and 3
If the variable is an array, each element of the array, in order, is assigned to consecutive locations, but all at the same specified component within each location. For example:
// component 3 in 6 locations are consumed layout(location = 2, component = 3) in float d[6];
That is, location 2 component 3 will hold d[0], location 3 component 3 will hold d[1], â¦, up through location 7 component 3 holding d[5].
This allows packing of two arrays into the same set of locations:
// e consumes beginning (components 0, 1 and 2) of each of 6 slots layout(location = 0, component = 0) in vec3 e[6];
// f consumes last component of the same 6 slots layout(location = 0, component = 3) in float f[6];
If applying this to an array of arrays, all levels of arrayness are removed to get to the elements that are assigned per location to the specified component. These non-arrayed elements will fill the locations in the order specified for arrays of arrays in âArraysâ.
It is a compile-time error to apply the component qualifier to a matrix, a structure, a block, or an array containing any of these. It is a compile-time error to use component 1 or 3 as the beginning of a double or dvec2. It is a link-time error to specify different components for the same variable
70

within a program.
Location aliasing is causing two variables or block members to have the same location number. Component aliasing is assigning the same (or overlapping) component numbers for two location aliases. (Recall if component is not used, components are assigned starting with 0.) With one exception, location aliasing is allowed only if it does not cause component aliasing; it is a compiletime or link-time error to cause component aliasing. Further, when location aliasing, the aliases sharing the location must have the same underlying numerical type and bit width (floating-point or integer, 32-bit versus 64-bit, etc.) and the same auxiliary storage and interpolation qualification. The one exception where component aliasing is permitted is when targeting OpenGL for two input variables (not block members) to a vertex shader, which are allowed to have component aliasing. This vertex-variable component aliasing is intended only to support vertex shaders where each execution path accesses at most one input per each aliased component. Implementations are permitted, but not required, to generate link-time errors if they detect that every path through the vertex shader executable accesses multiple inputs aliased to any single component.
Tessellation Evaluation Inputs
Additional input layout qualifier identifiers allowed for tessellation evaluation shaders are described below.
layout-qualifier-id : primitive_mode vertex_spacing ordering point_mode
The primitive-mode is used to specify a tessellation primitive mode to be used by the tessellation primitive generator.
primitive-mode: triangles quads isolines
If present, the primitive-mode specifies that the tessellation primitive generator should subdivide a triangle into smaller triangles, a quad into triangles, or a quad into a collection of lines, respectively.
A second group of layout identifiers, vertex spacing, is used to specify the spacing used by the tessellation primitive generator when subdividing an edge.
vertex-spacing: equal_spacing fractional_even_spacing fractional_odd_spacing
equal_spacing specifies that edges should be divided into a collection of equal-sized segments;
fractional_even_spacing specifies that edges should be divided into an even number of equal-
71

length segments plus two additional shorter âfractionalâ segments; or
fractional_odd_spacing specifies that edges should be divided into an odd number of equal-length segments plus two additional shorter âfractionalâ segments.
A third group of layout identifiers, ordering, specifies whether the tessellation primitive generator produces triangles in clockwise or counter-clockwise order, according to the coordinate system depicted in the OpenGL Specification.
ordering: cw ccw
The identifiers cw and ccw indicate clockwise and counter-clockwise triangles, respectively. If the tessellation primitive generator does not produce triangles, the order is ignored.
Finally, point mode indicates that the tessellation primitive generator should produce one point for each distinct vertex in the subdivided primitive, rather than generating lines or triangles.
point-mode: point_mode
Any or all of these identifiers may be specified one or more times in a single input layout declaration. If primitive mode, vertex spacing, or ordering is declared more than once in the tessellation evaluation shaders of a program, all such declarations must use the same identifier.
At least one tessellation evaluation shader (compilation unit) in a program must declare a primitive mode in its input layout. Declaring vertex spacing, ordering, or point mode identifiers is optional. It is not required that all tessellation evaluation shaders in a program declare a primitive mode. If spacing or vertex ordering declarations are omitted, the tessellation primitive generator will use equal spacing or counter-clockwise vertex ordering, respectively. If a point mode declaration is omitted, the tessellation primitive generator will produce lines or triangles according to the primitive mode.
Geometry Shader Inputs
Additional layout qualifier identifiers for geometry shader inputs include primitive identifiers and an invocation count identifier:
layout-qualifier-id : points lines lines_adjacency triangles triangles_adjacency invocations = layout-qualifier-value
The identifiers points, lines, lines_adjacency, triangles, and triangles_adjacency are used to specify the type of input primitive accepted by the geometry shader, and only one of these is accepted. At least one geometry shader (compilation unit) in a program must declare this input
72

primitive layout, and all geometry shader input layout declarations in a program must declare the same layout. It is not required that all geometry shaders in a program declare an input primitive layout.
The identifier invocations is used to specify the number of times the geometry shader executable is invoked for each input primitive received. Invocation count declarations are optional. If no invocation count is declared in any geometry shader in a program, the geometry shader will be run once for each input primitive. If an invocation count is declared, all such declarations must specify the same count. If a shader specifies an invocation count greater than the implementationdependent maximum, or less than or equal to zero, a compile-time error results.
For example,
layout(triangles, invocations = 6) in;

will establish that all inputs to the geometry shader are triangles and that the geometry shader executable is run six times for each triangle processed.
All geometry shader input unsized array declarations will be sized by an earlier input primitive layout qualifier, when present, as per the following table.

Layout points lines lines_adjacency triangles triangles_adjacency

Size of Input Arrays 1 2 4 3 6

The intrinsically declared input array gl_in[] will also be sized by any input primitive-layout declaration. Hence, the expression

gl_in.length()

will return the value from the table above.
For inputs declared without an array size, including intrinsically declared inputs (i.e., gl_in), a layout must be declared before any use of the method length() or other any array use that requires the array size to be known.
It is a compile-time error if a layout declarationâs array size (from the table above) does not match all the explicit array sizes specified in declarations of an input variables in the same shader. The following includes examples of compile-time errors:

73

// code sequence within one shader... in vec4 Color1[]; // legal, size still unknown in vec4 Color2[2]; // legal, size is 2 in vec4 Color3[3]; // illegal, input sizes are inconsistent layout(lines) in; // legal for Color2, input size is 2, matching Color2 in vec4 Color4[3]; // illegal, contradicts layout of lines layout(lines) in; // legal, matches other layout() declaration layout(triangles) in; // illegal, does not match earlier layout() declaration
It is a link-time error if not all provided sizes (sized input arrays and layout size) match across all geometry shaders in a program.
Fragment Shader Inputs
Additional fragment layout qualifier identifiers include the following for gl_FragCoord :
layout-qualifier-id : origin_upper_left pixel_center_integer
By default, gl_FragCoord in OpenGL assumes a lower-left origin for window coordinates and assumes pixel centers are located at half-pixel coordinates. For example, the (x, y) location (0.5, 0.5) is returned for the lower-left-most pixel in a window. The origin can be changed by redeclaring gl_FragCoord with the origin_upper_left qualifier, moving the origin of gl_FragCoord to the upper left of the window, with y increasing in value toward the bottom of the window. The values returned can also be shifted by half a pixel in both x and y by pixel_center_integer so it appears the pixels are centered at whole number pixel offsets. This moves the (x, y) value returned by gl_FragCoord of (0.5, 0.5) by default, to (0.0, 0.0) with pixel_center_integer.
Targeting Vulkan will assume and require an upper-left origin for gl_FragCoord with pixel centers located at half-pixel coordinates. This origin can be explicitly set by redeclaring gl_FragCoord with the origin_upper_left identifier.
Redeclarations are done as follows
in vec4 gl_FragCoord; // redeclaration that changes nothing is allowed
// All the following are allowed redeclaration that change behavior layout(origin_upper_left) in vec4 gl_FragCoord; layout(pixel_center_integer) in vec4 gl_FragCoord; layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;
If gl_FragCoord is redeclared in any fragment shader in a program, it must be redeclared in all the fragment shaders in that program that have a static use gl_FragCoord. All redeclarations of gl_FragCoord in all fragment shaders in a single program must have the same set of qualifiers. Within any shader, the first redeclarations of _glFragCoord must appear before any use of gl_FragCoord. The built-in gl_FragCoord is only predeclared in fragment shaders, so redeclaring it in any other shader language results in a compile-time error.
74

Redeclaring glFragCoord with origin_upper_left and/or pixel_center_integer qualifiers only affects gl_FragCoord.x and gl_FragCoord.y. It has no effect on rasterization, transformation, or any other part of the API pipeline or language features. Fragment shaders allow the following layout qualifier on in only (not with variable declarations): layout-qualifier-id :
early_fragment_tests to request that fragment tests be performed before fragment shader execution, as described in section 15.2.4 âEarly Fragment Testsâ of the OpenGL Specification. For example,
layout(early_fragment_tests) in;
Specifying this will make per-fragment tests be performed before fragment shader execution. If this is not declared, per-fragment tests will be performed after fragment shader execution. Only one fragment shader (compilation unit) need declare this, though more than one can. If at least one declares this, then it is enabled.
Compute Shader Inputs There are no layout location qualifiers for compute shader inputs. Layout qualifier identifiers for compute shader inputs are the workgroup size qualifiers: layout-qualifier-id :
local_size_x = layout-qualifier-value local_size_y = layout-qualifier-value local_size_z = layout-qualifier-value The local_size_x, local_size_y, and local_size_z qualifiers are used to declare a fixed workgroup size by the compute shader in the first, second, and third dimension, respectively. If a shader does not specify a size for one of the dimensions, that dimension will have a size of 1. For example, the following declaration in a compute shader
layout(local_size_x = 32, local_size_y = 32) in;
is used to declare a two-dimensional compute shader with a workgroup size of 32 X 32 elements, which is equivalent to a three-dimensional compute shader where the third dimension has size one. As another example, the declaration
layout(local_size_x = 8) in;
75

effectively specifies that a one-dimensional compute shader is being compiled, and its size is 8 elements.
If the fixed workgroup size of the shader in any dimension is less than or equal to zero or greater than the maximum size supported by the implementation for that dimension, a compile-time error results. Also, if such a layout qualifier is declared more than once in the same shader, all those declarations must set the same set of workgroup sizes and set them to the same values; otherwise a compile-time error results. If multiple compute shaders attached to a single program object declare a fixed workgroup size, the declarations must be identical; otherwise a link-time error results.
Furthermore, if a program object contains any compute shaders, at least one must contain an input layout qualifier specifying a fixed workgroup size for the program, or a link-time error will occur.
4.4.2. Output Layout Qualifiers
Some output layout qualifiers apply to all shader stages and some apply only to specific stages. The latter are discussed in separate sections below.
As with input layout qualifiers, all shaders except compute shaders allow location layout qualifiers on output variable declarations, output block declarations, and output block member declarations. Of these, variables and block members (but not blocks) additionally allow the component layout qualifier.
layout-qualifier-id : location = layout-qualifier-value component = layout-qualifier-value
The usage and rules for applying the location qualifier and the component qualifier to blocks and structures are exactly as described in âInput Layout Qualifiersâ. Additionally, for fragment shader outputs, if two variables are placed within the same location, they must have the same underlying type (floating-point or integer). No component aliasing of output variables or members is allowed.
Fragment shaders allow an additional index output layout qualifier:
layout-qualifier-id : index = layout-qualifier-value
Each of these qualifiers may appear at most once. If index is specified, location must also be specified. If index is not specified, the value 0 is used. For example, in a fragment shader,
layout(location = 3) out vec4 color;
will establish that the fragment shader output color is assigned to fragment color 3 as the first (index zero) input to the blend equation. And,
layout(location = 3, index = 1) out vec4 factor;
will establish that the fragment shader output factor is assigned to fragment color 3 as the second
76

(index one) input to the blend equation.
For fragment shader outputs, the location and index specify the color output number and index receiving the values of the output. For outputs of all other shader stages, the location specifies a vector number that can be used to match against inputs in a subsequent shader stage, even if that shader is in a different program object.
If a declared output is a scalar or vector type other than dvec3 or dvec4, it will consume a single location. Outputs of type dvec3 or dvec4 will consume two consecutive locations. Outputs of type double and dvec2 will consume only a single location, in all stages.
If the declared output is an array, it will be assigned consecutive locations starting with the location specified. For example,
layout(location = 2) out vec4 colors[3];
will establish that colors is assigned to vector location numbers 2, 3, and 4.
If the declared output is an n Ã m matrix, it will be assigned multiple locations starting with the location specified. The number of locations assigned will be the same as for an n-element array of m -component vectors.
If the declared output is a structure, its members will be assigned consecutive locations in the order of declaration, with the first member assigned the location specified for the structure. The number of locations consumed by a structure member is determined by applying the rules above recursively as though the structure member were declared as an output variable of the same type.
location layout qualifiers may be used on output variables declared as structures. However, it is a compile-time error to use a location qualifier on a structure member. Location layout qualifiers may be used on output blocks and output block members.
The number of output locations available to a shader is limited. For fragment shaders, the limit is the advertised number of draw buffers.
For all other shaders, the limit is implementation-dependent and must be no less than one fourth of the advertised maximum output component count (compute shaders have no outputs). A program will fail to link if any attached shader uses a location greater than or equal to the number of supported locations, unless device-dependent optimizations are able to make the program fit within available hardware resources.
Compile-time errors may also be given if at compile time it is known the link will fail. A negative output location will result in a compile-time error. It is also a compile-time error if a fragment shader sets a layout index to less than 0 or greater than 1.
It is a compile-time or link-time error if any of the following occur:
â¢ any two fragment shader output variables are assigned to the same location and index. â¢ if any two output variables from the same vertex, tessellation or geometry shader stage are
assigned to the same location.
77

For fragment shader outputs, locations can be assigned using either a layout qualifier or via the OpenGL API.
For all shader types, a program will fail to link if explicit location assignments leave the linker unable to find space for other variables without explicit assignments.
If an output variable with no location or index assigned in the shader text has a location specified through the OpenGL API, the API-assigned location will be used. Otherwise, such variables will be assigned a location by the linker. All such assignments will have a color index of zero. See section 15.2 âShader Executionâ of the OpenGL Specification for more details. A link-time error will occur if an output variable is declared in multiple shaders of the same language with conflicting location or index values.
For the purposes of determining if a non-fragment output matches an input from a subsequent shader stage, the location layout qualifier (if any) must match.
Transform Feedback Layout Qualifiers
The vertex, tessellation, and geometry stages allow shaders to control transform feedback. When doing this, shaders will dictate which transform feedback buffers are in use, which output variables will be written to which buffers, and how each buffer is laid out. To accomplish this, shaders allow the following layout qualifier identifiers on output declarations:
layout-qualifier-id : xfb_buffer = layout-qualifier-value xfb_offset = layout-qualifier-value xfb_stride = layout-qualifier-value
Any shader making any static use (after preprocessing) of any of these xfb_ qualifiers will cause the shader to be in a transform feedback capturing mode and hence responsible for describing the transform feedback setup. This mode will capture any output selected by xfb_offset, directly or indirectly, to a transform feedback buffer.
The xfb_buffer qualifier specifies which transform feedback buffer will capture outputs selected with xfb_offset. The xfb_buffer qualifier can be applied to the qualifier out, to output variables, to output blocks, and to output block members. Shaders in the transform feedback capturing mode have an initial global default of
layout(xfb_buffer = 0) out;
This default can be changed by declaring a different buffer with xfb_buffer on the interface qualifier out. This is the only way the global default can be changed. When a variable or output block is declared without an xfb_buffer qualifier, it inherits the global default buffer. When a variable or output block is declared with an xfb_buffer qualifier, it has that declared buffer. All members of a block inherit the blockâs buffer. A member is allowed to declare an xfb_buffer, but it must match the buffer inherited from its block, or a compile-time error results.
78

layout(xfb_buffer=2, xfb_offset=0) out block { // block's buffer is 2

layout(xfb_buffer = 2) vec4 v; // okay, matches the inherited 2

layout(xfb_buffer = 3) vec4 u; // ERROR, mismatched buffer

vec4 w; // inherited

};

layout(xfb_offset=16) out vec4 t; // initial default is buffer 0

layout(xfb_buffer=1) out;

// new global default of 1

out block {

// block has buffer 1

vec4 x;

// x has buffer 1 (not captured)

layout(xfb_buffer = 1) vec4 y; // okay (not captured)

layout(xfb_buffer = 0) vec4 z; // ERROR, mismatched buffer

};

layout(xfb_offset=0) out vec4 g; // g has buffer 1

layout(xfb_buffer=2) out vec4 h; // does not change global default

layout(xfb_offset=16) out vec4 j; // j has buffer 1

Note this means all members of a block that go to a transform feedback buffer will go to the same buffer.
When a block is declared as an array, all members of block array-element 0 are captured, as previously described, by the declared or inherited xfb_buffer. Generally, an array of size N of blocks is captured by N consecutive buffers, with all members of block array-element E captured by buffer B, where B equals the declared or inherited xfb_buffer plus E.
It is a compile-time or link-time error to specify an xfb_buffer, including any additional buffers needed to capture an arrays of blocks, that is less than zero or greater than or equal to the implementation-dependent constant gl_MaxTransformFeedbackBuffers.
The xfb_offset qualifier assigns a byte offset within a transform feedback buffer. Only variables, block members, or blocks can be qualified with xfb_offset. If a block is qualified with xfb_offset, all its members are assigned transform feedback buffer offsets. If a block is not qualified with xfb_offset, any members of that block not qualified with an xfb_offset will not be assigned transform feedback buffer offsets. Only variables and block members that are assigned offsets will be captured (thus, a proper subset of a block can be captured). Each time such a variable or block member is written in a shader, the written value is captured at the assigned offset. If such a block member or variable is not written during a shader invocation, the buffer contents at the assigned offset will be undefined. Even if there are no static writes to a variable or member that is assigned a transform feedback offset, the space is still allocated in the buffer and still affects the stride.
Variables and block members qualified with xfb_offset can be scalars, vectors, matrices, structures, and (sized) arrays of these. The offset must be a multiple of the size of the first component of the first qualified variable or block member, or a compile-time error results. Further, if applied to an aggregate containing a double, the offset must also be a multiple of 8, and the space taken in the buffer will be a multiple of 8. The given offset applies to the first component of the first member of the qualified entity. Then, within the qualified entity, subsequent components are each assigned, in order, to the next available offset aligned to a multiple of that componentâs size. Aggregate types are flattened down to the component level to get this sequence of components. It is a compile-time error to apply xfb_offset to the declaration of an unsized array.

79

No aliasing in output buffers is allowed: It is a compile-time or link-time error to specify variables with overlapping transform feedback offsets.
The xfb_stride qualifier specifies how many bytes are consumed by each captured vertex. It applies to the transform feedback buffer for that declaration, whether it is inherited or explicitly declared. It can be applied to variables, blocks, block members, or just the qualifier out. If the buffer is capturing any outputs with double-precision components, the stride must be a multiple of 8, otherwise it must be a multiple of 4, or a compile-time or link-time error results. It is a compiletime or link-time error to have any xfb_offset that overflows xfb_stride, whether stated on declarations before or after the xfb_stride, or in different compilation units. While xfb_stride can be declared multiple times for the same buffer, it is a compile-time or link-time error to have different values specified for the stride for the same buffer.
For example:
// buffer 1 has 32-byte stride layout(xfb_buffer = 1, xfb_stride = 32) out;
// same as previous example; order within layout does not matter layout(xfb_stride = 32, xfb_buffer = 1) out;
// everything in this block goes to buffer 0 layout(xfb_buffer = 0, xfb_stride = 32) out block1 {
layout(xfb_offset = 0) vec4 a; // a goes to byte offset 0 of buffer 0 layout(xfb_offset = 16) vec4 b; // b goes to offset 16 of buffer 0 };
layout(xfb_buffer = 3, xfb_offset = 12) out block2 { vec4 v; // v will be written to byte offsets 12 through 27 of buffer float u; // u will be written to offset 28 layout(xfb_offset = 40) vec4 w; vec4 x; // x will be written to offset 56, the next available offset
};
layout(xfb_buffer = 2, xfb_stride = 32) out block3 { layout(xfb_offset = 12) vec3 c; layout(xfb_offset = 24) vec3 d; // ERROR, requires stride of 36 layout(xfb_offset = 0) vec3 g; // okay, increasing order not required
};
When no xfb_stride is specified for a buffer, the stride of the buffer will be the smallest needed to hold the variable placed at the highest offset, including any required padding. For example:
// if there no other declarations for buffer 3, it has stride 32 layout(xfb_buffer = 3) out block4 {
layout(xfb_offset = 0) vec4 e; layout(xfb_offset = 16) vec4 f; };
80

The resulting stride (implicit or explicit), when divided by 4, must be less than or equal to the implementation-dependent constant gl_MaxTransformFeedbackInterleavedComponents.
Tessellation Control Outputs
Other than for the transform feedback layout qualifiers, tessellation control shaders allow output layout qualifiers only on the interface qualifier out, not on an output block, block member, or variable declaration. The output layout qualifier identifiers allowed for tessellation control shaders are:
layout-qualifier-id : vertices = layout-qualifier-value
The identifier vertices specifies the number of vertices in the output patch produced by the tessellation control shader, which also specifies the number of times the tessellation control shader is invoked. It is a compile- or link-time error for the output vertex count to be less than or equal to zero, or greater than the implementation-dependent maximum patch size.
The intrinsically declared tessellation control output array gl_out[] will also be sized by any output layout declaration. Hence, the expression
gl_out.length()
will return the output patch vertex count specified in a previous output layout qualifier. For outputs declared without an array size, including intrinsically declared outputs (i.e., gl_out), a layout must be declared before any use of the method length() or other array use that requires its size to be known.
It is a compile-time error if the output patch vertex count specified in an output layout qualifier does not match the array size specified in any output variable declaration in the same shader.
All tessellation control shader layout declarations in a program must specify the same output patch vertex count. There must be at least one layout qualifier specifying an output patch vertex count in any program containing tessellation control shaders; however, such a declaration is not required in all tessellation control shaders.
Geometry Outputs
Geometry shaders can have three additional types of output layout identifiers: an output primitive type, a maximum output vertex count, and per-output stream numbers. The primitive type and vertex count identifiers are allowed only on the interface qualifier out, not on an output block, block member, or variable declaration. The stream identifier is allowed on the interface qualifier out, on output blocks, and on variable declarations.
The layout qualifier identifiers for geometry shader outputs are
layout-qualifier-id : points line_strip
81

triangle_strip max_vertices = layout-qualifier-value stream = layout-qualifier-value
The primitive type identifiers points, line_strip, and triangle_strip are used to specify the type of output primitive produced by the geometry shader, and only one of these is accepted. At least one geometry shader (compilation unit) in a program must declare an output primitive type, and all geometry shader output primitive type declarations in a program must declare the same primitive type. It is not required that all geometry shaders in a program declare an output primitive type.
The vertex count identifier max_vertices is used to specify the maximum number of vertices the shader will ever emit in a single invocation. At least one geometry shader (compilation unit) in a program must declare a maximum output vertex count, and all geometry shader output vertex count declarations in a program must declare the same count. It is not required that all geometry shaders in a program declare a count.
In this example,

layout(triangle_strip, max_vertices = 60) out; // order does not matter

layout(max_vertices = 60) out; // redeclaration okay

layout(triangle_strip) out; // redeclaration okay

layout(points) out;

// error, contradicts triangle_strip

layout(max_vertices = 30) out; // error, contradicts 60

all outputs from the geometry shader are triangles and at most 60 vertices will be emitted by the shader. It is an error for the maximum number of vertices to be greater than gl_MaxGeometryOutputVertices.
The identifier stream is used to specify that a geometry shader output variable or block is associated with a particular vertex stream (numbered beginning with zero). A default stream number may be declared at global scope by qualifying interface qualifier out as in this example:

layout(stream = 1) out;

The stream number specified in such a declaration replaces any previous default and applies to all subsequent block and variable declarations until a new default is established. The initial default stream number is zero.
Each output block or non-block output variable is associated with a vertex stream. If the block or variable is declared with the stream identifier, it is associated with the specified stream; otherwise, it is associated with the current default stream. A block member may be declared with a stream identifier, but the specified stream must match the stream associated with the containing block. One example:

82

layout(stream=1) out;

// default is now stream 1

out vec4 var1;

// var1 gets default stream (1)

layout(stream=2) out Block1 { // "Block1" belongs to stream 2

layout(stream=2) vec4 var2; // redundant block member stream decl

layout(stream=3) vec2 var3; // ILLEGAL (must match block stream)

vec3 var4;

// belongs to stream 2

};

layout(stream=0) out;

// default is now stream 0

out vec4 var5;

// var5 gets default stream (0)

out Block2 {

// "Block2" gets default stream (0)

vec4 var6;

};

layout(stream=3) out vec4 var7; // var7 belongs to stream 3

Each vertex emitted by the geometry shader is assigned to a specific stream, and the attributes of the emitted vertex are taken from the set of output blocks and variables assigned to the targeted stream. After each vertex is emitted, the values of all output variables become undefined. Additionally, the output variables associated with each vertex stream may share storage. Writing to an output variable associated with one stream may overwrite output variables associated with any other stream. When emitting each vertex, a geometry shader should write to all outputs associated with the stream to which the vertex will be emitted and to no outputs associated with any other stream.
If a geometry shader output block or variable is declared more than once, all such declarations must associate the variable with the same vertex stream. If any stream declaration specifies a nonexistent stream number, the shader will fail to compile.
Built-in geometry shader outputs are always associated with vertex stream zero.
All geometry shader output layout declarations in a program must declare the same layout and same value for max_vertices. If geometry shaders are in a program, there must be at least one geometry output layout declaration somewhere in that program, but not all geometry shaders (compilation units) are required to declare it.
Fragment Outputs
The built-in fragment shader variable gl_FragDepth may be redeclared using one of the following layout qualifiers.
layout-qualifier-id : depth_any depth_greater depth_less depth_unchanged
The layout qualifier for gl_FragDepth constrains intentions of the final value of gl_FragDepth written by any shader invocation. GL implementations are allowed to perform optimizations assuming that the depth test fails (or passes) for a given fragment if all values of gl_FragDepth consistent with the layout qualifier would fail (or pass). This potentially includes skipping shader

83

execution if the fragment is discarded because it is occluded and the shader has no side effects. If the final value of gl_FragDepth is inconsistent with its layout qualifier, the result of the depth test for the corresponding fragment is undefined. However, no error will be generated in this case. If the depth test passes and depth writes are enabled, the value written to the depth buffer is always the value of gl_FragDepth, whether or not it is consistent with the layout qualifier.
By default, gl_FragDepth is qualified as depth_any. When the layout qualifier for gl_FragDepth is depth_any, the shader compiler will note any assignment to gl_FragDepth modifying it in an unknown way, and depth testing will always be performed after the shader has executed. When the layout qualifier is depth_greater, the GL can assume that the final value of gl_FragDepth is greater than or equal to the fragmentâs interpolated depth value, as given by the z component of gl_FragCoord. When the layout qualifier is depth_less, the GL can assume that any modification of gl_FragDepth will only decrease its value. When the layout qualifier is depth_unchanged, the shader compiler will honor any modification to gl_FragDepth, but the rest of the GL can assume that gl_FragDepth is not assigned a new value.
Redeclarations of gl_FragDepth are performed as follows:
// redeclaration that changes nothing is allowed + out float gl_FragDepth;
// assume it may be modified in any way layout(depth_any) out float gl_FragDepth;
// assume it may be modified such that its value will only increase layout(depth_greater) out float gl_FragDepth;
// assume it may be modified such that its value will only decrease layout(depth_less) out float gl_FragDepth;
// assume it will not be modified layout(depth_unchanged) out float gl_FragDepth;
If gl_FragDepth is redeclared in any fragment shader in a program, it must be redeclared in all fragment shaders in that program that have static assignments to gl_FragDepth. All redeclarations of gl_FragDepth in all fragment shaders in a single program must have the same set of qualifiers. Within any shader, the first redeclarations of gl_FragDepth must appear before any use of gl_FragDepth. The built-in gl_FragDepth is only predeclared in fragment shaders, so redeclaring it in any other shader language results in a compile-time error.
4.4.3. Uniform Variable Layout Qualifiers
Layout qualifiers can be used for uniform variables and subroutine uniforms. The layout qualifier identifiers for uniform variables and subroutine uniforms are:
layout-qualifier-id : location = layout-qualifier-value
The location identifier can be used with default-block uniform variables and subroutine uniforms.
84

The location specifies the location by which the API can reference the uniform and update its value. Individual elements of a uniform array are assigned consecutive locations with the first element taking location location. Default-block uniform variable declarations sharing the same location linked in the program have to match by name, type, qualifiers and arrayness. For arrays their array dimensionality and array sizes must match. For structs this rule applies recursively to all members. No two subroutine uniform variables can have the same location in the same shader stage, otherwise a compile-time or link-time error will be generated. Valid locations for default-block uniform variable locations are in the range of 0 to the implementation-defined maximum number of uniform locations minus one. Valid locations for subroutine uniforms are in the range of 0 to the implementation-defined per-stage maximum number of subroutine uniform locations minus one.
Locations can be assigned to default-block uniform arrays and structures. The first inner-most scalar, vector or matrix member or element takes the specified location and the compiler assigns the next inner-most member or element the next incremental location value. Each subsequent inner-most member or element gets incremental locations for the entire structure or array. This rule applies to nested structures and arrays and gives each inner-most scalar, vector, or matrix member a unique location. For arrays without an explicit size, the size is calculated based on its static usage. When the linker generates locations for uniforms without an explicit location, it assumes for all uniforms with an explicit location all their array elements and structure members are used and the linker will not generate a conflicting location, even if that element or member is deemed unused.
When generating SPIR-V for APIâs that accept individual (default block) non-opaque uniform variables, it is a compile-time error to not include a location when declaring them.
When targeting Vulkan, the push_constant qualifier is used to declare an entire block, and represents a set of push constants, as defined by the Vulkan API. It is a compile-time error to apply this to anything other than a uniform block declaration, or when not targeting Vulkan. The values in the block will be initialized as per the Vulkan API specification. A block declared with layout(push_constant) may optionally include an instance-name. There can be only one push_constant block per stage, or a compile-time or link-time error will result. A push-constant array can only be indexed with dynamically uniform indices. Uniform blocks declared with push_constant use different resources than those without; and are accounted for separately.
4.4.4. Subroutine Function Layout Qualifiers
Layout qualifiers can be used for subroutine functions. The layout qualifier identifiers for subroutine functions are:
layout-qualifier-id : index = layout-qualifier-value
Each subroutine with an index qualifier in the shader must be given a unique index, otherwise a compile- or link-time error will be generated. The indices must be in the range of 0 to the implementation defined maximum number of subroutines minus one. It is recommended, but not required, that the shader assigns a range of tightly packed index values starting from zero so that the OpenGL subroutine function enumeration API returns a non-empty name for all active indices.
85

4.4.5. Uniform and Shader Storage Block Layout Qualifiers
Layout qualifiers can be used for uniform and shader storage blocks, but not for non-block uniform declarations. The layout qualifier identifiers (and shared keyword) for uniform and shader storage blocks are:
layout-qualifier-id : shared packed std140 std430 row_major column_major binding = layout-qualifier-value offset = layout-qualifier-value align = layout-qualifier-value
None of these have any semantic effect at all on the usage of the variables being declared; they only describe how data is laid out in memory. For example, matrix semantics are always column-based, as described in the rest of this specification, no matter what layout qualifiers are being used.
Uniform and shader storage block layout qualifiers can be declared for global scope, on a single uniform or shader storage block, or on a single block member declaration.
Default layouts are established at global scope for uniform blocks as:
layout(layout-qualifier-id-list) uniform;
and for shader storage blocks as:
layout(layout-qualifier-id-list) buffer;
When this is done, the previous default qualification is first inherited and then overridden as per the override rules listed below for each qualifier listed in the declaration. The result becomes the new default qualification scoped to subsequent uniform or shader storage block definitions.
The initial state of compilation when generating SPIR-V is as if the following were declared:
layout(std140, column_major) uniform; layout(std430, column_major) buffer;
However, when push_constant is declared, the default layout of the buffer will be std430. There is no method to globally set this default.
The initial state of compilation when not generating SPIR-V is as if the following were declared:
86

layout(shared, column_major) uniform; layout(shared, column_major) buffer;
Uniform and shader storage blocks can be declared with optional layout qualifiers, and so can their individual member declarations. Such block layout qualification is scoped only to the content of the block. As with global layout declarations, block layout qualification first inherits from the current default qualification and then overrides it. Similarly, individual member layout qualification is scoped just to the member declaration, and inherits from and overrides the blockâs qualification.
The shared qualifier overrides only the std140, std430, and packed qualifiers; other qualifiers are inherited. The compiler/linker will ensure that multiple programs and programmable stages containing this definition will share the same memory layout for this block, as long as all arrays are declared with explicit sizes and all matrices have matching row_major and/or column_major qualifications (which may come from a declaration outside the block definition). This allows use of the same buffer to back the same block definition across different programs. It is a compile-time error to use the shared qualifier when generating SPIR-V.
The packed qualifier overrides only std140, std430, and shared; other qualifiers are inherited. When packed is used, no shareable layout is guaranteed. The compiler and linker can optimize memory use based on what variables actively get used and on other criteria. Offsets must be queried, as there is no other way of guaranteeing where (and which) variables reside within the block.
It is a link-time error to access the same packed uniform or shader storage block in multiple stages within a program. Attempts to access the same packed uniform or shader storage block across programs can result in conflicting member offsets and in undefined values being read. However, implementations may aid application management of packed blocks by using canonical layouts for packed blocks. It is a compile-time error to use the packed qualifier when generating SPIR-V.
The std140 and std430 qualifiers override only the packed, shared, std140, and std430 qualifiers; other qualifiers are inherited. The std430 qualifier is supported only for shader storage blocks; a shader using the std430 qualifier on a uniform block will result in a compile-time error, unless it is also declared with push_constant.
The layout is explicitly determined by this, as described in section 7.6.2.2 âStandard Uniform Block Layoutâ of the OpenGL Specification. Hence, as in shared above, the resulting layout is shareable across programs.
Layout qualifiers on member declarations cannot use the shared, packed, std140, or std430 qualifiers. These can only be used at global scope (without an object) or on a block declaration, or a compile-time error results.
The row_major and column_major qualifiers only affect the layout of matrices, including all matrices contained in structures and arrays they are applied to, to all depths of nesting. These qualifiers can be applied to other types, but will have no effect.
The row_major qualifier overrides only the column_major qualifier; other qualifiers are inherited. Elements within a matrix row will be contiguous in memory.
87

The column_major qualifier overrides only the row_major qualifier; other qualifiers are inherited. Elements within a matrix column will be contiguous in memory.
The binding qualifier specifies the uniform buffer binding point corresponding to the uniform or shader storage block, which will be used to obtain the values of the member variables of the block. It is a compile-time error to specify the binding qualifier for the global scope or for block member declarations. Any uniform or shader storage block declared without a binding qualifier is initially assigned to block binding point zero. After a program is linked, the binding points used for uniform and shader storage blocks declared with or without a binding qualifier can be updated by the API.
When used with OpenGL, if the binding qualifier is used with a uniform block or shader storage block instanced as an array, the first element of the array takes the specified block binding and each subsequent element takes the next consecutive binding point. For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a binding point, and they are ordered per the array of array ordering described in âArrays.â
When targeting Vulkan, if the binding qualifier is used with a uniform block or buffer block instanced as an array, the entire array takes only the provided binding number. The next consecutive binding number is available for a different object. For an array of arrays, descriptor set array element numbers used in descriptor set accesses are ordered per the array-of-array ordering described in âArrays.â
If the binding point for any uniform or shader storage block instance is less than zero, or greater than or equal to the corresponding implementation-dependent maximum number of buffer bindings, a compile-time error will occur. When the binding qualifier is used with a uniform or shader storage block instanced as an array of size N, all elements of the array from binding through binding + N - 1 must be within this range. It is a compile-time or link-time error to use the same binding number for more than one uniform block or for more than one buffer block.
The set qualifier is only available when targeting Vulkan. It specifies the descriptor set this object belongs to. It is a compile-time error to apply set to a standalone qualifier, to a member of a block, or when not targeting an API that supports descriptor sets. It is a compile-time error to apply set to a block qualified as push_constant. By default, any non-push-constant uniform or shader storage block declared without a set identifier is assigned to descriptor set 0. Similarly, any sampler, texture, or subpass-input type declared as a uniform without a set identifier is also assigned to descriptor set 0.
If applied to an object declared as an array, all elements of the array belong to the specified set.
When generating SPIR-V, it is a compile-time error for either the set or binding value to exceed a front-end-configuration supplied maximum value.
When multiple arguments are listed in a layout declaration, the effect will be the same as if they were declared one at a time, in order from left to right, each in turn inheriting from and overriding the result from the previous qualification.
For example
layout(row_major, column_major)
88

results in the qualification being column_major. Other examples:

layout(shared, row_major) uniform; // default is now shared and row_major

layout(std140) uniform Transform { // layout of this block is std140

mat4 M1;

// row major

layout(column_major) mat4 M2; // column major

mat3 N1;

// row major

};

uniform T2 { ...
};

// layout of this block is shared

layout(column_major) uniform T3 { mat4 M3; layout(row_major) mat4 m4; mat3 N2;
};

// shared and column major // column major // row major // column major

When targeting Vulkan, the offset and align qualifiers for blocks and block members can only be used with uniform and buffer blocks. When not targeting Vulkan, they can only be used with blocks declared with std140 or std430 layouts.
The offset qualifier can only be used on block members. The offset qualifier forces the qualified member to start at or after the specified layout-qualifier-value, which will be its byte offset from the beginning of the buffer. It is a compile-time error to have any offset, explicit or assigned, that lies within another member of the block. When not generating SPIR-V, it is a compile-time error to specify an offset that is smaller than the offset of the previous member in the block. Two blocks linked together in the same program with the same block name must have the exact same set of members qualified with offset and their layout-qualifier-value values must be the same, or a linktime error results. The specified offset must be a multiple of the base alignment of the type of the block member it qualifies, or a compile-time error results.
The align qualifier makes the start of each block member have a minimum byte alignment. It does not affect the internal layout within each member, which will still follow the std140 or std430 rules. The specified alignment must be greater than 0 and a power of 2, or a compile-time error results.
The actual alignment of a member will be the greater of the specified align alignment and the standard (e.g. std140) base alignment for the memberâs type. The actual offset of a member is computed as follows: If offset was declared, start with that offset, otherwise start with the offset immediately following the preceding member (in declaration order). If the resulting offset is not a multiple of the actual alignment, increase it to the first offset that is a multiple of the actual alignment. This results in the actual offset the member will have.
When align is applied to an array, it affects only the start of the array, not the arrayâs internal stride. Both an offset and an align qualifier can be specified on a declaration.

89

The align qualifier, when used on a block, has the same effect as qualifying each member with the same align value as declared on the block, and gets the same compile-time results and errors as if this had been done. As described in general earlier, an individual member can specify its own align, which overrides the block-level align, but just for that member.
Examples:

layout(std140) uniform block {

vec4 a;

// a takes offsets 0-15

layout(offset = 32) vec3 b; // b takes offsets 32-43

layout(offset = 40) vec2 c; // ERROR, lies within previous member

layout(offset = 48) vec2 d; // d takes offsets 48-55

layout(align = 16) float e; // e takes offsets 64-67

layout(align = 2) double f; // f takes offsets 72-79

layout(align = 6) double g; // ERROR, 6 is not a power of 2

layout(offset = 80) float h; // h takes offsets 80-83

layout(align = 64) dvec3 i; // i takes offsets 128-151

layout(offset = 164, align = 8)

float j;

// j takes offsets 168-171

};

4.4.6. Opaque Uniform Layout Qualifiers
Opaque uniform variables can take the uniform layout qualifier for binding:
layout-qualifier-id : binding = layout-qualifier-value
The binding qualifier specifies the point where the variable will be bound. Any opaque variable declared without a binding qualifier has a default binding of zero.
When used with OpenGL, if the binding qualifier is used with an array, the first element of the array takes the specified binding point and each subsequent element takes the next consecutive binding point. For an array of arrays, each element (e.g. 6 elements for a[2][3]) gets a binding point, and they are ordered per the array of array ordering described in âArrays.â
When targeting Vulkan, if the binding qualifier is used with an array, the entire array takes only the provided binding number. The next consecutive binding number is available for a different object.
If the binding is less than zero, or greater than or equal to the implementation-dependent maximum supported number of binding points, a compile-time error will occur. When the binding qualifier is used with an array of size N, all elements of the array from binding through binding + N - 1 must be within this range. It is a compile-time or link-time error to use the same binding number for more than one atomic counter, unless the offset for the atomic counters sharing the same binding are all different.
A link-time error will result if two shaders in a program specify different layout-qualifier-value bindings for the same opaque-uniform name. However, it is not an error to specify a binding on

90

some but not all declarations for the same name, as shown in the examples below.

// in one shader... layout(binding=3) uniform sampler2D s; // s bound to point 3

// in another shader... uniform sampler2D s;

// okay, s still bound at 3

// in another shader... layout(binding=4) uniform sampler2D s; // ERROR: contradictory bindings

4.4.7. Atomic Counter Layout Qualifiers
Atomic counters are not available when targeting Vulkan.
Atomic counter layout qualifiers can be used on atomic counter declarations. The atomic counter qualifiers are:
layout-qualifier-id : binding = layout-qualifier-value offset = layout-qualifier-value
For example,
layout(binding = 2, offset = 4) uniform atomic_uint a;
will establish that the opaque handle to the atomic counter a will be bound to atomic counter buffer binding point 2 at an offset of 4 basic machine units into that buffer. The default offset for binding point 2 will be post incremented by 4 (the size of an atomic counter).
A subsequent atomic counter declaration will inherit the previous (post incremented) offset. For example, a subsequent declaration of
layout(binding = 2) uniform atomic_uint bar;
will establish that the atomic counter bar has a binding to buffer binding point 2 at an offset of 8 basic machine units into that buffer. The offset for binding point 2 will again be post-incremented by 4 (the size of an atomic counter).
When multiple variables are listed in a layout declaration, the effect will be the same as if they were declared one at a time, in order from left to right.
Binding points are not inherited, only offsets. Each binding point tracks its own current default offset for inheritance of subsequent variables using the same binding. The initial state of compilation is that all binding points have an offset of 0. The offset can be set per binding point at global scope (without declaring a variable). For example,

91

layout(binding = 2, offset = 4) uniform atomic_uint;

Establishes that the next atomic_uint declaration for binding point 2 will inherit offset 4 (but does not establish a default binding):
layout(binding = 2) uniform atomic_uint bar; // offset is 4 layout(offset = 8) uniform atomic_uint bar; // error, no default binding

Atomic counters may share the same binding point, but if a binding is shared, their offsets must be either explicitly or implicitly (from inheritance) unique and non overlapping.
Example valid uniform declarations, assuming top of shader:

layout(binding=3, offset=4) uniform atomic_uint a; // offset = 4

layout(binding=2) uniform atomic_uint b;

// offset = 0

layout(binding=3) uniform atomic_uint c;

// offset = 8

layout(binding=2) uniform atomic_uint d;

// offset = 4

Example of an invalid uniform declaration:

layout(offset=4) ...

// error, must include binding

layout(binding=1, offset=0) ... a; // okay

layout(binding=2, offset=0) ... b; // okay

layout(binding=1, offset=0) ... c; // error, offsets must not be shared

// between a and c

layout(binding=1, offset=2) ... d; // error, overlaps offset 0 of a

It is a compile-time error to bind an atomic counter with a binding value greater than or equal to gl_MaxAtomicCounterBindings. It is a compile-time error to declare an unsized array of atomic_uint.
4.4.8. Format Layout Qualifiers
Format layout qualifiers can be used on image variable declarations (those declared with a basic type having âimageâ in its keyword). The format layout qualifier identifiers for image variable declarations are:
layout-qualifier-id : float-image-format-qualifier int-image-format-qualifier uint-image-format-qualifier binding = layout-qualifier-value
float-image-format-qualifier : rgba32f

92

rgba16f rg32f rg16f r11f_g11f_b10f r32f r16f rgba16 rgb10_a2 rgba8 rg16 rg8 r16 r8 rgba16_snorm rgba8_snorm rg16_snorm rg8_snorm r16_snorm r8_snorm
int-image-format-qualifier : rgba32i rgba16i rgba8i rg32i rg16i rg8i r32i r16i r8i
uint-image-format-qualifier : rgba32ui rgba16ui rgb10_a2ui rgba8ui rg32ui rg16ui rg8ui r32ui r16ui r8ui
A format layout qualifier specifies the image format associated with a declared image variable. Only one format qualifier may be specified for any image variable declaration. For image variables with floating-point component types (keywords starting with âimageâ), signed integer component types (keywords starting with âiimageâ), or unsigned integer component types (keywords starting with âuimageâ), the format qualifier used must match the float-image-format-qualifier, int-image-
93

format-qualifier, or uint-image-format-qualifier grammar rules, respectively. It is a compile-time error to declare an image variable where the format qualifier does not match the image variable type.
Any image variable used for image loads or atomic operations must specify a format layout qualifier; it is a compile-time error to pass an image uniform variable or function parameter declared without a format layout qualifier to an image load or atomic function.
Uniforms not qualified with writeonly must have a format layout qualifier. Note that an image variable passed to a function for read access cannot be declared as writeonly and hence must have been declared with a format layout qualifier.
The binding qualifier was described in âOpaque Uniform Layout Qualifiersâ.
4.4.9. Subpass Input Qualifier
Subpass inputs are only available when targeting Vulkan.
Subpass inputs are declared with the basic subpassInput types. They must be declared with the layout qualifier input_attachment_index, or a compile-time error results. For example:
layout(input_attachment_index = 2) uniform subpassInput t;

This selects which subpass input is being read from. The value assigned to input_attachment_index, say i (input_attachment_index = i), selects that entry (i th entry) in the input list for the pass. See the API documentation for more detail about passes and the input list.
If an array of size N is declared, it consumes N consecutive input_attachment_index values, starting with the one provided.
It is a compile-time or link-time error to have different variables declared with the same input_attachment_index. This includes any overlap in the implicit input_attachment_index consumed by array declarations.
It is a compile-time error if the value assigned to an input_attachment_index is greater than or equal to gl_MaxInputAttachments.

4.5. Interpolation Qualifiers

Inputs and outputs that could be interpolated can be further qualified by at most one of the following interpolation qualifiers:

Qualifier smooth flat noperspective

Meaning perspective correct interpolation no interpolation linear interpolation

The presence of and type of interpolation is controlled by the above interpolation qualifiers as well

94

as the auxiliary storage qualifiers centroid and sample. When no interpolation qualifier is present, smooth interpolation is used. It is a compile-time error to use more than one interpolation qualifier. The auxiliary storage qualifier patch is not used for interpolation; it is a compile-time error to use interpolation qualifiers with patch.
A variable qualified as flat will not be interpolated. Instead, it will have the same value for every fragment within a primitive. This value will come from a single provoking vertex, as described by the API. A variable qualified as flat may also be qualified as centroid or sample, which will mean the same thing as qualifying it only as flat.
A variable qualified as smooth will be interpolated in a perspective-correct manner over the primitive being rendered. Interpolation in a perspective correct manner is specified in equation 14.7 of the OpenGL Specification, section 14.5 âLine Segmentsâ.
A variable qualified as noperspective must be interpolated linearly in screen space, as described in equation 3.7 of the OpenGL Specification, section 3.5 âLine Segmentsâ.
When multisample rasterization is disabled, or for fragment shader input variables qualified with neither centroid nor sample, the value of the assigned variable may be interpolated anywhere within the pixel and a single value may be assigned to each sample within the pixel, to the extent permitted by the OpenGL Specification.
When multisample rasterization is enabled, centroid and sample may be used to control the location and frequency of the sampling of the qualified fragment shader input. If a fragment shader input is qualified with centroid, a single value may be assigned to that variable for all samples in the pixel, but that value must be interpolated at a location that lies in both the pixel and in the primitive being rendered, including any of the pixelâs samples covered by the primitive. Because the location at which the variable is interpolated may be different in neighboring pixels, and derivatives may be computed by computing differences between neighboring pixels, derivatives of centroid-sampled inputs may be less accurate than those for non-centroid interpolated variables. If a fragment shader input is qualified with sample, a separate value must be assigned to that variable for each covered sample in the pixel, and that value must be sampled at the location of the individual sample.
It is a link-time error if, within the same stage, the interpolation qualifiers of variables of the same name do not match.
4.5.1. Redeclaring Built-In Interpolation Variables in the Compatibility Profile
The following predeclared variables can be redeclared with an interpolation qualifier when using the compatibility profile:
Vertex, tessellation control, tessellation evaluation, and geometry languages:
95

gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor

Fragment language:

gl_Color gl_SecondaryColor

For example,

in vec4 gl_Color;

// predeclared by the fragment language

flat in vec4 gl_Color;

// redeclared by user to be flat

flat in vec4 gl_FrontColor; // input to geometry shader, no "gl_in[]"

flat out vec4 gl_FrontColor; // output from geometry shader

Ideally, these are redeclared as part of the redeclaration of an interface block, as described in âCompatibility Profile Built-In Language Variablesâ. However, for the above purpose, they can be redeclared as individual variables at global scope, outside an interface block. Such redeclarations also allow adding the transform-feedback qualifiers xfb_buffer, xfb_stride, and xfb_offset to output variables. (Using xfb_buffer on a variable does not change the global default buffer.) A compile-time error will result if a shader has both an interface block redeclaration and a separate redeclaration of a member of that interface block outside the interface block redeclaration.
If gl_Color is redeclared with an interpolation qualifier, then gl_FrontColor and gl_BackColor (if they are written to) must also be redeclared with the same interpolation qualifier, and vice versa. If gl_SecondaryColor is redeclared with an interpolation qualifier, then gl_FrontSecondaryColor and _gl_BackSecondaryColor _(if they are written to) must also be redeclared with the same interpolation qualifier, and vice versa. This qualifier matching on predeclared variables is only required for variables that are statically used within the shaders in a program.

4.6. Parameter Qualifiers

In addition to precision qualifiers and memory qualifiers, parameters can have these parameter qualifiers.

Qualifier <none: default> const
in

Meaning same as in for function parameters that cannot be written to for function parameters passed into a function

96

