Programming from the Ground Up
Jonathan Bartlett
Edited by
Dominick Bruno, Jr.

Programming from the Ground Up by Jonathan Bartlett
Edited by Dominick Bruno, Jr.
Copyright © 2003 by Jonathan Bartlett
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is included in Appendix H. In addition, you are granted full rights to use the code examples for any purpose without even having to credit the authors. All trademarks are property of their respective owners.
This book can be purchased at http://www.bartlettpublishing.com/
This book is not a reference book, it is an introductory book. It is therefore not suitable by itself to learn how to professionally program in x86 assembly language, as some details have been left out to make the learning process smoother. The point of the book is to help the student understand how assembly language and computer programming works, not to be a reference to the subject. Reference information about a particular processor can be obtained by contacting the company which makes it.
To receive a copy of this book in electronic form, please visit the website http://savannah.nongnu.org/projects/pgubook/ This site contains the instructions for downloading a transparent copy of this book as deﬁned by the GNU Free Documentation License.

Table of Contents
1. Introduction........................................................................................................1 Welcome to Programming ...............................................................................1 Your Tools ........................................................................................................3
2. Computer Architecture .....................................................................................7 Structure of Computer Memory.......................................................................7 The CPU...........................................................................................................9 Some Terms ...................................................................................................11 Interpreting Memory......................................................................................13 Data Accessing Methods................................................................................14 Review ...........................................................................................................16
3. Your First Programs ........................................................................................19 Entering in the Program .................................................................................19 Outline of an Assembly Language Program..................................................22 Planning the Program.....................................................................................28 Finding a Maximum Value.............................................................................31 Addressing Modes .........................................................................................41 Review ...........................................................................................................45
4. All About Functions.........................................................................................49 Dealing with Complexity...............................................................................49 How Functions Work .....................................................................................50 Assembly-Language Functions using the C Calling Convention ..................52 A Function Example ......................................................................................59 Recursive Functions.......................................................................................64 Review ...........................................................................................................71
5. Dealing with Files.............................................................................................75 The UNIX File Concept.................................................................................75 Buffers and .bss ...........................................................................................76 Standard and Special Files .............................................................................78 Using Files in a Program................................................................................79
iii

Review ...........................................................................................................93 6. Reading and Writing Simple Records ...........................................................95
Writing Records ...........................................................................................100 Reading Records ..........................................................................................104 Modifying the Records ................................................................................111 Review .........................................................................................................114 7. Developing Robust Programs........................................................................117 Where Does the Time Go?...........................................................................117 Some Tips for Developing Robust Programs...............................................118 Handling Errors Effectively .........................................................................121 Making Our Program More Robust .............................................................123 Review .........................................................................................................126 8. Sharing Functions with Code Libraries.......................................................129 Using a Shared Library ................................................................................130 How Shared Libraries Work ........................................................................133 Finding Information about Libraries............................................................134 Useful Functions ..........................................................................................140 Building a Shared Library............................................................................141 Review .........................................................................................................143 9. Intermediate Memory Topics........................................................................147 How a Computer Views Memory ................................................................147 The Memory Layout of a Linux Program....................................................149 Every Memory Address is a Lie ..................................................................151 Getting More Memory .................................................................................155 A Simple Memory Manager ........................................................................157 Using our Allocator......................................................................................174 More Information.........................................................................................177 Review .........................................................................................................178
iv

10. Counting Like a Computer .........................................................................181 Counting.......................................................................................................181 Truth, Falsehood, and Binary Numbers .......................................................186 The Program Status Register .......................................................................195 Other Numbering Systems...........................................................................196 Octal and Hexadecimal Numbers ................................................................199 Order of Bytes in a Word .............................................................................201 Converting Numbers for Display .................................................................204 Review .........................................................................................................210
11. High-Level Languages .................................................................................213 Compiled and Interpreted Languages ..........................................................213 Your First C Program ...................................................................................215 Perl ...............................................................................................................218 Python ..........................................................................................................219 Review .........................................................................................................220
12. Optimization.................................................................................................223 When to Optimize ........................................................................................223 Where to Optimize.......................................................................................224 Local Optimizations.....................................................................................225 Global Optimization.....................................................................................229 Review .........................................................................................................230
13. Moving On from Here .................................................................................233 From the Bottom Up ....................................................................................234 From the Top Down .....................................................................................234 From the Middle Out ...................................................................................235 Specialized Topics .......................................................................................236 Further Resources on Assembly Language..................................................237
v

A. GUI Programming ........................................................................................239 B. Common x86 Instructions ............................................................................257 C. Important System Calls ................................................................................271 D. Table of ASCII Codes ...................................................................................275 E. C Idioms in Assembly Language .................................................................277 F. Using the GDB Debugger..............................................................................289 G. Document History .........................................................................................299 H. GNU Free Documentation License..............................................................301 I. Personal Dedication........................................................................................311 Index....................................................................................................................313
vi

Chapter 1. Introduction
Welcome to Programming
I love programming. I enjoy the challenge to not only make a working program, but to do so with style. Programming is like poetry. It conveys a message, not only to the computer, but to those who modify and use your program. With a program, you build your own world with your own rules. You create your world according to your conception of both the problem and the solution. Masterful programmers create worlds with programs that are clear and succinct, much like a poem or essay.
One of the greatest programmers, Donald Knuth, describes programming not as telling a computer how to do something, but telling a person how they would instruct a computer to do something. The point is that programs are meant to be read by people, not just computers. Your programs will be modiﬁed and updated by others long after you move on to other projects. Thus, programming is not as much about communicating to a computer as it is communicating to those who come after you. A programmer is a problem-solver, a poet, and an instructor all at once. Your goal is to solve the problem at hand, doing so with balance and taste, and teach your solution to future programmers. I hope that this book can teach at least some of the poetry and magic that makes computing exciting.
Most introductory books on programming frustrate me to no end. At the end of them you can still ask "how does the computer really work?" and not have a good answer. They tend to pass over topics that are difﬁcult even though they are important. I will take you through the difﬁcult issues because that is the only way to move on to masterful programming. My goal is to take you from knowing nothing about programming to understanding how to think, write, and learn like a programmer. You won’t know everything, but you will have a background for how everything ﬁts together. At the end of this book, you should be able to do the following:
1

Chapter 1. Introduction
• Understand how a program works and interacts with other programs
• Read other people’s programs and learn how they work
• Learn new programming languages quickly
• Learn advanced concepts in computer science quickly
I will not teach you everything. Computer science is a massive ﬁeld, especially when you combine the theory with the practice of computer programming. However, I will attempt to get you started on the foundations so you can easily go wherever you want afterwards.
There is somewhat of a chicken and egg problem in teaching programming, especially assembly language. There is a lot to learn - it’s almost too much to learn almost at once, but each piece depends on all the others. Therefore, you must be patient with yourself and the computer while learning to program. If you don’t understand something the ﬁrst time, reread it. If you still don’t understand it, it is sometimes best to take it by faith and come back to it later. Often after more exposure to programming the ideas will make more sense. Don’t get discouraged. It’s a long climb, but very worthwhile.
At the end of each chapter are three sets of review exercises. The ﬁrst set is more or less regurgitation - they check to see if can you give back what you learned in the chapter. The second set contains application questions - they check to see if you can apply what you learned to solve problems. The ﬁnal set is to see if you are capable of broadening your horizons. Some of these questions may not be answerable until later in the book, but they give you some things to think about. Other questions require some research into outside sources to discover the answer. Still others require you to simply analyze your options and explain a best solution. Many of the questions don’t have right or wrong answers, but that doesn’t mean they are unimportant. Learning the issues involved in programming, learning how to research answers, and learning how to look ahead are all a major part of a programmer’s work.
If you have problems that you just can’t get past, there is a mailing list for this
2

Chapter 1. Introduction
book where readers can discuss and get help with what they are reading. The address is pgubook-readers@nongnu.org. This mailing list is open for any type of question or discussion along the lines of this book. You can subscribe to this list by going to http://mail.nongnu.org/mailman/listinfo/pgubook-readers.
Your Tools
This book teaches assembly language for x86 processors and the GNU/Linux operating system. Therefore we will be giving all of the examples using the GNU/Linux standard GCC tool set. If you are not familiar with GNU/Linux and the GCC tool set, they will be described shortly. If you are new to Linux, you should check out the guide available at http://rute.sourceforge.net/1 What I intend to show you is more about programming in general than using a speciﬁc tool set on a speciﬁc platform, but standardizing on one makes the task much easier.
Those new to Linux should also try to get involved in their local GNU/Linux User’s Group. User’s Group members are usually very helpful for new people, and will help you from everything from installing Linux to learning to use it most efﬁciently. A listing of GNU/Linux User’s Groups is available at http://www.linux.org/groups/
All of these programs have been tested using Red Hat Linux 8.0, and should work with any other GNU/Linux distribution, too.2 They will not work with non-Linux operating systems such as BSD or other systems. However, all of the skills learned in this book should be easily transferable to any other system.
If you do not have access to a GNU/Linux machine, you can look for a hosting provider who offers a Linux shell account, which is a command-line only interface
1. This is quite a large document. You certainly don’t need to know everything to get started with this book. You simply need to know how to navigate from the command line and how to use an editor like pico, emacs, or vi (or others). 2. By "GNU/Linux distribution", I mean an x86 GNU/Linux distribution. GNU/Linux distributions for the Power Macintosh, the Alpha processor, or other processors will not work with this book.
3

Chapter 1. Introduction
to a Linux machine. There are many low-cost shell account providers, but you have to make sure that they match the requirements above (i.e. - Linux on x86). Someone at your local GNU/Linux User’s Group may be able to give you one as well. Shell accounts only require that you already have an Internet connection and a telnet program. If you use Windows®, you already have a telnet client - just click on start, then run, then type in telnet. However, it is usually better to download PuTTY from http://www.chiart.greenend.co.uk/~sgtatham/putty/ because Windows’ telnet has some weird problems. There are a lot of options for the Macintosh, too. NiftyTelnet is my favorite.
If you don’t have GNU/Linux and can’t ﬁnd a shell account service, then you can download Knoppix from http://www.knoppix.org/ Knoppix is a GNU/Linux distribution that boots from CD so that you don’t have to actually install it. Once you are done using it, you just reboot and remove the CD and you are back to your regular operating system.
So what is GNU/Linux? GNU/Linux is an operating system modeled after UNIX®. The GNU part comes from the GNU Project (http://www.gnu.org/)3, which includes most of the programs you will run, including the GCC tool set that we will use to program with. The GCC tool set contains all of the programs necessary to create programs in various computer languages.
Linux is the name of the kernel. The kernel is the core part of an operating system that keeps track of everything. The kernel is both an fence and a gate. As a gate, it allows programs to access hardware in a uniform way. Without the kernel, you would have to write programs to deal with every device model ever made. The kernel handles all device-speciﬁc interactions so you don’t have to. It also handles ﬁle access and interaction between processes. For example, when you type, your typing goes through several programs before it hits your editor. First, the kernel is what handles your hardware, so it is the ﬁrst to receive notice about the keypress. The keyboard sends in scancodes to the kernel, which then converts them to the actual letters, numbers, and symbols they represent. If you are using a windowing
3. The GNU Project is a project by the Free Software Foundation to produce a complete, free operating system.
4

Chapter 1. Introduction system (like Microsoft Windows® or the X Window System), then the windowing system reads the keypress from the kernel, and delivers it to whatever program is currently in focus on the user’s display.
Example 1-1. How the computer processes keyboard sigals
Keyboard -> Kernel -> Windowing system -> Application program
The kernel also controls the ﬂow of information between programs. The kernel is a program’s gate to the world around it. Every time that data moves between processes, the kernel controls the messaging. In our keyboard example above, the kernel would have to be involved for the windowing system to communicate the keypress to the application program. As a fence, the kernel prevents programs from accidentally overwriting each other’s data and from accessing ﬁles and devices that they don’t have permission to. It limits the amount of damage a poorly-written program can do to other running programs. In our case, the kernel is Linux. Now, the kernel all by itself won’t do anything. You can’t even boot up a computer with just a kernel. Think of the kernel as the water pipes for a house. Without the pipes, the faucets won’t work, but the pipes are pretty useless if there are no faucets. Together, the user applications (from the GNU project and other places) and the kernel (Linux) make up the entire operating system, GNU/Linux. For the most part, this book will be using the computer’s low-level assembly language. There are essentially three kinds of languages:
Machine Language This is what the computer actually sees and deals with. Every command the computer sees is given as a number or sequence of numbers.
5

Chapter 1. Introduction Assembly Language
This is the same as machine language, except the command numbers have been replaced by letter sequences which are easier to memorize. Other small things are done to make it easier as well. High-Level Language High-level languages are there to make programming easier. Assembly language requires you to work with the machine itself. High-level languages allow you to describe the program in a more natural language. A single command in a high-level language usually is equivalent to several commands in an assembly language. In this book we will learn assembly language, although we will cover a bit of high-level languages. Hopefully by learning assembly language, your understanding of how programming and computers work will put you a step ahead.
6

Chapter 2. Computer Architecture
Before learning how to program, you need to ﬁrst understand how a computer interprets programs. You don’t need a degree in electrical engineering, but you need to understand some basics. Modern computer architecture is based off of an architecture called the Von Neumann architecture, named after its creator. The Von Neumann architecture divides the computer up into two main parts - the CPU (for Central Processing Unit) and the memory. This architecture is used in all modern computers, including personal computers, supercomputers, mainframes, and even cell phones.
Structure of Computer Memory
To understand how the computer views memory, imagine your local post ofﬁce. They usually have a room ﬁlled with PO Boxes. These boxes are similar to computer memory in that each are numbered sequences of ﬁxed-size storage locations. For example, if you have 256 megabytes of computer memory, that means that your computer contains roughly 256 million ﬁxed-size storage locations. Or, to use our analogy, 256 million PO Boxes. Each location has a number, and each location has the same, ﬁxed-length size. The difference between a PO Box and computer memory is that you can store all different kinds of things in a PO Box, but you can only store a single number in a computer memory storage location.
7

Chapter 2. Computer Architecture
Memory locations are like PO Boxes You may wonder why a computer is organized this way. It is because it is simple to implement. If the computer were composed of a lot of differently-sized locations, or if you could store different kinds of data in them, it would be difﬁcult and expensive to implement. The computer’s memory is used for a number of different things. All of the results of any calculations are stored in memory. In fact, everything that is "stored" is stored in memory. Think of your computer at home, and imagine what all is stored in your computer’s memory. • The location of your cursor on the screen • The size of each window on the screen • The shape of each letter of each font being used • The layout of all of the controls on each window • The graphics for all of the toolbar icons
8

Chapter 2. Computer Architecture • The text for each error message and dialog box • The list goes on and on... In addition to all of this, the Von Neumann architecture speciﬁes that not only computer data should live in memory, but the programs that control the computer’s operation should live there, too. In fact, in a computer, there is no difference between a program and a program’s data except how it is used by the computer. They are both stored and accessed the same way.
The CPU
So how does the computer function? Obviously, simply storing data doesn’t do much help - you need to be able to access, manipulate, and move it. That’s where the CPU comes in. The CPU reads in instructions from memory one at a time and executes them. This is known as the fetch-execute cycle. The CPU contains the following elements to accomplish this:
• Program Counter • Instruction Decoder • Data bus • General-purpose registers • Arithmetic and logic unit The program counter is used to tell the computer where to fetch the next instruction from. We mentioned earlier that there is no difference between the way data and programs are stored, they are just interpreted differently by the CPU. The program counter holds the memory address of the next instruction to be executed. The CPU begins by looking at the program counter, and fetching whatever number is stored in memory at the location speciﬁed. It is then passed on to the instruction
9

Chapter 2. Computer Architecture
decoder which ﬁgures out what the instruction means. This includes what process needs to take place (addition, subtraction, multiplication, data movement, etc.) and what memory locations are going to be involved in this process. Computer instructions usually consist of both the actual instruction and the list of memory locations that are used to carry it out.
Now the computer uses the data bus to fetch the memory locations to be used in the calculation. The data bus is the connection between the CPU and memory. It is the actual wire that connects them. If you look at the motherboard of the computer, the wires that go out from the memory are your data bus.
In addition to the memory on the outside of the processor, the processor itself has some special, high-speed memory locations called registers. There are two kinds of registers - general registers and special-purpose registers. General-purpose registers are where the main action happens. Addition, subtraction, multiplication, comparisions, and other operations generally use general-purpose registers for processing. However, computers have very few general-purpose registers. Most information is stored in main memory, brought in to the registers for processing, and then put back into memory when the processing is completed. special-purpose registers are registers which have very speciﬁc purposes. We will discuss these as we come to them.
Now that the CPU has retrieved all of the data it needs, it passes on the data and the decoded instruction to the arithmetic and logic unit for further processing. Here the instruction is actually executed. After the results of the computation have been calculated, the results are then placed on the data bus and sent to the appropriate location in memory or in a register, as speciﬁed by the instruction.
This is a very simpliﬁed explanation. Processors have advanced quite a bit in recent years, and are now much more complex. Although the basic operation is still the same, it is complicated by the use of cache hierarchies, superscalar processors, pipelining, branch prediction, out-of-order execution, microcode translation, coprocessors, and other optimizations. Don’t worry if you don’t know what those words mean, you can just use them as Internet search terms if you want
10

to learn more about the CPU.

Chapter 2. Computer Architecture

Some Terms
Computer memory is a numbered sequence of ﬁxed-size storage locations. The number attached to each storage location is called it’s address. The size of a single storage location is called a byte. On x86 processors, a byte is a number between 0 and 255.
You may be wondering how computers can display and use text, graphics, and even large numbers when all they can do is store numbers between 0 and 255. First of all, specialized hardware like graphics cards have special interpretations of each number. When displaying to the screen, the computer uses ASCII code tables to translate the numbers you are sending it into letters to display on the screen, with each number translating to exactly one letter or numeral.1 For example, the capital letter A is represented by the number 65. The numeral 1 is represented by the number 49. So, to print out "HELLO", you would actually give the computer the sequence of numbers 72, 69, 76, 76, 79. To print out the number 100, you would give the computer the sequence of numbers 49, 48, 48. A list of ASCII characters and their numeric codes is found in Appendix D.
In addition to using numbers to represent ASCII characters, you as the programmer get to make the numbers mean anything you want them to, as well. For example, if I am running a store, I would use a number to represent each item I was selling. Each number would be linked to a series of other numbers which would be the ASCII codes for what I wanted to display when the items were scanned in. I would have more numbers for the price, how many I have in inventory, and so on.
1. With the advent of international character sets and Unicode, this is not entirely true anymore. However, for the purposes of keeping this simple for beginners, we will use the assumption that one number translates directly to one character. For more information, see Appendix D.

11

Chapter 2. Computer Architecture
So what about if we need numbers larger than 255? We can simply use a combination of bytes to represent larger numbers. Two bytes can be used to represent any number between 0 and 65536. Four bytes can be used to represent any number between 0 and 4294967295. Now, it is quite difﬁcult to write programs to stick bytes together to increase the size of your numbers, and requires a bit of math. Luckily, the computer will do it for us for numbers up to 4 bytes long. In fact, four-byte numbers are what we will work with by default.
We mentioned earlier that in addition to the regular memory that the computer has, it also has special-purpose storage locations called registers. Registers are what the computer uses for computation. Think of a register as a place on your desk - it holds things you are currently working on. You may have lots of information tucked away in folders and drawers, but the stuff you are working on right now is on the desk. Registers keep the contents of numbers that you are currently manipulating.
On the computers we are using, registers are each four bytes long. The size of a typical register is called a computer’s word size. x86 processors have four-byte words. This means that it is most natural on these computers to do computations four bytes at a time. This gives us roughly 4 billion values.
Addresses are also four bytes (1 word) long, and therefore also ﬁt into a register. x86 processors can access up to 4294967296 bytes if enough memory is installed. Notice that this means that we can store addresses the same way we store any other number. In fact, the computer can’t tell the difference between a value that is an address, a value that is a number, a value that is an ASCII code, or a value that you have decided to use for another purpose. A number becomes an ASCII code when you attempt to display it. A number becomes an address when you try to look up the byte it points to. Take a moment to think about this, because it is crucial to understanding how computer programs work.
Addresses which are stored in memory are also called pointers, because instead of having a regular value in them, they point you to a different location in memory.
As we’ve mentioned, computer instructions are also stored in memory. In fact,
12

Chapter 2. Computer Architecture
they are stored exactly the same way that other data is stored. The only way the computer knows that a memory location is an instruction is that a special-purpose register called the instruction pointer points to them at one point or another. If the instruction pointer points to a memory word, it is loaded as an instruction. Other than that, the computer has no way of knowing the difference between programs and other types of data.2
Interpreting Memory
Computers are very exact. Because they are exact, programmers have to be equally exact. A computer has no idea what your program is supposed to do. Therefore, it will only do exactly what you tell it to do. If you accidentally print out a regular number instead of the ASCII codes that make up the number’s digits, the computer will let you - and you will wind up with jibberish on your screen (it will try to look up what your number represents in ASCII and print that). If you tell the computer to start executing instructions at a location containing data instead of program instructions, who knows how the computer will interpret that but it will certainly try. The computer will execute your instructions in the exact order you specify, even if it doesn’t make sense.
The point is, the computer will do exactly what you tell it, no matter how little sense it makes. Therefore, as a programmer, you need to know exactly how you have your data arranged in memory. Remember, computers can only store numbers, so letters, pictures, music, web pages, documents, and anything else are just long sequences of numbers in the computer, which particular programs know how to interpret.
For example, say that you wanted to store customer information in memory. One way to do so would be to set a maximum size for the customer’s name and address - say 50 ASCII characters for each, which would be 50 bytes for each. Then, after
2. Note that here we are talking about general computer theory. Some processors and operating systems actually mark the regions of memory that can be executed with a special marker that indicates this.
13

Chapter 2. Computer Architecture that, have a number for the customer’s age and their customer id. In this case, you would have a block of memory that would look like this:
Start of Record: Customer’s name (50 bytes) - start of record Customer’s address (50 bytes) - start of record + 50 bytes Customer’s age (1 word - 4 bytes) - start of record + 100 bytes Customer’s id number (1 word - 4 bytes) - start of record + 104 byte
This way, given the address of a customer record, you know where the rest of the data lies. However, it does limit the customer’s name and address to only 50 ASCII characters each. What if we didn’t want to specify a limit? Another way to do this would be to have in our record pointers to this information. For example, instead of the customer’s name, we would have a pointer to their name. In this case, the memory would look like this:
Start of Record: Customer’s name pointer (1 word) - start of record Customer’s address pointer (1 word) - start of record + 4 Customer’s age (1 word) - start of record + 8 Customer’s id number (1 word) - start of record + 12
The actual name and address would be stored elsewhere in memory. This way, it is easy to tell where each part of the data is from the start of the record, without explicitly limitting the size of the name and address. If the length of the ﬁelds within our records could change, we would have no idea where the next ﬁeld started. Because records would be different sizes, it would also be hard to ﬁnd where the next record began. Therefore, almost all records are of ﬁxed lengths. Variable-length data is usually store separately from the rest of the record.
14

Data Accessing Methods

Chapter 2. Computer Architecture

Processors have a number of different ways of accessing data, known as addressing modes. The simplest mode is immediate mode, in which the data to access is embedded in the instruction itself. For example, if we want to initialize a register to 0, instead of giving the computer an address to read the 0 from, we would specify immediate mode, and give it the number 0.

In the register addressing mode, the instruction contains a register to access, rather than a memory location. The rest of the modes will deal with addresses.

In the direct addressing mode, the instruction contains the memory address to access. For example, I could say, please load this register with the data at address 2002. The computer would go directly to byte number 2002 and copy the contents into our register.

In the indexed addressing mode, the instruction contains a memory address to access, and also speciﬁes an index register to offset that address. For example, we could specify address 2002 and an index register. If the index register contains the number 4, the actual address the data is loaded from would be 2006. This way, if you have a set of numbers starting at location 2002, you can cycle between each of them using an index register. On x86 processors, you can also specify a multiplier for the index. This allows you to access memory a byte at a time or a word at a time (4 bytes). If you are accessing an entire word, your index will need to be multiplied by 4 to get the exact location of the fourth element from your address. For example, if you wanted to access the fourth byte from location 2002, you would load your index register with 3 (remember, we start counting at 0) and set the multiplier to 1 since you are going a byte at a time. This would get you location 2005. However, if you wanted to access the fourth word from location 2002, you would load your index register with 3 and set the multiplier to 4. This would load from location 2014 - the fourth word. Take the time to calculate these yourself to make sure you understand how it works.

In the indirect addressing mode, the instruction contains a register that contains a pointer to where the data should be accessed. For example, if we used indirect

15

Chapter 2. Computer Architecture addressing mode and speciﬁed the %eax register, and the %eax register contained the value 4, whatever value was at memory location 4 would be used. In direct addressing, we would just load the value 4, but in indirect addressing, we use 4 as the address to use to ﬁnd the data we want. Finally, there is the base pointer addressing mode. This is similar to indirect addressing, but you also include a number called the offset to add to the register’s value before using it for lookup. We will use this mode quite a bit in this book. In the Section called Interpreting Memory we discussed having a structure in memory holding customer information. Let’s say we wanted to access the customer’s age, which was the eighth byte of the data, and we had the address of the start of the structure in a register. We could use base pointer addressing and specify the register as the base pointer, and 8 as our offset. This is a lot like indexed addressing, with the difference that the offset is constant and the pointer is held in a register, and in indexed addressing the offset is in a register and the pointer is constant. There are other forms of addressing, but these are the most important ones.
Review
Know the Concepts
• Describe the fetch-execute cycle. • What is a register? How would computation be more difﬁcult without registers? • How do you represent numbers larger than 255? • How big are the registers on the machines we will be using? • How does a computer know how to interpret a given byte or set of bytes of
memory?
16

Chapter 2. Computer Architecture • What are the addressing modes and what are they used for? • What does the instruction pointer do?
Use the Concepts
• What data would you use in an employee record? How would you lay it out in memory?
• If I had the pointer the the beginning of the employee record above, and wanted to access a particular piece of data inside of it, what addressing mode would I use?
• In base pointer addressing mode, if you have a register holding the value 3122, and an offset of 20, what address would you be trying to access?
• In indexed addressing mode, if the base address is 6512, the index register has a 5, and the multiplier is 4, what address would you be trying to access?
• In indexed addressing mode, if the base address is 123472, the index register has a 0, and the multiplier is 4, what address would you be trying to access?
• In indexed addressing mode, if the base address is 9123478, the index register has a 20, and the multiplier is 1, what address would you be trying to access?
Going Further
• What are the minimum number of addressing modes needed for computation? • Why include addressing modes that aren’t strictly needed? • Research and then describe how pipelining (or one of the other complicating
factors) affects the fetch-execute cycle.
17

Chapter 2. Computer Architecture • Research and then describe the tradeoffs between ﬁxed-length instructions and
variable-length instructions.
18

Chapter 3. Your First Programs
In this chapter you will learn the process for writing and building Linux assembly-language programs. In addition, you will learn the structure of assembly-language programs, and a few assembly-language commands. As you go through this chapter, you may want to refer also to Appendix B and Appendix F.
These programs may overwhelm you at ﬁrst. However, go through them with diligence, read them and their explanations as many times as necessary, and you will have a solid foundation of knowledge to build on. Please tinker around with the programs as much as you can. Even if your tinkering does not work, every failure will help you learn.

Entering in the Program
Okay, this ﬁrst program is simple. In fact, it’s not going to do anything but exit! It’s short, but it shows some basics about assembly language and Linux programming. You need to enter the program in an editor exactly as written, with the ﬁlename exit.s. The program follows. Don’t worry about not understanding it. This section only deals with typing it in and running it. In the Section called Outline of an Assembly Language Program we will describe how it works.

#PURPOSE: Simple program that exits and returns a

#

status code back to the Linux kernel

#

#INPUT: #

none

#OUTPUT: # # # #

returns a status code. This can be viewed by typing
echo $?

19

Chapter 3. Your First Programs

#

after running the program

#

#VARIABLES:

#

%eax holds the system call number

#

%ebx holds the return status

#

.section .data

.section .text .globl _start _start: movl $1, %eax

# this is the linux kernel command # number (system call) for exiting # a program

movl $0, %ebx

# this is the status number we will # return to the operating system. # Change this around and it will # return different things to # echo $?

int $0x80

# this wakes up the kernel to run # the exit command

What you have typed in is called the source code. Source code is the human-readable form of a program. In order to transform it into a program that a computer can run, we need to assemble and link it.
The ﬁrst step is to assemble it. Assembling is the process that transforms what you typed into instructions for the machine. The machine itself only reads sets of numbers, but humans prefer words. An assembly language is a more human-readable form of the instructions a computer understands. Assembling

20

Chapter 3. Your First Programs
transforms the human-readable ﬁle into a machine-readable one. To assembly the program type in the command
as exit.s -o exit.o
as is the command which runs the assembler, exit.s is the source ﬁle, and -o exit.o tells the assemble to put it’s output in the ﬁle exit.o. exit.o is an object ﬁle. An object ﬁle is code that is in the machine’s language, but has not been completely put together. In most large programs, you will have several source ﬁles, and you will convert each one into an object ﬁle. The linker is the program that is responsible for putting the object ﬁles together and adding information to it so that the kernel knows how to load and run it. In our case, we only have one object ﬁle, so the linker is only adding the information to enable it to run. To link the ﬁle, enter the command
ld exit.o -o exit
ld is the command to run the linker, exit.o is the object ﬁle we want to link, and -o exit instructs the linker to output the new program into a ﬁle called exit.1 If any of these commands reported errors, you have either mistyped your program or the command. After correcting the program, you have to re-run all the commands. You must always re-assemble and re-link programs after you modify the source ﬁle for the changes to occur in the program. You can run exit by typing in the command
./exit
The ./ is used to tell the computer that the program isn’t in one of the normal program directories, but is the current directory instead2. You’ll notice when you type this command, the only thing that happens is that you’ll go to the next line.
1. If you are new to Linux and UNIX®, you may not be aware that ﬁles don’t have to have extensions. In fact, while Windows® uses the .exe extension to signify an executable program, UNIX executables usually have no extension. 2. . refers to the current directory in Linux and UNIX systems.
21

Chapter 3. Your First Programs That’s because this program does nothing but exit. However, immediately after you run the program, if you type in
echo $?
It will say 0. What is happening is that every program when it exits gives Linux an exit status code, which tells it if everything went all right. If everything was okay, it returns 0. UNIX programs return numbers other than zero to indicate failure or other errors, warnings, or statuses. The programmer determines what each number means. You can view this code by typing in echo $?. In the following section we will look at what each part of the code does.
Outline of an Assembly Language Program
Take a look at the program we just entered. At the beginning there are lots of lines that begin with hashes (#). These are comments. Comments are not translated by the assembler. They are used only for the programmer to talk to anyone who looks at the code in the future. Most programs you write will be modiﬁed by others. Get into the habit of writing comments in your code that will help them understand both why the program exists and how it works. Always include the following in your comments:
• The purpose of the code • An overview of the processing involved • Anything strange your program does and why it does it3 After the comments, the next line says
3. You’ll ﬁnd that many programs end up doing things strange ways. Usually there is a reason for that, but, unfortunately, programmers never document such things in their comments. So, future programmers either have to learn the reason the hard way by modifying the code and watching it break, or just leaving it alone whether it is still needed or not. You should always document any strange behavior your program performs. Unfortunately, ﬁguring out what is strange and what is straightforward comes mostly with experience.
22

.section .data

Chapter 3. Your First Programs

Anything starting with a period isn’t directly translated into a machine instruction. Instead, it’s an instruction to the assembler itself. These are called assembler directives or pseudo-operations because they are handled by the assembler and are not actually run by the computer. The .section command breaks your program up into sections. This command starts the data section, where you list any memory storage you will need for data. Our program doesn’t use any, so we don’t need the section. It’s just here for completeness. Almost every program you write in the future will have data.
Right after this you have

.section .text

which starts the text section. The text section of a program is where the program instructions live.
The next instruction is

.globl _start

This instructs the assembler that _start is important to remember. _start is a symbol, which means that it is going to be replaced by something else either during assembly or linking. Symbols are generally used to mark locations of programs or data, so you can refer to them by name instead of by their location number. Imagine if you had to refer to every memory location by it’s address. First of all, it would be very confusing because you would have to memorize or look up the numeric memory address of every piece of code or data. In addition, every time you had to insert a piece of data or code you would have to change all the addresses in your program! Symbols are used so that the assembler and linker can take care of keeping track of addresses, and you can concentrate on writing your program.

23

Chapter 3. Your First Programs
.globl means that the assembler shouldn’t discard this symbol after assembly, because the linker will need it. _start is a special symbol that always needs to be marked with .globl because it marks the location of the start of the program. Without marking this location in this way, when the computer loads your program it won’t know where to begin running your program.
The next line
_start:
deﬁnes the value of the _start label. A label is a symbol followed by a colon. Labels deﬁne a symbol’s value. When the assembler is assembling the program, it has to assign each data value and instruction an address. Labels tell the assembler to make the symbol’s value be wherever the next instruction or data element will be. This way, if the actual physical location of the data or instruction changes, you don’t have to rewrite any references to it - the symbol automatically gets the new value.
Now we get into actual computer instructions. The ﬁrst such instruction is this:
movl $1, %eax
When the program runs, this instruction transfers the number 1 into the %eax register. In assembly language, many instructions have operands. movl has two operands - the source and the destination. In this case, the source is the literal number 1, and the destination is the %eax register. Operands can be numbers, memory location references, or registers. Different instructions allow different types of operands. See Appendix B for more information on which instructions take which kinds of operands.
On most instructions which have two operands, the ﬁrst one is the source operand and the second one is the destination. Note that in these cases, the source operand is not modiﬁed at all. Other instructions of this type are, for example, addl, subl, and imull. These add/subtract/multiply the source operand from/to/by the destination operand and and save the result in the destination operand. Other
24

Chapter 3. Your First Programs instructions may have an operand hardcoded in. idivl, for example, requires that the dividend be in %eax, and %edx be zero, and the quotient is then transferred to %eax and the remainder to %edx. However, the divisor can be any register or memory location. On x86 processors, there are several general-purpose registers4 (all of which can be used with movl):
• %eax
• %ebx
• %ecx
• %edx
• %edi
• %esi
In addition to these general-purpose registers, there are also several special-purpose registers, including:
• %ebp
• %esp
• %eip
• %eflags
We’ll discuss these later, just be aware that they exist.5 Some of these registers,
4. Note that on x86 processors, even the general-purpose registers have some special purposes, or used to before it went 32-bit. However, these are general-purpose registers for most instructions. Each of them has at least one instruction where it is used in a special way. However, for most of them, those instructions aren’t covered in this book. 5. You may be wondering, why do all of these registers begin with the letter e? The reason is that early generations of x86 processors were 16 bits rather than 32 bits. Therefore, the registers were only half the length they are now. In later generations of x86 processors, the size of the registers doubled. They kept the old names to refer to the ﬁrst half of the register,
25

Chapter 3. Your First Programs
like %eip and %eflags can only be accessed through special instructions. The others can be accessed using the same instructions as general-purpose registers, but they have special meanings, special uses, or are simply faster when used in a speciﬁc way.
So, the movl instruction moves the number 1 into %eax. The dollar-sign in front of the one indicates that we want to use immediate mode addressing (refer back to the Section called Data Accessing Methods in Chapter 2). Without the dollar-sign it would do direct addressing, loading whatever number is at address 1. We want the actual number 1 loaded in, so we have to use immediate mode.
The reason we are moving the number 1 into %eax is because we are preparing to call the Linux Kernel. The number 1 is the number of the exit system call . We will discuss system calls in more depth soon, but basically they are requests for the operating system’s help. Normal programs can’t do everything. Many operations such as calling other programs, dealing with ﬁles, and exiting have to be handled by the operating system through system calls. When you make a system call, which we will do shortly, the system call number has to be loaded into %eax (for a complete listing of system calls and their numbers, see Appendix C). Depending on the system call, other registers may have to have values in them as well. Note that system calls is not the only use or even the main use of registers. It is just the one we are dealing with in this ﬁrst program. Later programs will use registers for regular computation.
The operating system, however, usually needs more information than just which call to make. For example, when dealing with ﬁles, the operating system needs to know which ﬁle you are dealing with, what data you want to write, and other details. The extra details, called parameters are stored in other registers. In the case of the exit system call, the operating system requires a status code be loaded
and added an e to refer to the extended versions of the register. Usually you will only use the extended versions. Newer models also offer a 64-bit mode, which doubles the size of these registers yet again and uses an r preﬁx to indicate the larger registers (i.e. %rax is the 64-bit version of %eax). However, these processors are not widely used, and are not covered in this book.
26

Chapter 3. Your First Programs
in %ebx. This value is then returned to the system. This is the value you retrieved when you typed echo $?. So, we load %ebx with 0 by typing the following:
movl $0, %ebx
Now, loading registers with these numbers doesn’t do anything itself. Registers are used for all sorts of things besides system calls. They are where all program logic such as addition, subtraction, and comparisons take place. Linux simply requires that certain registers be loaded with certain parameter values before making a system call. %eax is always required to be loaded with the system call number. For the other registers, however, each system call has different requirements. In the exit system call, %ebx is required to be loaded with the exit status. We will discuss different system calls as they are needed. For a list of common system calls and what is required to be in each register, see Appendix C
The next instruction is the "magic" one. It looks like this:
int $0x80
The int stands for interrupt. The 0x80 is the interrupt number to use.6 An interrupt interrupts the normal program ﬂow, and transfers control from our program to Linux so that it will do a system call.7. You can think of it as like signaling Batman(or Larry-Boy8, if you prefer). You need something done, you send the signal, and then he comes to the rescue. You don’t care how he does his work - it’s more or less magic - and when he’s done you’re back in control. In this case, all we’re doing is asking Linux to terminate the program, in which case we
6. You may be wondering why it’s 0x80 instead of just 80. The reason is that the number is written in hexadecimal. In hexadecimal, a single digit can hold 16 values instead of the normal 10. This is done by utilizing the letters a through f in addition to the regular digits. a represents 10, b represents 11, and so on. 0x10 represents the number 16, and so on. This will be discussed more in depth later, but just be aware that numbers starting with 0x are in hexadecimal. Tacking on an H at the end is also sometimes used instead, but we won’t do that in this book. For more information about this, see Chapter 10 7. Actually, the interrupt transfers control to whoever set up an interrupt handler for the interrupt number. In the case of Linux, all of them are set to be handled by the Linux kernel. 8. If you don’t watch Veggie Tales, you should. Start with Dave and the Giant Pickle.
27

Chapter 3. Your First Programs won’t be back in control. If we didn’t signal the interrupt, then no system call would have been performed.
Quick System Call Review: To recap - Operating System features are accessed through system calls. These are invoked by setting up the registers in a special way and issuing the instruction int $0x80. Linux knows which system call we want to access by what we stored in the %eax register. Each system call has other requirements as to what needs to be stored in the other registers. System call number 1 is the exit system call, which requires the status code to be placed in %ebx.
Now that you’ve assembled, linked, run, and examined the program, you should make some basic edits. Do things like change the number that is loaded into %ebx, and watch it come out at the end with echo $?. Don’t forget to assemble and link it again before running it. Add some comments. Don’t worry, the worse thing that would happen is that the program won’t assemble or link, or will freeze your screen. That’s just part of learning!
Planning the Program
In our next program we will try to ﬁnd the maximum of a list of numbers. Computers are very detail-oriented, so in order to write the program we will have to have planned out a number of details. These details include:
• Where will the original list of numbers be stored? • What procedure will we need to follow to ﬁnd the maximum number? • How much storage do we need to carry out that procedure? • Will all of the storage ﬁt into registers, or do we need to use some memory as
well?
28

Chapter 3. Your First Programs You might not think that something as simple as ﬁnding the maximum number from a list would take much planning. You can usually tell people to ﬁnd the maximum number, and they can do so with little trouble. However, our minds are used to putting together complex tasks automatically. Computers need to be instructed through the process. In addition, we can usually hold any number of things in our mind without much trouble. We usually don’t even realize we are doing it. For example, if you scan a list of numbers for the maximum, you will probably keep in mind both the highest number you’ve seen so far, and where you are in the list. While your mind does this automatically, with computers you have to explicitly set up storage for holding the current position on the list and the current maximum number. You also have other problems such as how to know when to stop. When reading a piece of paper, you can stop when you run out of numbers. However, the computer only contains numbers, so it has no idea when it has reached the last of your numbers. In computers, you have to plan every step of the way. So, let’s do a little planning. First of all, just for reference, let’s name the address where the list of numbers starts as data_items. Let’s say that the last number in the list will be a zero, so we know where to stop. We also need a value to hold the current position in the list, a value to hold the current list element being examined, and the current highest value on the list. Let’s assign each of these a register:
• %edi will hold the current position in the list. • %ebx will hold the current highest value in the list. • %eax will hold the current element being examined. When we begin the program and look at the ﬁrst item in the list, since we haven’t seen any other items, that item will automatically be the current largest element in the list. Also, we will set the current position in the list to be zero - the ﬁrst element. From then, we will follow the following steps:
29

Chapter 3. Your First Programs
1. Check the current list element (%eax) to see if it’s zero (the terminating element).
2. If it is zero, exit.
3. Increase the current position (%edi).
4. Load the next value in the list into the current value register (%eax). What addressing mode might we use here? Why?
5. Compare the current value (%eax) with the current highest value (%ebx).
6. If the current value is greater than the current highest value, replace the current highest value with the current value.
7. Repeat.
That is the procedure. Many times in that procedure I made use of the word "if". These places are where decisions are to be made. You see, the computer doesn’t follow the exact same sequence of instructions every time. Depending on which "if"s are correct, the computer may follow a different set of instructions. The second time through, it might not have the highest value. In that case, it will skip step 6, but come back to step 7. In every case except the last one, it will skip step 2. In more complicated programs, the skipping around increases dramatically.
These "if"s are a class of instructions called ﬂow control instructions, because they tell the compute which steps to follow and which paths to take. In the previous program, we did not have any ﬂow control instructions, as there was only one possible path to take - exit. This program is much more dynamic in that it is directed by data. Depending on what data it receives, it will follow different instruction paths.
In this program, this will be accomplished by two different instructions, the conditional jump and the unconditional jump. The conditional jump changes paths based on the results of a previous comparison or calculation. The unconditional jump just goes directly to a different path no matter what. The unconditional jump may seem useless, but it is very necessary since all of the instructions will be laid
30

Chapter 3. Your First Programs
out on a line. If a path needs to converge back to the main path, it will have to do this by an unconditional jump. We will see more of both of these jumps in the next section.
Another use of ﬂow control is in implementing loops. A loop is a piece of program code that is meant to be repeated. In our example, the ﬁrst part of the program (setting the current position to 0 and loading the current highest value with the current value) was only done once, so it wasn’t a loop. However, the next part is repeated over and over again for every number in the list. It is only left when we have come to the last element, indicated by a zero. This is called a loop because it occurs over and over again. It is implemented by doing unconditional jumps to the beginning of the loop at the end of the loop, which causes it to start over. However, you have to always remember to have a conditional jump to exit the loop somewhere, or the loop will continue forever! This condition is called an inﬁnite loop. If we accidentally left out step 1, 2, or 3, the loop (and our program) would never end.
In the next section, we will implement this program that we have planned. Program planning sounds complicated - and it is, to some degree. When you ﬁrst start programming, it’s often hard to convert our normal thought process into a procedure that the computer can understand. We often forget the number of "temporary storage locations" that our minds are using to process problems. As you read and write programs, however, this will eventually become very natural to you. Just have patience.

Finding a Maximum Value
Enter the following program as maximum.s:

#PURPOSE: This program finds the maximum number of a

#

set of data items.

#

31

Chapter 3. Your First Programs

#VARIABLES: The registers have the following uses:

#

# %edi - Holds the index of the data item being examined

# %ebx - Largest data item found

# %eax - Current data item

#

# The following memory locations are used:

#

# data_items - contains the item data. A 0 is used

#

to terminate the data

#

.section .data

data_items:

#These are the data items

.long 3,67,34,222,45,75,54,34,44,33,22,11,66,0

.section .text

.globl _start

_start:

movl $0, %edi

# move 0 into the index register

movl data_items(,%edi,4), %eax # load the first byte of data

movl %eax, %ebx

# since this is the first item, %eax is

# the biggest

start_loop:

# start loop

cmpl $0, %eax

# check to see if we’ve hit the end

je loop_exit

incl %edi

# load next value

movl data_items(,%edi,4), %eax

cmpl %ebx, %eax

# compare values

jle start_loop

# jump to loop beginning if the new

# one isn’t bigger

movl %eax, %ebx

# move the value as the largest

32

jmp start_loop

Chapter 3. Your First Programs
# jump to loop beginning

loop_exit:

# %ebx is the status code for the exit system call

# and it already has the maximum number

movl $1, %eax

#1 is the exit() syscall

int $0x80

Now, assemble and link it with these commands:

as maximum.s -o maximum.o ld maximum.o -o maximum

Now run it, and check it’s status.

./maximum echo $?

You’ll notice it returns the value 222. Let’s take a look at the program and what it does. If you look in the comments, you’ll see that the program ﬁnds the maximum of a set of numbers (aren’t comments wonderful!). You may also notice that in this program we actually have something in the data section. These lines are the data section:

data_items:

#These are the data items

.long 3,67,34,222,45,75,54,34,44,33,22,11,66,0

Lets look at this. data_items is a label that refers to the location that follows it. Then, there is a directive that starts with .long. That causes the assembler to reserve memory for the list of numbers that follow it. data_items refers to the location of the ﬁrst one. Because data_items is a label, any time in our program where we need to refer to this address we can use the data_items symbol, and the assembler will substitute it with the address where the numbers start during assembly. For example, the instruction movl data_items, %eax would move

33

Chapter 3. Your First Programs the value 3 into %eax. There are several different types of memory locations other than .long that can be reserved. The main ones are as follows:
.byte
Bytes take up one storage location for each number. They are limited to numbers between 0 and 255.
.int
Ints (which differ from the int instruction) take up two storage locations for each number. These are limitted to numbers between 0 and 65535.9
.long
Longs take up four storage locations. This is the same amount of space the registers use, which is why they are used in this program. They can hold numbers between 0 and 4294967295.
.ascii
The .ascii directive is to enter in characters into memory. Characters each take up one storage location (they are converted into bytes internally). So, if you gave the directive .ascii "Hello there\0", the assembler would reserve 12 storage locations (bytes). The ﬁrst byte contains the numeric code for H, the second byte contains the numeric code for e, and so forth. The last character is represented by \0, and it is the terminating character (it will never display, it just tells other parts of the program that that’s the end of the characters). Letters and numbers that start with a backslash represent characters that are not typeable on the keyboard or easily viewable on the screen. For example, \n refers to the "newline" character which causes the
9. Note that no numbers in assembly language (or any other computer language I’ve seen) have commas embedded in them. So, always write numbers like 65535, and never like 65,535.
34

Chapter 3. Your First Programs
computer to start output on the next line and \t refers to the "tab" character. All of the letters in an .ascii directive should be in quotes.
In our example, the assembler reserves 14 .longs, one right after another. Since each long takes up 4 bytes, that means that the whole list takes up 56 bytes. These are the numbers we will be searching through to ﬁnd the maximum. data_items is used by the assembler to refer to the address of the ﬁrst of these values.
Take note that the last data item in the list is a zero. I decided to use a zero to tell my program that it has hit the end of the list. I could have done this other ways. I could have had the size of the list hard-coded into the program. Also, I could have put the length of the list as the ﬁrst item, or in a separate location. I also could have made a symbol which marked the last location of the list items. No matter how I do it, I must have some method of determining the end of the list. The computer knows nothing - it can only do what its told. It’s not going to stop processing unless I give it some sort of signal. Otherwise it would continue processing past the end of the list into the data that follows it, and even to locations where we haven’t put any data.
Notice that we don’t have a .globl declaration for data_items. This is because we only refer to these locations within the program. No other ﬁle or program needs to know where they are located. This is in contrast to the _start symbol, which Linux needs to know where it is so that it knows where to begin the program’s execution. It’s not an error to write .globl data_items, it’s just not necessary. Anyway, play around with this line and add your own numbers. Even though they are .long, the program will produce strange results if any number is greater than 255, because that’s the largest allowed exit status. Also notice that if you move the 0 to earlier in the list, the rest get ignored. Remember that any time you change the source ﬁle, you have to re-assemble and re-link your program. Do this now and see the results.
All right, we’ve played with the data a little bit. Now let’s look at the code. In the comments you will notice that we’ve marked some variables that we plan to use. A variable is a dedicated storage location used for a speciﬁc purpose, usually
35

Chapter 3. Your First Programs given a distinct name by the programmer. We talked about these in the previous section, but didn’t give them a name. In this program, we have several variables:
• a variable for the current maximum number found • a variable for which number of the list we are currently examining, called the
index • a variable holding the current number being examined In this case,we have few enough variables that we can hold them all in registers. In larger programs, you have to put them in memory, and then move them to registers when you are ready to use them. We will discuss how to do that later. When people start out programming, they usually underestimate the number of variables they will need. People are not used to having to think through every detail of a process, and therefore leave out needed variables in their ﬁrst programming attempts. In this program, we are using %ebx as the location of the largest item we’ve found. %edi is used as the index to the current data item we’re looking at. Now, let’s talk about what an index is. When we read the information from data_items, we will start with the ﬁrst one (data item number 0), then go to the second one (data item number 1), then the third (data item number 2), and so on. The data item number is the index of data_items. You’ll notice that the ﬁrst instruction we give to the computer is:
movl $0, %edi
Since we are using %edi as our index, and we want to start looking at the ﬁrst item, we load %edi with 0. Now, the next instruction is tricky, but crucial to what we’re doing. It says:
movl data_items(,%edi,4), %eax
Now to understand this line, you need to keep several things in mind:
36

Chapter 3. Your First Programs • data_items is the location number of the start of our number list. • Each number is stored across 4 storage locations (because we declared it using
.long) • %edi is holding 0 at this point So, basically what this line does is say, "start at the beginning of data_items, and take the ﬁrst item number (because %edi is 0), and remember that each number takes up four storage locations." Then it stores that number in %eax. This is how you write indexed addressing mode instructions in assembly language. The instruction in a general form is this:
movl BEGINNINGADDRESS(,%INDEXREGISTER,WORDSIZE)
In our case data_items was our beginning address, %edi was our index register, and 4 was our word size. This topic is discussed further in the Section called Addressing Modes. If you look at the numbers in data_items, you will see that the number 3 is now in %eax. If %edi was set to 1, the number 67 would be in %eax, and if it was set to 2, the number 34 would be in %eax, and so forth. Very strange things would happen if we used a number other than 4 as the size of our storage locations.10 The way you write this is very awkward, but if you know what each piece does, it’s not too difﬁcult. For more information about this, see the Section called Addressing Modes Let’s look at the next line:
movl %eax, %ebx 10. The instruction doesn’t really use 4 for the size of the storage locations, although looking at it that way works for our purposes now. It’s actually what’s called a multiplier. basically, the way it works is that you start at the location speciﬁed by data_items, then you add %edi*4 storage locations, and retrieve the number there. Usually, you use the size of the numbers as your multiplier, but in some circumstances you’ll want to do other things.
37

Chapter 3. Your First Programs We have the ﬁrst item to look at stored in %eax. Since it is the ﬁrst item, we know it’s the biggest one we’ve looked at. We store it in %ebx, since that’s where we are keeping the largest number found. Also, even though movl stands for move, it actually copies the value, so %eax and %ebx both contain the starting value.11 Now we move into a loop. A loop is a segment of your program that might run more than once. We have marked the starting location of the loop in the symbol start_loop. The reason we are doing a loop is because we don’t know how many data items we have to process, but the procedure will be the same no matter how many there are. We don’t want to have to rewrite our program for every list length possible. In fact, we don’t even want to have to write out code for a comparison for every list item. Therefore, we have a single section of code (a loop) that we execute over and over again for every element in data_items. In the previous section, we outlined what this loop needed to do. Let’s review:
• Check to see if the current value being looked at is zero. If so, that means we are at the end of our data and should exit the loop.
• We have to load the next value of our list. • We have to see if the next value is bigger than our current biggest value. • If it is, we have to copy it to the location we are holding the largest value in. • Now we need to go back to the beginning of the loop. Okay, so now lets go to the code. We have the beginning of the loop marked with start_loop. That is so we know where to go back to at the end of our loop. Then we have these instructions:
cmpl $0, %eax je end_loop 11. Also, the l in movl stands for move long since we are moving a value that takes up four storage locations.
38

Chapter 3. Your First Programs The cmpl instruction compares the two values. Here, we are comparing the number 0 to the number stored in %eax This compare instruction also affects a register not mentioned here, the %eflags register. This is also known as the status register, and has many uses which we will discuss later. Just be aware that the result of the comparison is stored in the status register. The next line is a ﬂow control instruction which says to jump to the end_loop location if the values that were just compared are equal (that’s what the e of je means). It uses the status register to hold the value of the last comparison. We used je, but there are many jump statements that you can use:
je
Jump if the values were equal
jg
Jump if the second value was greater than the ﬁrst value12
jge
Jump if the second value was greater than or equal to the ﬁrst value
jl
Jump if the second value was less than the ﬁrst value
jle
Jump if the second value was less than or equal to the ﬁrst value
jmp
Jump no matter what. This does not need to be preceeded by a comparison.
12. notice that the comparison is to see if the second value is greater than the ﬁrst. I would have thought it the other way around. You will ﬁnd a lot of things like this when learning programming. It occurs because different things make sense to different people. Anyway, you’ll just have to memorize such things and go on.
39

Chapter 3. Your First Programs The complete list is documented in Appendix B. In this case, we are jumping if %eax holds the value of zero. If so, we are done and we go to loop_exit.13 If the last loaded element was not zero, we go on to the next instructions:
incl %edi movl data_items(,%edi,4), %eax
If you remember from our previous discussion, %edi contains the index to our list of values in data_items. incl increments the value of %edi by one. Then the movl is just like the one we did beforehand. However, since we already incremented %edi, %eax is getting the next value from the list. Now %eax has the next value to be tested. So, let’s test it!
cmpl %ebx, %eax jle start_loop
Here we compare our current value, stored in %eax to our biggest value so far, stored in %ebx. If the current value is less or equal to our biggest value so far, we don’t care about it, so we just jump back to the beginning of the loop. Otherwise, we need to record that value as the largest one:
movl %eax, %ebx jmp start_loop
which moves the current value into %ebx, which we are using to store the current largest value, and starts the loop over again. Okay, so the loop executes until it reaches a 0, when it jumps to loop_exit. This part of the program calls the Linux kernel to exit. If you remember from the last
13. The names of these symbols can be anything you want them to be, as long as they only contain letters and the underscore character(_). The only one that is forced is _start, and possibly others that you declare with .globl. However, if its a symbol you deﬁne and only you use, feel free to call it anything you want that is adequately descriptive (remember that others will have to modify your code later, and will have to ﬁgure out what your symbols mean).
40

Chapter 3. Your First Programs program, when you call the operating system (remember it’s like signaling Batman), you store the system call number in %eax (1 for the exit call), and store the other values in the other registers. The exit call requires that we put our exit status in %ebx We already have the exit status there since we are using %ebx as our largest number, so all we have to do is load %eax with the number one and call the kernel to exit. Like this:
movl $1, %eax int 0x80
Okay, that was a lot of work and explanation, especially for such a small program. But hey, you’re learning a lot! Now, read through the whole program again, paying special attention to the comments. Make sure that you understand what is going on at each line. If you don’t understand a line, go back through this section and ﬁgure out what the line means. You might also grab a piece of paper, and go through the program step-by-step, recording every change to every register, so you can see more clearly what is going on.
Addressing Modes
In the Section called Data Accessing Methods in Chapter 2 we learned the different types of addressing modes available for use in assembly language. This section will deal with how those addressing modes are represented in assembly language instructions. The general form of memory address references is this:
ADDRESS_OR_OFFSET(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)
All of the ﬁelds are optional. To calculate the address, simply perform the following calculation:
41

Chapter 3. Your First Programs
FINAL ADDRESS = ADDRESS_OR_OFFSET + %BASE_OR_OFFSET + MULTIPLIER * %INDEX
ADDRESS_OR_OFFSET and MULTIPLIER must both be constants, while the other two must be registers. If any of the pieces is left out, it is just substituted with zero in the equation. All of the addressing modes mentioned in the Section called Data Accessing Methods in Chapter 2 except immediate-mode can be represented in this fashion.
direct addressing mode This is done by only using the ADDRESS_OR_OFFSET portion. Example:
movl ADDRESS, %eax
This loads %eax with the value at memory address ADDRESS.
indexed addressing mode This is done by using the ADDRESS_OR_OFFSET and the %INDEX portion. You can use any general-purpose register as the index register. You can also have a constant multiplier of 1, 2, or 4 for the index register, to make it easier to index by bytes, double-bytes, and words. For example, let’s say that we had a string of bytes as string_start and wanted to access the third one (an index of 2 since we start counting the index at zero), and %ecx held the value 2. If you wanted to load it into %eax you could do the following:
movl string_start(,%ecx,1), %eax
This starts at string_start, and adds 1 * %ecx to that address, and loads the value into %eax.
indirect addressing mode Indirect addressing mode loads a value from the address indicated by a register. For example, if %eax held an address, we could move the value at
42

Chapter 3. Your First Programs that address to %ebx by doing the following:
movl (%eax), %ebx
base pointer addressing mode Base-pointer addressing is similar to indirect addressing, except that it adds a constant value to the address in the register. For example, if you have a record where the age value is 4 bytes into the record, and you have the address of the record in %eax, you can retrieve the age into %ebx by issuing the following instruction:
movl 4(%eax), %ebx
immediate mode Immediate mode is very simple. It does not follow the general form we have been using. Immediate mode is used to load direct values into registers or memory locations. For example, if you wanted to load the number 12 into %eax, you would simply do the following:
movl $12, %eax
Notice that to indicate immediate mode, we used a dollar sign in front of the number. If we did not, it would be direct addressing mode, in which case the value located at memory location 12 would be loaded into %eax rather than the number 12 itself.
register addressing mode Register mode simply moves data in or out of a register. In all of our examples, register addressing mode was used for the other operand.
These addressing modes are very important, as every memory access will use one of these. Every mode except immediate mode can be used as either the source or destination operand. Immediate mode can only be a source operand.
43

Chapter 3. Your First Programs In addition to these modes, there are also different instructions for different sizes of values to move. For example, we have been using movl to move data a word at a time. in many cases, you will only want to move data a byte at a time. This is accomplished by the instruction movb. However, since the registers we have discussed are word-sized and not byte-sized, you cannot use the full register. Instead, you have to use a portion of the register. Take for instance %eax. If you only wanted to work with two bytes at a time, you could just use %ax. %ax is the least-signiﬁcant half (i.e. - the last part of the number) of the %eax register, and is useful when dealing with two-byte quantities. %ax is further divided up into %al and %ah. %al is the least-signiﬁcant byte of %ax, and %ah is the most signiﬁcant byte.14 Loading a value into %eax will wipe out whatever was in %al and %ah (and also %ax, since %ax is made up of them). Similarly, loading a value into either %al or %ah will corrupt any value that was formerly in %eax. Basically, it’s wise to only use a register for either a byte or a word, but never both at the same time.
14. When we talk about the most or least signiﬁcant byte, it may be a little confusing. Let’s take the number 5432. In that number, 54 is the most signiﬁcant half of that number and 32 is the least signiﬁcant half. You can’t quite divide it like that for registers, since they operate on base 2 rather than base 10 numbers, but that’s the basic idea. For more information on this topic, see Chapter 10.
44

Chapter 3. Your First Programs
Layout of the %eax register For a more comprehensive list of instructions, see Appendix B.
Review
Know the Concepts
• What does if mean if a line in the program starts with the ’#’ character? • What is the difference between an assembly language ﬁle and an object code
ﬁle? • What does the linker do? • How do you check the result status code of the last program you ran? • What is the difference between movl $1, %eax and movl 1, %eax?
45

Chapter 3. Your First Programs • Which register holds the system call number? • What are indexes used for? • Why do indexes usually start at 0? • If I issued the command movl data_items(,%edi,4), %eax and
data_items was address 3634 and %edi held the value 13, what address would you be using to move into %eax? • List the general-purpose registers. • What is the difference between movl and movb? • What is ﬂow control? • What does a conditional jump do? • What things do you have to plan for when writing a program? • Go through every instruction and list what addressing mode is being used for each operand.
Use the Concepts
• Modify the ﬁrst program to return the value 3. • Modify the maximum program to ﬁnd the minimum instead. • Modify the maximum program to use the number 255 to end the list rather than
the number 0 • Modify the maximum program to use an ending address rather than the number
0 to know when to stop. • Modify the maximum program to use a length count rather than the number 0 to
know when to stop.
46

Chapter 3. Your First Programs • What would the instruction movl _start, %eax do? Be speciﬁc, based on
your knowledge of both addressing modes and the meaning of _start. How would this differ from the instruction movl $_start, %eax?
Going Further
• Modify the ﬁrst program to leave off the int instruction line. Assemble, link, and execute the new program. What error message do you get. Why do you think this might be?
• So far, we have discussed three approaches to ﬁnding the end of the list - using a special number, using the ending address, and using the length count. Which approach do you think is best? Why? Which approach would you use if you knew that the list was sorted? Why?
47

Chapter 3. Your First Programs 48

Chapter 4. All About Functions
Dealing with Complexity
In Chapter 3, the programs we wrote only consisted of one section of code. However, if we wrote real programs like that, it would be impossible to maintain them. It would be really difﬁcult to get multiple people working on the project, as any change in one part might adversely affect another part that another developer is working on.
To assist programmers in working together in groups, it is necessary to break programs apart into separate pieces, which communicate with each other through well-deﬁned interfaces. This way, each piece can be developed and tested independently of the others, making it easier for multiple programmers to work on the project.
Programmers use functions to break their programs into pieces which can be independently developed and tested. Functions are units of code that do a deﬁned piece of work on speciﬁed types of data. For example, in a word processor program, I may have a function called handle_typed_character which is activated whenever a user types in a key. The data the function uses would probably be the keypress itself and the document the user currently has open. The function would then modify the document according to the keypress it was told about.
The data items a function is given to process are called it’s parameters. In the word processing example, the key which was pressed and the document would be considered parameters to the handle_typed_characters function. The parameter list and the processing expectations of a function (what it is expected to do with the parameters) are called the function’s interface. Much care goes into designing function interfaces, because if they are called from many places within a project, it is difﬁcult to change them if necessary.
A typical program is composed of hundreds or thousands of functions, each with a
49

Chapter 4. All About Functions small, well-deﬁned task to perform. However, ultimately there are things that you cannot write functions for which must be provided by the system. Those are called primitive functions (or just primitives) - they are the basics which everything else is built off of. For example, imagine a program that draws a graphical user interface. There has to be a function to create the menus. That function probably calls other functions to write text, to write icons, to paint the background, calculate where the mouse pointer is, etc. However, ultimately, they will reach a set of primitives provided by the operating system to do basic line or point drawing. Programming can either be viewed as breaking a large program down into smaller pieces until you get to the primitive functions, or incrementally building functions on top of primitives until you get the large picture in focus. In assembly language, the primitives are usually the same thing as the system calls, even though system calls aren’t true functions as we will talk about in this chapter.
How Functions Work
Functions are composed of several different pieces:
function name A function’s name is a symbol that represents the address where the function’s code starts. In assembly language, the symbol is deﬁned by typing the the function’s name as a label before the function’s code. This is just like labels you have used for jumping.
function parameters A function’s parameters are the data items that are explicitly given to the function for processing. For example, in mathematics, there is a sine function. If you were to ask a computer to ﬁnd the sine of 2, sine would be the function’s name, and 2 would be the parameter. Some functions have
50

many parameters, others have none.1

Chapter 4. All About Functions

local variables
Local variables are data storage that a function uses while processing that is thrown away when it returns. It’s kind of like a scratch pad of paper. Functions get a new piece of paper every time they are activated, and they have to throw it away when they are ﬁnished processing. Local variables of a function are not accessible to any other function within a program.

static variables
Static variables are data storage that a function uses while processing that is not thrown away afterwards, but is reused for every time the function’s code is activated. This data is not accessible to any other part of the program. Static variables are generally not used unless absolutely necessary, as they can cause problems later on.

global variables
Global variables are data storage that a function uses for processing which are managed outside the function. For example, a simple text editor may put the entire contents of the ﬁle it is working on in a global variable so it doesn’t have to be passed to every function that operates on it.2 Conﬁguration values are also often stored in global variables.

return address
The return address is an "invisible" parameter in that it isn’t directly used during the function. The return address is a parameter which tells the function
1. Function parameters can also be used to hold pointers to data that the function wants to send back to the program. 2. This is generally considered bad practice. Imagine if a program is written this way, and in the next version they decided to allow a single instance of the program edit multiple ﬁles. Each function would then have to be modiﬁed so that the ﬁle that was being manipulated would be passed as a parameter. If you had simply passed it as a parameter to begin with, most of your functions could have survived your upgrade unchanged.

51

Chapter 4. All About Functions where to resume executing after the function is completed. This is needed because functions can be called to do processing from many different parts of your program, and the function needs to be able to get back to wherever it was called from. In most programming languages, this parameter is passed automatically when the function is called. In assembly language, the call instruction handles passing the return address for you, and ret handles using that address to return back to where you called the function from.
return value The return value is the main method of transferring data back to the main program. Most programming languages only allow a single return value for a function.
These pieces are present in most programming languages. How you specify each piece is different in each one, however. The way that the variables are stored and the parameters and return values are transferred by the computer varies from language to language as well. This variance is known as a language’s calling convention, because it describes how functions expect to get and receive data when they are called.3 Assembly language can use any calling convention it wants to. You can even make one up yourself. However, if you want to interoperate with functions written in other languages, you have to obey their calling conventions. We will use the calling convention of the C programming language for our examples because it is the most widely used, and because it is the standard for Linux platforms.
3. A convention is a way of doing things that is standardized, but not forcibly so. For example, it is a convention for people to shake hands when they meet. If I refuse to shake hands with you, you may think I don’t like you. Following conventions is important because it makes it easier for others to understand what you are doing, and makes it easier for programs written by multiple independent authors to work together.
52

Chapter 4. All About Functions
Assembly-Language Functions using the C Calling Convention
You cannot write assembly-language functions without understanding how the computer’s stack works. Each computer program that runs uses a region of memory called the stack to enable functions to work properly. Think of a stack as a pile of papers on your desk which can be added to indeﬁnitely. You generally keep the things that you are working on toward the top, and you take things off as you are ﬁnished working with them.
Your computer has a stack, too. The computer’s stack lives at the very top addresses of memory. You can push values onto the top of the stack through an instruction called pushl, which pushes either a register or memory value onto the top of the stack. Well, we say it’s the top, but the "top" of the stack is actually the bottom of the stack’s memory. Although this is confusing, the reason for it is that when we think of a stack of anything - dishes, papers, etc. - we think of adding and removing to the top of it. However, in memory the stack starts at the top of memory and grows downward due to architectural considerations. Therefore, when we refer to the "top of the stack" remember it’s at the bottom of the stack’s memory. You can also pop values off the top using an instruction called popl. This removes the top value from the stack and places it into a register or memory location of your choosing..
When we push a value onto the stack, the top of the stack moves to accomodate the additional value. We can actually continually push values onto the stack and it will keep growing further and further down in memory until we hit our code or data. So how do we know where the current "top" of the stack is? The stack register, %esp, always contains a pointer to the current top of the stack, wherever it is.
Every time we push something onto the stack with pushl, %esp gets subtracted by 4 so that it points to the new top of the stack (remember, each word is four bytes long, and the stack grows downward). If we want to remove something from the stack, we simply use the popl instruction, which adds 4 to %esp and puts the previous top value in whatever register you speciﬁed. pushl and popl each take
53

Chapter 4. All About Functions one operand - the register to push onto the stack for pushl, or receive the data that is popped off the stack for popl. If we simply want to access the value on the top of the stack without removing it, we can simply use the %esp register in indirect addressing mode. For example, the following code moves whatever is at the top of the stack into %eax:
movl (%esp), %eax
If we were to just do this:
movl %esp, %eax
then %eax would just hold the pointer to the top of the stack rather than the value at the top. Putting %esp in parenthesis causes the computer to go to indirect addressing mode, and therefore we get the value pointed to by %esp. If we want to access the value right below the top of the stack, we can simply issue this instruction:
movl 4(%esp), %eax
This instruction uses the base pointer addressing mode (see the Section called Data Accessing Methods in Chapter 2) which simply adds 4 to %esp before looking up the value being pointed to. In the C language calling convention, the stack is the key element for implementing a function’s local variables, parameters, and return address. Before executing a function, a program pushes all of the parameters for the function onto the stack in the reverse order that they are documented. Then the program issues a call instruction indicating which function it wishes to start. The call instruction does two things. First it pushes the address of the next instruction, which is the return address, onto the stack. Then it modiﬁes the instruction pointer (%eip) to point to the start of the function. So, at the time the function starts, the stack looks like this (the "top" of the stack is at the bottom on
54

this example):

Chapter 4. All About Functions

Parameter #N ... Parameter 2 Parameter 1 Return Address <--- (%esp)

Each of the parameters of the function have been pushed onto the stack, and ﬁnally the return address is there. Now the function itself has some work to do.
The ﬁrst thing it does is save the current base pointer register, %ebp, by doing pushl %ebp. The base pointer is a special register used for accessing function parameters and local variables. Next, it copies the stack pointer to %ebp by doing movl %esp, %ebp. This allows you to be able to access the function parameters as ﬁxed indexes from the base pointer. You may think that you can use the stack pointer for this. However, during your program you may do other things with the stack such as pushing arguments to other functions.
Copying the stack pointer into the base pointer at the beginning of a function allows you to always know where your parameters are (and as we will see, local variables too), even while you may be pushing things on and off the stack. %ebp will always be where the stack pointer was at the beginning of the function, so it is more or less a constant reference to the stack frame (the stack frame consists of all of the stack variables used within a function, including parameters, local variables, and the return address).
At this point, the stack looks like this:

Parameter #N <--- N*4+4(%ebp)

...

Parameter 2 <--- 12(%ebp)

Parameter 1 <--- 8(%ebp)

Return Address <--- 4(%ebp)

Old %ebp

<--- (%esp) and (%ebp)

55

Chapter 4. All About Functions
As you can see, each parameter can be accessed using base pointer addressing mode using the %ebp register.
Next, the function reserves space on the stack for any local variables it needs. This is done by simply moving the stack pointer out of the way. Let’s say that we are going to need two words of memory to run a function. We can simply move the stack pointer down two words to reserve the space. This is done like this:

subl $8, %esp

This subtracts 8 from %esp (remember, a word is four bytes long).4 This way, we can use the stack for variable storage without worring about clobbering them with pushes that we may make for function calls. Also, since it is allocated on the stack frame for this function call, the variable will only be alive during this function. When we return, the stack frame will go away, and so will these variables. That’s why they are called local - they only exist while this function is being called.
Now we have two words for local storage. Our stack now looks like this:

Parameter #N

<--- N*4+4(%ebp)

...

Parameter 2

<--- 12(%ebp)

Parameter 1

<--- 8(%ebp)

Return Address <--- 4(%ebp)

Old %ebp

<--- (%ebp)

Local Variable 1 <--- -4(%ebp)

Local Variable 2 <--- -8(%ebp) and (%esp)

So we can now access all of the data we need for this function by using base pointer addressing using different offsets from %ebp. %ebp was made speciﬁcally for this purpose, which is why it is called the base pointer. You can use other registers in base pointer addressing mode, but the x86 architecture makes using the %ebp register a lot faster.
4. Just a reminder - the dollar sign in front of the eight indicates immediate mode addressing, meaning that we load the number 8 into %esp rather than the value at address 8.

56

Chapter 4. All About Functions Global variables and static variables are accessed just like we have been accessing memory in previous chapters. The only difference between the global and static variables is that static variables are only used by one function, while global variables are used by many functions. Assembly language treats them exactly the same, although most other languages distinguish them. When a function is done executing, it does three things:
1. It stores it’s return value in %eax. 2. It resets the stack to what it was when it was called (it gets rid of the current
stack frame and puts the stack frame of the calling code back into effect). 3. It returns control back to wherever it was called from. This is done using the
ret instruction, which pops whatever value is at the top of the stack, and sets the instruction pointer, %eip, to that value. So, before a function returns control to the code that called it, it must restore the previous stack frame. Note also that without doing this, ret wouldn’t work, because in our current stack frame, the return address is not at the top of the stack. Therefore, before we return, we have to reset the stack pointer %esp and base pointer %ebp to what they were when the function began. Therefore to return from the function you have to do the following:
movl %ebp, %esp popl %ebp ret
At this point, you should consider all local variables to be disposed of. The reason is that after you move the stack pointer back, future stack pushes will likely overwrite everything you put there. Therefore, you should never save the address of a local variable past the life of the function it was created in, or else it will be overwritten after the life of it’s stack frame ends.
57

Chapter 4. All About Functions
Control has now beenhanded back to the calling code, which can now examine %eax for the return value. The calling code also needs to pop off all of the parameters it pushed onto the stack in order to get the stack pointer back where it was (you can also simply add 4 * number of paramters to %esp using the addl instruction, if you don’t need the values of the parameters anymore).5
Destruction of Registers
When you call a function, you should assume that everything currently in your registers will be wiped out. The only register that is guaranteed to be left with the value it started with is %ebp. %eax is guaranteed to be overwritten, and the others likely are. If there are registers you want to save before calling a function, you need to save them by pushing them on the stack before pushing the function’s paramters. You can then pop them back off in reverse order after popping off the parameters. Even if you know a function does not overwrite a register you should save it, because future versions of that function may.
Other languages’ calling conventions may be different. For example, other calling conventions may place the burden on the function to save any registers it uses. Be sure to check to make sure the calling conventions of your languages are compatible before trying to mix languages. Or in the case of assembly language, be sure you know how to call the other language’s functions. them.
Extended Speciﬁcation: Details of the C language calling convention (also known as the ABI, or Application Binary Interface) is available online. We have oversimpliﬁed and left out several important pieces to make this simpler for new programmers. For full details, you should check out the documents available at http://www.linuxbase.org/spec/refspecs/ Speciﬁcally, you should
5. This is not always strictly needed unless you are saving registers on the stack before a function call. The base pointer keeps the stack frame in a reasonably consistent state. However, it is still a good idea, and is absolutely necessary if you are temporarily saving registers on the stack..
58

Chapter 4. All About Functions
look for the System V Application Binary Interface - Intel386 Architecture Processor Supplement.

A Function Example
Let’s take a look at how a function call works in a real program. The function we are going to write is the power function. We will give the power function two parameters - the number and the power we want to raise it to. For example, if we gave it the paramters 2 and 3, it would raise 2 to the power of 3, or 2*2*2, giving 8. In order to make this program simple, we will only allow numbers 1 and greater.
The following is the code for the complete program. As usual, an explanation follows. Name the ﬁle power.s.

#PURPOSE: # # #

Program to illustrate how functions work This program will compute the value of 2^3 + 5^2

#Everything in the main program is stored in registers, #so the data section doesn’t have anything. .section .data

.section .text

.globl _start _start:
pushl $3 pushl $2 call power addl $8, %esp

#push second argument #push first argument #call the function #move the stack pointer back

59

Chapter 4. All About Functions
pushl %eax

#save the first answer before #calling the next function

pushl $2 pushl $5 call power addl $8, %esp

#push second argument #push first argument #call the function #move the stack pointer back

popl %ebx

#The second answer is already #in %eax. We saved the #first answer onto the stack, #so now we can just pop it #out into %ebx

addl %eax, %ebx

#add them together #the result is in %ebx

movl $1, %eax int $0x80

#exit (%ebx is returned)

#PURPOSE: This function is used to compute

#

the value of a number raised to

#

a power.

#

#INPUT: First argument - the base number

#

Second argument - the power to

#

raise it to

#

#OUTPUT: Will give the result as a return value

#

#NOTES: The power must be 1 or greater

#

#VARIABLES:

#

%ebx - holds the base number

#

%ecx - holds the power

60

Chapter 4. All About Functions

#

#

-4(%ebp) - holds the current result

#

#

%eax is used for temporary storage

#

.type power, @function

power:

pushl %ebp

#save old base pointer

movl %esp, %ebp

#make stack pointer the base pointer

subl $4, %esp

#get room for our local storage

movl 8(%ebp), %ebx #put first argument in %eax movl 12(%ebp), %ecx #put second argument in %ecx

movl %ebx, -4(%ebp) #store current result

power_loop_start:

cmpl $1, %ecx

#if the power is 1, we are done

je end_power

movl -4(%ebp), %eax #move the current result into %eax

imull %ebx, %eax

#multiply the current result by

#the base number

movl %eax, -4(%ebp) #store the current result

decl %ecx

#decrease the power

jmp power_loop_start #run for the next power

end_power: movl -4(%ebp), %eax movl %ebp, %esp popl %ebp ret

#return value goes in %eax #restore the stack pointer #restore the base pointer

61

Chapter 4. All About Functions Type in the program, assemble it, and run it. Try calling power for different values, but remember that the result has to be less than 256 when it is passed back to the operating system. Also try subtracting the results of the two computations. Try adding a third call to the power function, and add it’s result back in. The main program code is pretty simple. You push the arguments onto the stack, call the function, and then move the stack pointer back. The result is stored in %eax. Note that between the two calls to power, we save the ﬁrst value onto the stack. This is because the only register that is guaranteed to be saved is %ebp. Therefore we push the value onto the stack, and pop the value back off after the second function call is complete. Let’s look at how the function itself is written. Notice that before the function, there is documentation as to what the function does, what it’s arguments are, and what it gives as a return value. This is useful for programmers who use this function. This is the function’s interface. This lets the programmer know what values are needed on the stack, and what will be in %eax at the end. We then have the following line:
.type power,@function
This tells the linker that the symbol power should be treated as a function. Since this program is only in one ﬁle, it would work just the same with this left out. However, it is good practice. After that, we deﬁne the value of the power label:
power:
As mentioned previously, this deﬁnes the symbol power to be the address where the instructions following the label begin. This is how call power works. It transfers control to this spot of the program. The difference between call and jmp is that call also pushes the return address onto the stack so that the function can return, while the jmp does not.
62

Chapter 4. All About Functions Next, we have our instructions to set up our function:

pushl %ebp movl %esp, %ebp subl $4, %esp

At this point, our stack looks like this:

Base Number <--- 12(%ebp)

Power

<--- 8(%ebp)

Return Address <--- 4(%ebp)

Old %ebp

<--- (%ebp)

Current result <--- -4(%ebp) and (%esp)

Although we could use a register for temporary storage, this program uses a local variable in order to show how to set it up. Often times there just aren’t enough registers to store everything, so you have to ofﬂoad them into local variables. Other times, your function will need to call another function and send it a pointer to some of your data. You can’t have a pointer to a register, so you have to store it in a local variable in order to send a pointer to it.
Basically, what the program does is start with the base number, and store it both as the multiplier (stored in %ebx) and the current value (stored in -4(%ebp)). It also has the power stored in %ecx It then continually multiplies the current value by the multiplier, decreases the power, and leaves the loop if the power (in %ecx) gets down to 1.
By now, you should be able to go through the program without help. The only things you should need to know is that imull does integer multiplication and stores the result in the second operand, and decl decreases the given register by 1. For more information on these and other instructions, see Appendix B
A good project to try now is to extend the program so it will return the value of a number if the power is 0 (hint, anything raised to the zero power is 1). Keep trying. If it doesn’t work at ﬁrst, try going through your program by hand with a

63

Chapter 4. All About Functions scrap of paper, keeping track of where %ebp and %esp are pointing, what is on the stack, and what the values are in each register.
Recursive Functions
The next program will stretch your brains even more. The program will compute the factorial of a number. A factorial is the product of a number and all the numbers between it and one. For example, the factorial of 7 is 7*6*5*4*3*2*1, and the factorial of 4 is 4*3*2*1. Now, one thing you might notice is that the factorial of a number is the same as the product of a number and the factorial just below it. For example, the factorial of 4 is 4 times the factorial of 3. The factorial of 3 is 3 times the factorial of 2. 2 is 2 times the factorial of 1. The factorial of 1 is 1. This type of deﬁnition is called a recursive deﬁnition. That means, the deﬁnition of the factorial function includes the factorial funtion itself. However, since all functions need to end, a recursive deﬁnition must include a base case. The base case is the point where recursion will stop. Without a base case, the function would go on forever calling itself until it eventually ran out of stack space. In the case of the factorial, the base case is the number 1. When we hit the number 1, we don’t run the factorial again, we just say that the factorial of 1 is 1. So, let’s run through what we want the code to look like for our factorial function:
1. Examine the number 2. Is the number 1? 3. If so, the answer is one 4. Otherwise, the answer is the number times the factorial of the number minus
one This would be problematic if we didn’t have local variables. In other programs, storing values in global variables worked ﬁne. However, global variables only provide one copy of each variable. In this program, we will have multiple copies
64

Chapter 4. All About Functions
of the function running at the same time, all of them needing their own copies of the data!6 Since local variables exist on the stack frame, and each function call gets its own stack frame, we are okay.
Let’s look at the code to see how this works:

#PURPOSE - Given a number, this program computes the

#

factorial. For example, the factorial of

#

3 is 3 * 2 * 1, or 6. The factorial of

#

4 is 4 * 3 * 2 * 1, or 24, and so on.

#

#This program shows how to call a function recursively.

.section .data

#This program has no global data

.section .text

.globl _start

.globl factorial #this is unneeded unless we want to share

#this function among other programs

_start:

pushl $4

#The factorial takes one argument - the

#number we want a factorial of. So, it

#gets pushed

call factorial #run the factorial function

addl $4, %esp #Scrubs the parameter that was pushed on

#the stack

movl %eax, %ebx #factorial returns the answer in %eax, but

#we want it in %ebx to send it as our exit

#status

6. By "running at the same time" I am talking about the fact that one will not have ﬁnished before a new one is activated. I am not implying that their instructions are running at the same time.

65

Chapter 4. All About Functions
movl $1, %eax #call the kernel’s exit function int $0x80

#This is the actual function definition

.type factorial,@function

factorial:

pushl %ebp

#standard function stuff - we have to

#restore %ebp to its prior state before

#returning, so we have to push it

movl %esp, %ebp #This is because we don’t want to modify

#the stack pointer, so we use %ebp.

movl 8(%ebp), %eax #This moves the first argument to %eax

#4(%ebp) holds the return address, and

#8(%ebp) holds the first parameter

cmpl $1, %eax

#If the number is 1, that is our base

#case, and we simply return (1 is

#already in %eax as the return value)

je end_factorial

decl %eax

#otherwise, decrease the value

pushl %eax

#push it for our call to factorial

call factorial

#call factorial

movl 8(%ebp), %ebx #%eax has the return value, so we

#reload our parameter into %ebx

imull %ebx, %eax #multiply that by the result of the

#last call to factorial (in %eax)

#the answer is stored in %eax, which

#is good since that’s where return

#values go.

end_factorial:

movl %ebp, %esp #standard function return stuff - we

popl %ebp

#have to restore %ebp and %esp to where

#they were before the function started

ret

#return to the function (this pops the

66

Chapter 4. All About Functions
#return value, too)
Assemble, link, and run it with these commands:
as factorial.s -o factorial.o ld factorial.o -o factorial ./factorial echo $?
This should give you the value 24. 24 is the factorial of 4, you can test it out yourself with a calculator: 4 * 3 * 2 * 1 = 24. I’m guessing you didn’t understand the whole code listing. Let’s go through it a line at a time to see what is happening.
_start: pushl $4 call factorial
Okay, this program is intended to compute the factorial of the number 4. When programming functions, you are supposed to put the parameters of the function on the top of the stack right before you call it. Remember, a function’s parameters are the data that you want the function to work with. In this case, the factorial function takes 1 parameter - the number you want the factorial of. The pushl instruction puts the given value at the top of the stack. The call instruction then makes the function call. Next we have these lines:
addl $4, %esp movl %eax, %ebx movl $1, %eax
67

Chapter 4. All About Functions
int $0x80
This takes place after factorial has ﬁnished and computed the factorial of 4 for us. Now we have to clean up the stack. The addl instruction moves the stack pointer back to where it was before we pushed the $4 onto the stack. You should always clean up your stack parameters after a function call returns. The next instruction moves %eax to %ebx. What’s in %eax? It is factorial’s return value. In our case, it is the value of the factorial function. With 4 as our parameter, 24 should be our return value. Remember, return values are always stored in %eax. We want to return this value as the status code to the operating system. However, Linux requires that the program’s exit status be stored in %ebx, not %eax, so we have to move it. Then we do the standard exit system call. The nice thing about function calls is that:
• Other programmers don’t have to know anything about them except it’s arguments to use them.
• They provide standardized building blocks from which you can form a program. • They can be called multiple times and from multiple locations and they always
know how to get back to where they were since call pushes the return address onto the stack. These are the main advantages of functions. Larger programs also use functions to break down complex pieces of code into smaller, simpler ones. In fact, almost all of programming is writing and calling functions. Let’s now take a look at how the factorial function itself is implemented. Before the function starts, we have this directive:
.type factorial,@function factorial:
68

Chapter 4. All About Functions The .type directive tells the linker that factorial is a function. This isn’t really needed unless we were using factorial in other programs. We have included it for completeness. The line that says factorial: gives the symbol factorial the storage location of the next instruction. That’s how call knew where to go when we said call factorial. The ﬁrst real instructions of the function are:
pushl %ebp movl %esp, %ebp
As shown in the previous program, this creates the stack frame for this function. These two lines will be the way you should start every function. The next instruction is this:
movl 8(%ebp), %eax
This uses base pointer addressing to move the ﬁrst parameter of the function into %eax. Remember, (%ebp) has the old %ebp, 4(%ebp) has the return address, and 8(%ebp) is the location of the ﬁrst parameter to the function. If you think back, this will be the value 4 on the ﬁrst call, since that was what we pushed on the stack before calling the function (with pushl $4). parameter into %eax. As this function calls itself, it will have other values, too. Next, we check to see if we’ve hit our base case (a parameter of 1). If so, we jump to the instruction at the label end_factorial, where it will be returned. Et’s already in %eax which we mentioned earlier is where you put return values. That is accomplished by these lines:
cmpl $1, %eax je end_factorial
If it’s not our base case, what did we say we would do? We would call the factorial function again with our parameter minus one. So, ﬁrst we decrease %eax by one:
69

Chapter 4. All About Functions
decl %eax
decl stands for decrement. It subtracts 1 from the given register or memory location (%eax in our case). incl is the inverse - it adds 1. After decrementing %eax we push it onto the stack since it’s going to be the parameter of the next function call. And then we call factorial again!
pushl %eax call factorial
Okay, now we’ve called factorial. One thing to remember is that after a function call, we can never know what the registers are (except %esp and %ebp). So even though we had the value we were called with in %eax, it’s not there any more. Therefore, we need pull it off the stack from the same place we got it the ﬁrst time (at 8(%ebp)). So, we do this:
movl 8(%ebp), %ebx
Now, we want to multiply that number with the result of the factorial function. If you remember our previous discussion, the result of functions are left in %eax. So, we need to multiply %ebx with %eax. This is done with this instruction:
imull %ebx, %eax
This also stores the result in %eax, which is exactly where we want the return value for the function to be! Since the return value is in place we just need to leave the function. If you remember, at the start of the function we pushed %ebp, and moved %esp into %ebp to create the current stack frame. Now we reverse the operation to destroy the current stack frame and reactivate the last one:
end_factorial: movl %ebp, %esp popl %ebp
Now we’re already to return, so we issue the following command
70

Chapter 4. All About Functions
ret
This pops the top value off of the stack, and then jumps to it. If you remember our discussion about call, we said that call ﬁrst pushed the address of the next instruction onto the stack before it jumped to the beginning of the function. So, here we pop it back off so we can return there. The function is done, and we have our answer! Like our previous program, you should look over the program again, and make sure you know what everything does. Look back through this section and the previous sections for the explanation of anything you don’t understand. Then, take a piece of paper, and go through the program step-by-step, keeping track of what the values of the registers are at each step, and what values are on the stack. Doing this should deepen your understanding of what is going on.
Review
Know the Concepts
• What are primitives? • What are calling conventions? • What is the stack? • How do pushl and popl affect the stack? What special-purpose register do
they affect? • What are local variables and what are they used for? • Why are local variables so necessary in recursive functions? • What are %ebp and %esp used for? • What is a stack frame?
71

Chapter 4. All About Functions
Use the Concepts
• Write a function called square which receives one argument and returns the square of that argument.
• Write a program to test your square function. • Convert the maximum program given in the Section called Finding a Maximum
Value in Chapter 3 so that it is a function which takes a pointer to several values and returns their maximum. Write a program that calls maximum with 3 different lists, and returns the result of the last one as the program’s exit status code. • Explain the problems that would arise without a standard calling convention.
Going Further
• Do you think it’s better for a system to have a large set of primitives or a small one, assuming that the larger set can be written in terms of the smaller one?
• The factorial function can be written non-recursively. Do so. • Find an application on the computer you use regularly. Try to locate a speciﬁc
feature, and practice breaking that feature out into functions. Deﬁne the function interfaces between that feature and the rest of the program. • Come up with your own calling convention. Rewrite the programs in this chapter using it. An example of a different calling convention would be to pass paramters in registers rather than the stack, to pass them in a different order, to return values in other registers or memory locations. Whatever you pick, be consistent and apply it throughout the whole program. • Can you build a calling convention without using the stack? What limitations might it have?
72

Chapter 4. All About Functions • What test cases should we use in our example program to check to see if it is
working properly?
73

Chapter 4. All About Functions 74

Chapter 5. Dealing with Files
A lot of computer programming deals with ﬁles. After all, when we reboot our computers, the only thing that remains from previous sessions are the things that have been put on disk. Data which is stored in ﬁles is called persistent data, because it persists in ﬁles that remain on the disk even when the program isn’t running..
The UNIX File Concept
Each operating system has it’s own way of dealing with ﬁles. However, the UNIX method, which is used on Linux, is the simplest and most universal. UNIX ﬁles, no matter what program created them, can all be accessed as a sequential stream of bytes. When you access a ﬁle, you start by opening it by name. The operating system then gives you a number, called a ﬁle descriptor, which you use to refer to the ﬁle until you are through with it. You can then read and write to the ﬁle using its ﬁle descriptor. When you are done reading and writing, you then close the ﬁle, which then makes the ﬁle descriptor useless. In our programs we will deal with ﬁles in the following ways:
1. Tell Linux the name of the ﬁle to open, and in what mode you want it opened (read, write, both read and write, create it if it doesn’t exist, etc.). This is handled with the open system call, which takes a ﬁlename, a number representing the mode, and a permission set as its parameters. %eax will hold the system call number, which is 5. The address of the ﬁrst character of the ﬁlename should be stored in %ebx. The read/write intentions, represented as a number, should be stored in %ecx. For now, use 0 for ﬁles you want to read from, and 03101 for ﬁles you want to write to (you must include the leading zero).1 Finally, the permission set should be stored as a number in %edx. If
1. This will be explained in more detail in the Section called Truth, Falsehood, and Binary Numbers in Chapter 10.
75

Chapter 5. Dealing with Files
you are unfamiliar with UNIX permissions, just use 0666 for the permissions (again, you must include the leading zero).
2. Linux will then return to you a ﬁle descriptor in %eax. Remember, this is a number that you use to refer to this ﬁle throughout your program.
3. Next you will operate on the ﬁle doing reads and/or writes, each time giving Linux the ﬁle descriptor you want to use. read is system call 3, and to call it you need to have the ﬁle descriptor in %ebx, the address of a buffer for storing the data that is read in %ecx, and the size of the buffer in %edx. Buffers will be explained in the Section called Buffers and .bss. read will return with either the number of characters read from the ﬁle, or an error code. Error codes can be distinguished because they are always negative numbers (more information on negative numbers can be found in Chapter 10). write is system call 4, and it requires the same parameters as the read system call, except that the buffer should already be ﬁlled with the data to write out. The write system call will give back the number of bytes written in %eax or an error code.
4. When you are through with your ﬁles, you can then tell Linux to close them. Afterwards, your ﬁle descriptor is no longer valid. This is done using close, system call 6. The only parameter to close is the ﬁle descriptor, which is placed in %ebx
Buffers and .bss
In the previous section we mentioned buffers without explaining what they were. A buffer is a continuous block of bytes used for bulk data transfer. When you request to read a ﬁle, the operating system needs to have a place to store the data it reads. That place is called a buffer. Usually buffers are only used to store data temporarily, and it is then read from the buffers and converted to a form that is easier for the programs to handle. Our programs won’t be complicated enough to need that done. For an example, let’s say that you want to read in a single line of text from a ﬁle but you do not know how long that line is. You would then simply
76

Chapter 5. Dealing with Files
read a large number of bytes/characters from the ﬁle into a buffer, look for the end-of-line character, and copy all of the characters to that end-of-line character to another location. If you didn’t ﬁnd and end-of-line character, you would allocate another buffer and continue reading. You would probably wind up with some characters left over in your buffer in this case, which you would use as the starting point when you next need data from the ﬁle.2
Another thing to note is that buffers are a ﬁxed size, set by the programmer. So, if you want to read in data 500 bytes at a time, you send the read system call the address of a 500-byte unused location, and send it the number 500 so it knows how big it is. You can make it smaller or bigger, depending on your application’s needs.
To create a buffer, you need to either reserve static or dynamic storage. Static storage is what we have talked about so far, storage locations declared using .long or .byte directives. Dynamic storage will be discussed in the Section called Getting More Memory in Chapter 9. There are problems, though, with declaring buffers using .byte. First, it is tedious to type. You would have to type 500 numbers after the .byte declaration, and they wouldn’t be used for anything but to take up space. Second, it uses up space in the executable. In the examples we’ve used so far, it doesn’t use up too much, but that can change in larger programs. If you want 500 bytes you have to type in 500 numbers and it wastes 500 bytes in the executable. There is a solution to both of these. So far, we have discussed two program sections, the .text and the .data sections. There is another section called the .bss. This section is like the data section, except that it doesn’t take up space in the executable. This section can reserve storage, but it can’t initialize it. In the .data section, you could reserve storage and set it to an initial value. In the .bss section, you can’t set an initial value. This is useful for buffers because we don’t need to initialize them anyway, we just need to reserve storage. In order to do this, we do the following commands:
.section .bss
2. While this sounds complicated, most of the time in programming you will not need to deal directly with buffers and ﬁle descriptors. In Chapter 8 you will learn how to use existing code present in Linux to handle most of the complications of ﬁle input/output for you.
77

Chapter 5. Dealing with Files
.lcomm my_buffer, 500
This directive, .lcomm, will create a symbol, my_buffer, that refers to a 500-byte storage location that we can use as a buffer. We can then do the following, assuming we have opened a ﬁle for reading and have placed the ﬁle descriptor in %ebx:
movl $my_buffer, %ecx movl 500, %edx movl 3, %eax int $0x80
This will read up to 500 bytes into our buffer. In this example, I placed a dollar sign in front of my_buffer. Remember that the reason for this is that without the dollar sign, my_buffer is treated as a memory location, and is accessed in direct addressing mode. The dollar sign switches it to immediate mode addressing, which actually loads the number represented by my_buffer (i.e. - the address of the start of our buffer). (which is the address of my_buffer) itself into %ecx.
Standard and Special Files
You might think that programs start without any ﬁles open by default. This is not true. Linux programs usually have at least three open ﬁle descriptors when they begin. They are:
STDIN This is the standard input. It is a read-only ﬁle, and usually represents your keyboard.3 This is always ﬁle descriptor 0.
3. As we mentioned earlier, in Linux, almost everything is a "ﬁle". Your keyboard input is considered a ﬁle, and so is your screen display.
78

Chapter 5. Dealing with Files STDOUT
This is the standard output. It is a write-only ﬁle, and usually represents your screen display. This is always ﬁle descriptor 1.
STDERR This is your standard error. It is a write-only ﬁle, and usually represents your screen display. Most regular processing output goes to STDOUT, but any error messages that come up in the process go to STDERR. This way, if you want to, you can split them up into separate places. This is always ﬁle descriptor 2.
Any of these "ﬁles" can be redirected from or to a real ﬁle, rather than a screen or a keyboard. This is outside the scope of this book, but any good book on the UNIX command-line will describe it in detail. The program itself does not even need to be aware of this indirection - it can just use the standard ﬁle descriptors as usual. Notice that many of the ﬁles you write to aren’t ﬁles at all. UNIX-based operating systems treat all input/output systems as ﬁles. Network connections are treated as ﬁles, your serial port is treated like a ﬁle, even your audio devices are treated as ﬁles. Communication between processes is usually done through special ﬁles called pipes. Some of these ﬁles have different methods of opening and creating them than regular ﬁles (i.e. - they don’t use the open system call), but they can all be read from and written to using the standard read and write system calls.
Using Files in a Program
We are going to write a simple program to illustrate these concepts. The program will take two ﬁles, and read from one, convert all of its lower-case letters to upper-case, and write to the other ﬁle. Before we do so, let’s think about what we need to do to get the job done:
• Have a function that takes a block of memory and converts it to upper-case. This function would need an address of a block of memory and its size as
79

Chapter 5. Dealing with Files
parameters.
• Have a section of code that repeatedly reads in to a buffer, calls our conversion function on the buffer, and then writes the buffer back out to the other ﬁle.
• Begin the program by opening the necessary ﬁles.
Notice that I’ve speciﬁed things in reverse order that they will be done. That’s a useful trick in writing complex programs - ﬁrst decide the meat of what is being done. In this case, it’s converting blocks of characters to upper-case. Then, you think about what all needs to be setup and processed to get that to happen. In this case, you have to open ﬁles, and continually read and write blocks to disk. One of the keys of programming is continually breaking down problems into smaller and smaller chunks until it’s small enough that you can easily solve the problem. Then you can build these chunks back up until you have a working program.4
You may have been thinking that you will never remember all of these numbers being thrown at you - the system call numbers, the interrupt number, etc. In this program we will also introduce a new directive, .equ which should help out. .equ allows you to assign names to numbers. For example, if you did .equ LINUX_SYSCALL, 0x80, any time after that you wrote LINUX_SYSCALL, the assembler would substitue 0x80 for that. So now, you can write
int $LINUX_SYSCALL
which is much easier to read, and much easier to remember. Coding is complex, but there are a lot of things we can do like this to make it easier.
Here is the program. Note that we have more labels than we actually use for jumps, because some of them are just there for clarity. Try to trace through the program and see what happens in various cases. An in-depth explanation of the program will follow.
#PURPOSE: This program converts an input file
4. Maureen Sprankle’s Problem Solving and Programming Concepts is an excellent book on the problem-solving process applied to computer programming.
80

Chapter 5. Dealing with Files

#

to an output file with all letters

#

converted to uppercase.

#

#PROCESSING: 1) Open the input file

#

2) Open the output file

#

4) While we’re not at the end of the input file

#

a) read part of file into our memory buffer

#

b) go through each byte of memory

#

if the byte is a lower-case letter,

#

convert it to uppercase

#

c) write the memory buffer to output file

.section .data

#######CONSTANTS########

#system call numbers .equ SYS_OPEN, 5 .equ SYS_WRITE, 4 .equ SYS_READ, 3 .equ SYS_CLOSE, 6 .equ SYS_EXIT, 1

#options for open (look at #/usr/include/asm/fcntl.h for #various values. You can combine them #by adding them or ORing them) #This is discussed at greater length #in "Counting Like a Computer" .equ O_RDONLY, 0 .equ O_CREAT_WRONLY_TRUNC, 03101

#standard file descriptors .equ STDIN, 0 .equ STDOUT, 1

81

Chapter 5. Dealing with Files
.equ STDERR, 2

#system call interrupt .equ LINUX_SYSCALL, 0x80

.equ END_OF_FILE, 0 #This is the return value #of read which means we’ve #hit the end of the file

.equ NUMBER_ARGUMENTS, 2

.section .bss

#Buffer - this is where the data is loaded into

#

from the data file and written from

#

into the output file. This should

#

never exceed 16,000 for various

#

reasons.

.equ BUFFER_SIZE, 500

.lcomm BUFFER_DATA, BUFFER_SIZE

.section .text

#STACK POSITIONS

.equ ST_SIZE_RESERVE, 8

.equ ST_FD_IN, -4

.equ ST_FD_OUT, -8

.equ ST_ARGC, 0

#Number of arguments

.equ ST_ARGV_0, 4 #Name of program

.equ ST_ARGV_1, 8 #Input file name

.equ ST_ARGV_2, 12 #Output file name

.globl _start _start:
###INITIALIZE PROGRAM### #save the stack pointer

82

movl %esp, %ebp

Chapter 5. Dealing with Files

#Allocate space for our file descriptors #on the stack subl $ST_SIZE_RESERVE, %esp

open_files: open_fd_in:
###OPEN INPUT FILE### #open syscall movl $SYS_OPEN, %eax #input filename into %ebx movl ST_ARGV_1(%ebp), %ebx #read-only flag movl $O_RDONLY, %ecx #this doesn’t really matter for reading movl $0666, %edx #call Linux int $LINUX_SYSCALL

store_fd_in: #save the given file descriptor movl %eax, ST_FD_IN(%ebp)

open_fd_out: ###OPEN OUTPUT FILE### #open the file movl $SYS_OPEN, %eax #output filename into %ebx movl ST_ARGV_2(%ebp), %ebx #flags for writing to the file movl $O_CREAT_WRONLY_TRUNC, %ecx #mode for new file (if it’s created) movl $0666, %edx #call Linux

83

Chapter 5. Dealing with Files
int $LINUX_SYSCALL

store_fd_out: #store the file descriptor here movl %eax, ST_FD_OUT(%ebp)

###BEGIN MAIN LOOP### read_loop_begin:

###READ IN A BLOCK FROM THE INPUT FILE### movl $SYS_READ, %eax #get the input file descriptor movl ST_FD_IN(%ebp), %ebx #the location to read into movl $BUFFER_DATA, %ecx #the size of the buffer movl $BUFFER_SIZE, %edx #Size of buffer read is returned in %eax int $LINUX_SYSCALL

###EXIT IF WE’VE REACHED THE END### #check for end of file marker cmpl $END_OF_FILE, %eax #if found or on error, go to the end jle end_loop

continue_read_loop:

###CONVERT THE BLOCK TO UPPER CASE###

pushl $BUFFER_DATA

#location of buffer

pushl %eax

#size of the buffer

call convert_to_upper

popl %eax

#get the size back

addl $4, %esp

#restore %esp

###WRITE THE BLOCK OUT TO THE OUTPUT FILE###

84

#size of the buffer movl %eax, %edx movl $SYS_WRITE, %eax #file to use movl ST_FD_OUT(%ebp), %ebx #location of the buffer movl $BUFFER_DATA, %ecx int $LINUX_SYSCALL

Chapter 5. Dealing with Files

###CONTINUE THE LOOP### jmp read_loop_begin

end_loop:

###CLOSE THE FILES###

#NOTE - we don’t need to do error checking

#

on these, because error conditions

#

don’t signify anything special here

movl $SYS_CLOSE, %eax

movl ST_FD_OUT(%ebp), %ebx

int $LINUX_SYSCALL

movl $SYS_CLOSE, %eax movl ST_FD_IN(%ebp), %ebx int $LINUX_SYSCALL

###EXIT### movl $SYS_EXIT, %eax movl $0, %ebx int $LINUX_SYSCALL

#PURPOSE: # # #INPUT:

This function actually does the conversion to upper case for a block
The first parameter is the location

85

Chapter 5. Dealing with Files

#

of the block of memory to convert

#

The second parameter is the length of

#

that buffer

#

#OUTPUT: This function overwrites the current

#

buffer with the upper-casified version.

#

#VARIABLES:

#

%eax - beginning of buffer

#

%ebx - length of buffer

#

%edi - current buffer offset

#

%cl - current byte being examined

#

(first part of %ecx)

#

###CONSTANTS## #The lower boundary of our search .equ LOWERCASE_A, ’a’ #The upper boundary of our search .equ LOWERCASE_Z, ’z’ #Conversion between upper and lower case .equ UPPER_CONVERSION, ’A’ - ’a’

###STACK STUFF### .equ ST_BUFFER_LEN, 8 #Length of buffer .equ ST_BUFFER, 12 #actual buffer convert_to_upper: pushl %ebp movl %esp, %ebp

###SET UP VARIABLES### movl ST_BUFFER(%ebp), %eax movl ST_BUFFER_LEN(%ebp), %ebx movl $0, %edi

86

Chapter 5. Dealing with Files
#if a buffer with zero length was given #to us, just leave cmpl $0, %ebx je end_convert_loop

convert_loop: #get the current byte movb (%eax,%edi,1), %cl

#go to the next byte unless it is between #’a’ and ’z’ cmpb $LOWERCASE_A, %cl jl next_byte cmpb $LOWERCASE_Z, %cl jg next_byte

#otherwise convert the byte to uppercase

addb $UPPER_CONVERSION, %cl

#and store it back

movb %cl, (%eax,%edi,1)

next_byte:

incl %edi

#next byte

cmpl %edi, %ebx

#continue unless

#we’ve reached the

#end

jne convert_loop

end_convert_loop: #no return value, just leave movl %ebp, %esp popl %ebp ret

Type in this program as toupper.s, and then enter in the following commands:

87

Chapter 5. Dealing with Files
as toupper.s -o toupper.o ld toupper.o -o toupper
This builds a program called toupper, which converts all of the lowercase characters in a ﬁle to uppercase. For example, to convert the ﬁle toupper.s to uppercase, type in the following command:
./toupper toupper.s toupper.uppercase
You will now ﬁnd in the ﬁle toupper.uppercase an uppercase version of your original ﬁle. Let’s examine how the program works. The ﬁrst section of the program is marked CONSTANTS. In programming, a constant is a value that is assigned when a program assembles or compiles, and is never changed. I make a habit of placing all of my constants together at the beginning of the program. It’s only necessary to declare them before you use them, but putting them all at the beginning makes them easy to ﬁnd. Making them all upper-case makes it obvious in your program which values are constants and where to ﬁnd them.5 In assembly language, we declare constants with the .equ directive as mentioned before. Here, we simply give names to all of the standard numbers we’ve used so far, like system call numbers, the syscall interrupt number, and ﬁle open options. The next section is marked BUFFERS. We only use one buffer in this program, which we call BUFFER_DATA. We also deﬁne a constant, BUFFER_SIZE, which holds the size of the buffer. If we always refer to this constant rather than typing out the number 500 whenever we need to use the size of the buffer, if it later changes, we only need to modify this value, rather than having to go through the entire program and changing all of the values individually. Instead of going on the the _start section of the program, go to the end where we deﬁne the convert_to_upper function. This is the part that actually does the
5. This is fairly standard practice among programmers in all languages.
88

Chapter 5. Dealing with Files
conversion.
This section begins with a list of constants that we will use The reason these are put here rather than at the top is that they only deal with this one function. We have these deﬁnitions:
.equ LOWERCASE_A, ’a’ .equ LOWERCASE_Z, ’z’ .equ UPPER_CONVERSION, ’A’ - ’a’
The ﬁrst two simply deﬁne the letters that are the boundaries of what we are searching for. Remember that in the computer, letters are represented as numbers. Therefore, we can use LOWERCASE_A in comparisons, additions, subtractions, or anything else we can use numbers in. Also, notice we deﬁne the constant UPPER_CONVERSION. Since letters are represented as numbers, we can subtract them. Subtracting an upper-case letter from the same lower-case letter gives us how much we need to add to a lower-case letter to make it upper case. If that doesn’t make sense, look at the ASCII code tables themselves (see Appendix D). You’ll notice that the number for the character A is 65 and the character a is 97. The conversion factor is then -32. For any lowercase letter if you add -32, you will get it’s capital equivalent.
After this, we have some constants labelled STACK POSITIONS. Remember that function parameters are pushed onto the stack before function calls. These constants (preﬁxed with ST for clarity) deﬁne where in the stack we should expect to ﬁnd each piece of data. The return address is at position 4 + %esp, the length of the buffer is at position 8 + %esp, and the address of the buffer is at position 12 + %esp. Using symbols for these numbers instead of the numbers themselves makes it easier to see what data is being used and moved.
Next comes the label convert_to_upper. This is the entry point of the function. The ﬁrst two lines are our standard function lines to save the stack pointer. The next two lines
movl ST_BUFFER(%ebp), %eax
89

Chapter 5. Dealing with Files
movl ST_BUFFER_LEN(%ebp), %ebx
move the function parameters into the appropriate registers for use. Then, we load zero into %edi. What we are going to do is iterate through each byte of the buffer by loading from the location %eax + %edi, incrementing %edi, and repeating until %edi is equal to the buffer length stored in %ebx. The lines
cmpl $0, %ebx je end_convert_loop
are just a sanity check to make sure that noone gave us a buffer of zero size. If they did, we just clean up and leave. Guarding against potential user and programming errors is an important task of a programmer. You can always specify that your function should not take a buffer of zero size, but it’s even better to have the function check and have a reliable exit plan if it happens. Now we start our loop. First, it moves a byte into %cl. The code for this is
movb (%eax,%edi,1), %cl
It is using an indexed indirect addressing mode. It says to start at %eax and go %edi locations forward, with each location being 1 byte big. It takes the value found there, and put it in %cl. After this it checks to see if that value is in the range of lower-case a to lower-case z. To check the range, it simply checks to see if the letter is smaller than a. If it is, it can’t be a lower-case letter. Likewise, if it is larger than z, it can’t be a lower-case letter. So, in each of these cases, it simply moves on. If it is in the proper range, it then adds the uppercase conversion, and stores it back into the buffer. Either way, it then goes to the next value by incrementing %cl;. Next it checks to see if we are at the end of the buffer. If we are not at the end, we jump back to the beginning of the loop (the convert_loop label). If we are at the end, it simply continues on to the end of the function. Because we are modifying the buffer directly, we don’t need to return anything to the calling program - the changes are
90

Chapter 5. Dealing with Files
already in the buffer. The label end_convert_loop is not needed, but it’s there so it’s easy to see where the parts of the program are.
Now we know how the conversion process works. Now we need to ﬁgure out how to get the data in and out of the ﬁles.
Before reading and writing the ﬁles we must open them. The UNIX open system call is what handles this. It takes the following parameters:
• %eax contains the system call number as usual - 5 in this case.
• %ebx contains a pointer to a string that is the name of the ﬁle to open. The string must be terminated with the null character.
• %ecx contains the options used for opening the ﬁle. These tell Linux how to open the ﬁle. They can indicate things such as open for reading, open for writing, open for reading and writing, create if it doesn’t exist, delete the ﬁle if it already exists, etc. We will not go into how to create the numbers for the options until the Section called Truth, Falsehood, and Binary Numbers in Chapter 10. For now, just trust the numbers we come up with.
• %edx contains the permissions that are used to open the ﬁle. This is used in case the ﬁle has to be created ﬁrst, so Linux knows what permissions to create the ﬁle with. These are expressed in octal, just like regular UNIX permissions.6
After making the system call, the ﬁle descriptor of the newly-opened ﬁle is stored in %eax.
So, what ﬁles are we opening? In this example, we will be opening the ﬁles speciﬁed on the command-line. Fortunately, command-line parameters are already stored by Linux in an easy-to-access location, and are already null-terminated. When a Linux program begins, all pointers to command-line arguments are stored on the stack. The number of arguments is stored at 8(%esp), the name of the program is stored at 12(%esp), and the arguments are stored from 16(%esp) on.
6. If you aren’t familiar with UNIX permissions, just put $0666 here. Don’t forget the leading zero, as it means that the number is an octal number.
91

Chapter 5. Dealing with Files
In the C Programming language, this is referred to as the argv array, so we will refer to it that way in our program.
The ﬁrst thing our program does is save the current stack position in %ebp and then reserve some space on the stack to store the ﬁle descriptors. After this, it starts opening ﬁles.
The ﬁrst ﬁle the program opens is the input ﬁle, which is the ﬁrst command-line argument. We do this by setting up the system call. We put the ﬁle name into %ebx, the read-only mode number into %ecx, the default mode of $0666 into %edx, and the system call number into %eax After the system call, the ﬁle is open and the ﬁle descriptor is stored in %eax.7 The ﬁle descriptor is then transferred to it’s appropriate place on the stack.
The same is then done for the output ﬁle, except that it is created with a write-only, create-if-doesn’t-exist, truncate-if-does-exist mode. Its ﬁle descriptor is stored as well.
Now we get to the main part - the read/write loop. Basically, we will read ﬁxed-size chunks of data from the input ﬁle, call our conversion function on it, and write it back to the output ﬁle. Although we are reading ﬁxed-size chunks, the size of the chunks don’t matter for this program - we are just operating on straight sequences of characters. We could read it in with as little or as large of chunks as we want, and it still would work properly.
The ﬁrst part of the loop is to read the data. This uses the read system call. This call just takes a ﬁle descriptor to read from, a buffer to write into, and the size of the buffer (i.e. - the maximum number of bytes that could be written). The system call returns the number of bytes actually read, or end-of-ﬁle (the number 0).
7. Notice that we don’t do any error checking on this. That is done just to keep the program simple. In normal programs, every system call should normally be checked for success or failure. In failure cases, %eax will hold an error code instead of a return value. Error codes are negative, so they can be detected by comparing %eax to zero and jumping if it is less than zero.
92

Chapter 5. Dealing with Files After reading a block, we check %eax for an end-of-ﬁle marker. If found, it exits the loop. Otherwise we keep on going. After the data is read, the convert_to_upper function is called with the buffer we just read in and the number of characters read in the previous system call. After this function executes, the buffer should be capitalized and ready to write out. The registers are then restored with what they had before. Finally, we issue a write system call, which is exactly like the read system call, except that it moves the data from the buffer out to the ﬁle. Now we just go back to the beginning of the loop. After the loop exits (remember, it exits if, after a read, it detects the end of the ﬁle), it simply closes its ﬁle descriptors and exits. The close system call just takes the ﬁle descriptor to close in %ebx. The program is then ﬁnished!
Review
Know the Concepts
• Describe the lifecycle of a ﬁle descriptor. • What are the standard ﬁle descriptors and what are they used for? • What is a buffer? • What is the difference between the .data section and the .bss section? • What are the system calls related to reading and writing ﬁles?
93

Chapter 5. Dealing with Files
Use the Concepts
• Modify the toupper program so that it reads from STDIN and writes to STDOUT instead of using the ﬁles on the command-line.
• Change the size of the buffer. • Rewrite the program so that it uses storage in the .bss section rather than the
stack to store the ﬁle descriptors. • Write a program that will create a ﬁle called heynow.txt and write the words
"Hey diddle diddle!" into it.
Going Further
• What difference does the size of the buffer make? • What error results can be returned by each of these system calls? • Make the program able to either operate on command-line arguments or use
STDIN or STDOUT based on the number of command-line arguments speciﬁed by ARGC. • Modify the program so that it checks the results of each system call, and prints out an error message to STDOUT when it occurs.
94

